{"meta":{"title":"不荒废现在,不畏惧未来🌸","subtitle":"","description":"💕一个二次元的个人博客网站💕","author":"CodeAnime","url":"https://codeanime.cc","root":"/"},"pages":[{"title":"about","date":"2021-08-05T16:56:12.000Z","updated":"2021-09-01T07:17:40.315Z","comments":false,"path":"about/index.html","permalink":"https://codeanime.cc/about/index.html","excerpt":"","text":""},{"title":"animations","date":"2021-08-07T12:30:42.000Z","updated":"2021-08-30T06:09:27.418Z","comments":false,"path":"animations/index.html","permalink":"https://codeanime.cc/animations/index.html","excerpt":"","text":""},{"title":"bangumis","date":"2021-08-30T06:09:54.000Z","updated":"2021-08-30T06:10:34.746Z","comments":false,"path":"bangumis/index.html","permalink":"https://codeanime.cc/bangumis/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-08-05T06:59:37.000Z","updated":"2021-08-05T07:02:04.857Z","comments":false,"path":"tags/index.html","permalink":"https://codeanime.cc/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-08-07T12:03:16.000Z","updated":"2021-08-07T12:03:54.324Z","comments":false,"path":"categories/index.html","permalink":"https://codeanime.cc/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"MySQL事务小记","slug":"MySQL事务小记","date":"2021-10-14T13:25:28.000Z","updated":"2021-10-14T13:27:22.147Z","comments":true,"path":"MySQL事务小记.html","link":"","permalink":"https://codeanime.cc/MySQL%E4%BA%8B%E5%8A%A1%E5%B0%8F%E8%AE%B0.html","excerpt":"","text":"MySQL事务小记一.什么是事务事务:一个最小的不可再分的工作单元 通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务就是一个最小的工作单元), 一个完整的业务需要批量的DML(insert、update、delete)语句共同联合完成. 事务只和DML语句有关，或者说DML语句才有事务。这个和业务逻辑有关，业务逻辑不同，DML语句的个数不同 二.事务的四大特征(ACID) 原子性(Atomicity): 事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。 一致性(Consistency): 事务开始之前、执行中、执行完毕，这些时间点，多个人去观察事务操作的数据的时候，看到的数据都是一致的。 隔离性(Isolation): 一个事务的执行不能被其他事务干扰。每个事务的执行过程是相对独立的； 持久性(Durability): 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 三.事务中的并发问题 脏读: 脏读又称无效数据的读出, 一个事务在执行的过程中读取到了其他事务还没有提交的数据。例如:事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据 读已提交: 一个事务操作过程中可以读取到其他事务已经提交的数据。事务中的每次读取操作，读取到的都是数据库中其他事务已提交的最新的数据 可重复读:一个事务操作中对于一个读取操作不管多少次，读取到的结果都是一样的。 不可重复读: 事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。 幻读: 事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，成为幻读。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://codeanime.cc/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://codeanime.cc/tags/MySQL/"},{"name":"事务","slug":"事务","permalink":"https://codeanime.cc/tags/%E4%BA%8B%E5%8A%A1/"}]},{"title":"MyBatis小记","slug":"MyBatis小记","date":"2021-10-11T14:11:14.000Z","updated":"2021-10-11T14:16:38.318Z","comments":true,"path":"MyBatis小记.html","link":"","permalink":"https://codeanime.cc/MyBatis%E5%B0%8F%E8%AE%B0.html","excerpt":"","text":"MyBatis小记为什么要用Mybatis? jdbc缺点: 缺点一：重复代码太多，这样会让开发效率降低。（比较繁琐，有一些代码是“没有必要的重复”） 缺点二：JDBC开发当中sql语句是编写在java程序当中的，sql语句不支持配置。sql语句可能后期需要调优，sql语句被修改的概率还是很高的。在java程序中编写sql语句，后期修改sql语句的时候，需要重新修改java源代码，源代码的修改会导致重新编译/重新部署等操作。并且修改java源代码已经违背了开闭原则：OCP。互联网分布式架构方面的项目，并发量很大，系统需要不断的优化，各方面优化，其中有一条非常重要的优化就是sql优化。 一. 我的第一个Mybatis程序:1.准备数据库新建一个数据库: create database mybatis; 新建一张表: create table student(id varchar(30),name varchar(30),birth varchar(30)); 插入数据: insert into student(id,name,birth) values('1' , 'zhangsan' , '20211010'); insert into student(id,name,birth) values('2' , 'lisi' , '20211011'); insert into student(id,name,birth) values('3' , 'wangwu' , '20211012'); commit; select * from student; 2.新建一个普通的java工程因为mybatis框架封装了JDBC。写一个main方法即可测试。 新建工程mybatis-project-laodu 在src同级目录下新建libs目录,把jar包引入到此目录 新建xml文件 新建mybatis-config.xml 新建sqlMapper.xml 在src目录下新建com/codeanime/main文件夹 在src目录下新建com/codeanime/test文件夹 3.引入相关的jar包mybatis-3.4.5.jar(mybatis核心jar) mysql-connector-java-5.1.23-bin.jar(mysql数据库驱动jar) 4.从xml中构建SqlSessionFactory4.1 编写main方法String resource = \"org/mybatis/example/mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); 注意: 什么是类路径？ bin是类的根路径, src可以等同看做类的根路径 修改main方法代码: String resource = \"mybatis-config.xml\"; 编辑mybatis-config.xml:核心配置文件主要配置连接数据库的信息，以及“sql语句配置文件”的路径。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?> &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"> &lt;configuration> &lt;environments default=\"development\"> &lt;environment id=\"development\"> &lt;transactionManager type=\"JDBC\" /> &lt;dataSource type=\"POOLED\"> &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\" /> &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis\" /> &lt;property name=\"username\" value=\"root\" /> &lt;property name=\"password\" value=\"123456\" /> &lt;/dataSource> &lt;/environment> &lt;/environments> &lt;mappers> &lt;mapper resource=\"org/mybatis/example/BlogMapper.xml\" /> &lt;/mappers> &lt;/configuration> 5.编写SqlMapper.xml提供一个配置sql语句的配置文件，通常这种文件一般都叫做：sql映射文件（SqlMapper.xml） 在类的根路径下新建一个SqlMapper.xml文件，修改mybatis-config.xml配置： &lt;mappers> &lt;mapper resource=\"SqlMapper.xml\" /> &lt;/mappers> 编辑SqlMapper.xml文件： &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?> &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> &lt;!-- 先不要管 namespace，随意编写一个。--> &lt;mapper namespace=\"1111111111\"> &lt;!-- 查询语句，查询所有的学生 --> &lt;!-- id具有唯一性，代表了这条sql语句，将来这个id是需要“拷贝”到java程序当中的。 --> &lt;!-- 思考：我们程序员需要告诉mybatis框架什么信息，mybatis才能自动创建对象，并且自动将查询的结果集放到java对象的对应属性上。 --> &lt;!-- 需要告诉mybatis，最终封装的java对象的类型。 --> &lt;!-- 需要告诉mybatis，最终查询出的结果集赋值到javabean的哪个属性上面，怎么告诉mybatis呢？ 查询结果集的列名要和javabean的属性名对应上，不对应的时候使用as关键字起别名。--> &lt;select id=\"getAll\" resultType=\"com.codeanime.mybatis.main.Student\"> select id as sid, name as sname , birth as sbirth from student &lt;/select> &lt;/mapper> 6.在main文件夹新建Student类作为javabeanpackage com.codeanime.mybatis.main; public class Student &#123; /* *注意：以下的属性名和数据库表当中的字段名不一致。 */ private String sid; private String sname; private String sbirth; public String getSid() &#123; return sid; &#125; public void setSid(String sid) &#123; this.sid = sid; &#125; public String getSname() &#123; return sname; &#125; public void setSname(String sname) &#123; this.sname = sname; &#125; public String getSbirth() &#123; return sbirth; &#125; public void setSbirth(String sbirth) &#123; this.sbirth = sbirth; &#125; &#125; 7.在test目录下新建MybatisTest01作为测试类package com.codeanime.mybatis.test; import java.io.IOException; import java.io.InputStream; import java.util.List; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import com.codeanime.mybatis.main.Student; public class MyBatisTest01 &#123; public static void main(String[] args) &#123; SqlSession sqlSession = null; try &#123; String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 事务自动提交机制关闭，等同于:conn.setAutoCommit(false); // SqlSession对象等同看做Connection，专门用来执行sql语句的一个会话对象。 // 开启事务 sqlSession = sqlSessionFactory.openSession(); // do work(执行核心业务逻辑) // 获取所有的学生，返回List集合，List集合中存储Student。 List&lt;Student> studentList = sqlSession.selectList(\"getAll\"); for(Student s : studentList)&#123; System.out.println(s.getSid() + \",\" + s.getSname() + \",\" + s.getSbirth()); &#125; // 没有出现异常，则事务结束，提交 sqlSession.commit(); &#125; catch (IOException e) &#123; // 遇到异常之后回滚 if (sqlSession != null)&#123; sqlSession.rollback(); &#125; e.printStackTrace(); &#125; finally &#123; // 关闭资源 if(sqlSession != null)&#123; sqlSession.close(); &#125; &#125; &#125; &#125; 运行test程序: 和数据库中一样: 二. 使用mybatis完成单张表的CRUDCRUD:增删改查 2.1 优化用户体验在类的根路径下，新建一个jdbc.properties文件。配置连接数据库的信息 jdbc.driver&#x3D;com.mysql.jdbc.Driver jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis jdbc.user&#x3D;root jdbc.password&#x3D;123456 然后在核心配置文件引入该资源文件。 &lt;properties resource=\"jdbc.properties\"/> 使用：语法。 注意：${jdbc.driver}这个不是EL表达式，是mybatis中自定制的语法机制。 ${属性文件中的key} 完整配置文件: &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?> &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"> &lt;configuration> &lt;!-- 引入外部独立的资源文件 --> &lt;properties resource=\"jdbc.properties\"/> &lt;environments default=\"development\"> &lt;environment id=\"development\"> &lt;transactionManager type=\"JDBC\" /> &lt;dataSource type=\"POOLED\"> &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\" /> &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /> &lt;property name=\"username\" value=\"$&#123;jdbc.user&#125;\" /> &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /> &lt;/dataSource> &lt;/environment> &lt;/environments> &lt;mappers> &lt;mapper resource=\"SqlMapper2.xml\" /> &lt;/mappers> &lt;/configuration> 编辑SqlMapper2配置文件: &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?> &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> &lt;mapper namespace=\"111111111111111111111111\"> &lt;insert id=\"save\" parameterType=\"com.codeanime.mybatis.main.Student\"> insert into student (id , name , birth) values (#&#123;stuId&#125; , #&#123;stuName&#125; , #&#123;stuBirth&#125;) &lt;/insert> &lt;/mapper> 插入数据: 编写类MyBtisCRUD: package com.codeanime.mybatis.test; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import com.codeanime.mybatis.main.Student; /** * 使用mybatis完成学生信息的增删改查（查一个/查所有） */ public class MyBatisCRUD &#123; public static void main(String[] args) &#123; SqlSession sqlSession = null; try &#123; /* * String resource = \"mybatis-config.xml\"; InputStream inputStream = * Resources.getResourceAsStream(resource); SqlSessionFactory * factory = new SqlSessionFactoryBuilder().build(inputStream); */ SqlSessionFactory factory = new SqlSessionFactoryBuilder() .build(Resources.getResourceAsStream(\"mybatis-config.xml\")); // 开启事务 sqlSession = factory.openSession(); // do work // insert Student stu = new Student(); stu.setStuId(\"123\"); stu.setStuName(\"zhangsan2\"); stu.setStuBirth(\"20211011\"); int count = sqlSession.insert(\"save\", stu); // 返回值是影响数据库表当中的记录条数。 System.out.println(count); // 提交事务 sqlSession.commit(); &#125; catch (Exception e) &#123; // 回滚事务 if (sqlSession != null) &#123; sqlSession.rollback(); &#125; e.printStackTrace(); &#125; finally &#123; // 释放资源 if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125; &#125; 运行结果: 运行成功返回影响行号 查看数据表: 数据表多了一条数据.表示插入成功 修改数据: 在类MyBtisCRUD中添加代码 // update Student stu = new Student(); stu.setStuId(\"123\"); stu.setStuName(\"zhangsan3\"); stu.setStuBirth(\"20211012\"); int count = sqlSession.update(\"update\", stu); System.out.println(count); MyBatis完整的代码: package com.codeanime.mybatis.test; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import com.codeanime.mybatis.main.Student; /** * 使用mybatis完成学生信息的增删改查（查一个/查所有） */ public class MyBatisCRUD &#123; public static void main(String[] args) &#123; SqlSession sqlSession = null; try &#123; /* * String resource = \"mybatis-config.xml\"; InputStream inputStream = * Resources.getResourceAsStream(resource); SqlSessionFactory * factory = new SqlSessionFactoryBuilder().build(inputStream); */ SqlSessionFactory factory = new SqlSessionFactoryBuilder() .build(Resources.getResourceAsStream(\"mybatis-config.xml\")); // 开启事务 sqlSession = factory.openSession(); // do work // insert //Student stu = new Student(); //stu.setStuId(\"123\"); //stu.setStuName(\"zhangsan2\"); //stu.setStuBirth(\"20211011\"); //int count = sqlSession.insert(\"save\", stu); // 返回值是影响数据库表当中的记录条数。 //System.out.println(count); // update Student stu = new Student(); stu.setStuId(\"123\"); stu.setStuName(\"zhangsan3\"); stu.setStuBirth(\"20211012\"); int count = sqlSession.update(\"update\", stu); System.out.println(count); // 提交事务 sqlSession.commit(); &#125; catch (Exception e) &#123; // 回滚事务 if (sqlSession != null) &#123; sqlSession.rollback(); &#125; e.printStackTrace(); &#125; finally &#123; // 释放资源 if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125; &#125; SqlMapper2.xml中添加代码: &lt;update id=\"update\" parameterType=\"Student\" > update student set name = #&#123;stuName&#125; , birth = #&#123;stuBirth&#125; where id = #&#123;stuId&#125; &lt;/update> SqlMapper2.xml完整代码: &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?> &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> &lt;mapper namespace=\"111111111111111111111111\"> &lt;insert id=\"save\" parameterType=\"com.codeanime.mybatis.main.Student\"> insert into student (id , name , birth) values (#&#123;stuId&#125; , #&#123;stuName&#125; , #&#123;stuBirth&#125;) &lt;/insert> &lt;update id=\"update\" parameterType=\"com.codeanime.mybatis.main.Student\" > update student set name = #&#123;stuName&#125; , birth = #&#123;stuBirth&#125; where id = #&#123;stuId&#125; &lt;/update> &lt;/mapper> 运行代码: 查看数据库: 发现数据库数据已经改变.表示修改成功 查询一条数据: 在MyBtisCRUD类中填加代码: Student stu = sqlSession.selectOne(\"getById\", \"123\"); System.out.println(stu.getStuId()); System.out.println(stu.getStuName()); System.out.println(stu.getStuBirth()); 完整代码: package com.codeanime.mybatis.test; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import com.codeanime.mybatis.main.Student; /** * 使用mybatis完成学生信息的增删改查（查一个/查所有） */ public class MyBatisCRUD &#123; public static void main(String[] args) &#123; SqlSession sqlSession = null; try &#123; /* * String resource = \"mybatis-config.xml\"; InputStream inputStream = * Resources.getResourceAsStream(resource); SqlSessionFactory * factory = new SqlSessionFactoryBuilder().build(inputStream); */ SqlSessionFactory factory = new SqlSessionFactoryBuilder() .build(Resources.getResourceAsStream(\"mybatis-config.xml\")); // 开启事务 sqlSession = factory.openSession(); // do work // insert //Student stu = new Student(); //stu.setStuId(\"123\"); //stu.setStuName(\"zhangsan2\"); //stu.setStuBirth(\"20211011\"); //int count = sqlSession.insert(\"save\", stu); // 返回值是影响数据库表当中的记录条数。 //System.out.println(count); // update /* Student stu = new Student(); stu.setStuId(\"123\"); stu.setStuName(\"zhangsan3\"); stu.setStuBirth(\"20211012\"); int count = sqlSession.update(\"update\", stu); System.out.println(count); */ // selectOne Student stu = sqlSession.selectOne(\"getById\", \"123\"); System.out.println(stu.getStuId()); System.out.println(stu.getStuName()); System.out.println(stu.getStuBirth()); // 提交事务 sqlSession.commit(); &#125; catch (Exception e) &#123; // 回滚事务 if (sqlSession != null) &#123; sqlSession.rollback(); &#125; e.printStackTrace(); &#125; finally &#123; // 释放资源 if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125; &#125; 在SqlMapper2.xml添加代码: &lt;!-- parameterType是参数类型,专门负责给sql语句传值 但是可以省略不写 --> &lt;!-- resultType是查询结果集的类型,只有在select语句中才会有 --> &lt;!-- parameterType = \"简单类型\",则parameter可以省略 resultType = \"简单类型\",不能省略. 什么是简单类型:17个 byte short int long float double boolean char Byte Short Integer Long Float Double Boolean Character String --> &lt;select id=\"getById\" parameterType=\"java.lang.String\" resultType=\"com.codeanime.mybatis.main.Student\"> select id as stuId, name as stuName, birth as stuBirth&lt;!-- 列名和javabean的属性名必须一致,不一致,使用别名 ,因为Student类的属性名和数据库中student表的属性名不一致--> from student where id = #&#123;11111111111&#125; &lt;!-- 当一个sql语句的占位符只有一个,这个时候#&#123;这里的内容随意编写&#125; --> &lt;/select> 运行代码: 对比数据库: 查询所有: 在MyBtisCRUD类中填加代码: List&lt;Student> stuList = sqlSession.selectList(\"getAll\"); for(Student s : stuList)&#123; System.out.println(s.getStuId()); &#125; 在SqlMapper2.xml添加代码: &lt;select id=\"getAll\" resultType=\"com.codeanime.mybatis.main.Student\"> select id as stuId, name as stuName, birth as stuBirth from student &lt;/select> 运行代码: 对比数据库: 删除数据: 在MyBtisCRUD类中填加代码: int count = sqlSession.delete(\"deleteById\", \"123\"); System.out.println(count); 在SqlMapper2.xml添加代码: &lt;delete id=\"deleteById\"> delete from student where id = #&#123;22222222222&#125; &lt;/delete> 运行代码: 对比数据库: 发现数据库中id为123的数据被删除. 附上完整代码: MyBtisCRUD package com.codeanime.mybatis.test; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import com.codeanime.mybatis.main.Student; import java.util.List; /** * 使用mybatis完成学生信息的增删改查（查一个/查所有） */ public class MyBatisCRUD &#123; public static void main(String[] args) &#123; SqlSession sqlSession = null; try &#123; /* * String resource = \"mybatis-config.xml\"; InputStream inputStream = * Resources.getResourceAsStream(resource); SqlSessionFactory * factory = new SqlSessionFactoryBuilder().build(inputStream); */ SqlSessionFactory factory = new SqlSessionFactoryBuilder() .build(Resources.getResourceAsStream(\"mybatis-config.xml\")); // 开启事务 sqlSession = factory.openSession(); // do work // insert //Student stu = new Student(); //stu.setStuId(\"123\"); //stu.setStuName(\"zhangsan2\"); //stu.setStuBirth(\"20211011\"); //int count = sqlSession.insert(\"save\", stu); // 返回值是影响数据库表当中的记录条数。 //System.out.println(count); // update /* Student stu = new Student(); stu.setStuId(\"123\"); stu.setStuName(\"zhangsan3\"); stu.setStuBirth(\"20211012\"); int count = sqlSession.update(\"update\", stu); System.out.println(count); */ // selectOne //Student stu = sqlSession.selectOne(\"getById\", \"123\"); //System.out.println(stu.getStuId()); //System.out.println(stu.getStuName()); //System.out.println(stu.getStuBirth()); // selectList //List&lt;Student> stuList = sqlSession.selectList(\"getAll\"); //for(Student s : stuList)&#123; // System.out.println(s.getStuId()); //&#125; // delete int count = sqlSession.delete(\"deleteById\", \"123\"); System.out.println(count); // 提交事务 sqlSession.commit(); &#125; catch (Exception e) &#123; // 回滚事务 if (sqlSession != null) &#123; sqlSession.rollback(); &#125; e.printStackTrace(); &#125; finally &#123; // 释放资源 if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125; &#125; Student类: package com.codeanime.mybatis.main; public class Student &#123; private String stuId; private String stuName; private String stuBirth; public String getStuId() &#123; return stuId; &#125; public void setStuId(String stuId) &#123; this.stuId = stuId; &#125; public String getStuName() &#123; return stuName; &#125; public void setStuName(String stuName) &#123; this.stuName = stuName; &#125; public String getStuBirth() &#123; return stuBirth; &#125; public void setStuBirth(String stuBirth) &#123; this.stuBirth = stuBirth; &#125; &#125; mybatis-config.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?> &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"> &lt;configuration> &lt;!-- 引入外部独立的资源文件 --> &lt;properties resource=\"jdbc.properties\"/> &lt;!-- mybatis的别名机制 --> &lt;!-- &lt;typeAliases> &lt;typeAlias type=\"com.codeanime.mybatis.main.Student\" alias=\"Student\"/> &lt;/typeAliases> --> &lt;typeAliases> &lt;!-- 使用package方式，那么该package包下的所有javabean会自动使用简类名作为别名。 --> &lt;package name=\"com.codeanime.mybatis.main\"/> &lt;/typeAliases> &lt;environments default=\"development\"> &lt;environment id=\"development\"> &lt;transactionManager type=\"JDBC\" /> &lt;dataSource type=\"POOLED\"> &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\" /> &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /> &lt;property name=\"username\" value=\"$&#123;jdbc.user&#125;\" /> &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /> &lt;/dataSource> &lt;/environment> &lt;/environments> &lt;mappers> &lt;mapper resource=\"SqlMapper2.xml\" /> &lt;/mappers> &lt;/configuration> SqlMapper2.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?> &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> &lt;mapper namespace=\"111111111111111111111111\"> &lt;insert id=\"save\" parameterType=\"com.codeanime.mybatis.main.Student\"> insert into student (id , name , birth) values (#&#123;stuId&#125; , #&#123;stuName&#125; , #&#123;stuBirth&#125;) &lt;/insert> &lt;update id=\"update\" parameterType=\"com.codeanime.mybatis.main.Student\" > update student set name = #&#123;stuName&#125; , birth = #&#123;stuBirth&#125; where id = #&#123;stuId&#125; &lt;/update> &lt;!-- parameterType是参数类型,专门负责给sql语句传值 但是可以省略不写 --> &lt;!-- resultType是查询结果集的类型,只有在select语句中才会有 --> &lt;!-- parameterType = \"简单类型\",则parameter可以省略 resultType = \"简单类型\",不能省略. 什么是简单类型:17个 byte short int long float double boolean char Byte Short Integer Long Float Double Boolean Character String --> &lt;select id=\"getById\" parameterType=\"java.lang.String\" resultType=\"com.codeanime.mybatis.main.Student\"> select id as stuId, name as stuName, birth as stuBirth&lt;!-- 列名和javabean的属性名必须一致,不一致,使用别名 ,因为Student类的属性名和数据库中student表的属性名不一致--> from student where id = #&#123;11111111111&#125; &lt;!-- 当一个sql语句的占位符只有一个,这个时候#&#123;这里的内容随意编写&#125; --> &lt;/select> &lt;select id=\"getAll\" resultType=\"com.codeanime.mybatis.main.Student\"> select id as stuId, name as stuName, birth as stuBirth from student &lt;/select> &lt;delete id=\"deleteById\"> delete from student where id = #&#123;22222222222&#125; &lt;/delete> &lt;/mapper> 三. 别名机制在**mybatis-config.xml**里添加: &lt;!-- mybatis的别名机制 --> &lt;!-- &lt;typeAliases> &lt;typeAlias type=\"com.codeanime.mybatis.main.Student\" alias=\"Student\"/> &lt;/typeAliases> --> &lt;typeAliases> &lt;!-- 使用package方式，那么该package包下的所有javabean会自动使用简类名作为别名。 --> &lt;package name=\"com.codeanime.mybatis.main\"/> &lt;/typeAliases> 然后**SqlMapper2.xml**中所有的parameterType可以写成包中的类名(默认) &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?> &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> &lt;mapper namespace=\"111111111111111111111111\"> &lt;insert id=\"save\" parameterType=\"Student\"> insert into student (id , name , birth) values (#&#123;stuId&#125; , #&#123;stuName&#125; , #&#123;stuBirth&#125;) &lt;/insert> &lt;update id=\"update\" parameterType=\"Student\" > update student set name = #&#123;stuName&#125; , birth = #&#123;stuBirth&#125; where id = #&#123;stuId&#125; &lt;/update> &lt;!-- parameterType是参数类型,专门负责给sql语句传值 但是可以省略不写 --> &lt;!-- resultType是查询结果集的类型,只有在select语句中才会有 --> &lt;!-- parameterType = \"简单类型\",则parameter可以省略 resultType = \"简单类型\",不能省略. 什么是简单类型:17个 byte short int long float double boolean char Byte Short Integer Long Float Double Boolean Character String --> &lt;select id=\"getById\" parameterType=\"java.lang.String\" resultType=\"Student\"> select id as stuId, name as stuName, birth as stuBirth&lt;!-- 列名和javabean的属性名必须一致,不一致,使用别名 ,因为Student类的属性名和数据库中student表的属性名不一致--> from student where id = #&#123;11111111111&#125; &lt;!-- 当一个sql语句的占位符只有一个,这个时候#&#123;这里的内容随意编写&#125; --> &lt;/select> &lt;select id=\"getAll\" resultType=\"Student\"> select id as stuId, name as stuName, birth as stuBirth from student &lt;/select> &lt;delete id=\"deleteById\"> delete from student where id = #&#123;22222222222&#125; &lt;/delete> &lt;/mapper> 四.使用maven模块创建mybatis项目 创建student表(id,name,email,age) -- 创建student表 create table student( id int(11) not null primary key, name varchar(50) default null, email varchar(50) default null, age int(11) default null ); -- 插入一条数据 insert into student (id,name,email,age) values(1001,\"zhangsan\",\"zhangsan@163.com\",11); 新建一个空项目 新建maven模块 创建完成之后是这样子的: 然后, 在main目录下新建文件夹resources, 删除默认创建的App类和App测试类AppTest 处理之后结构是这样的: 整理pom.xml文件: 整理后的文件内容: &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;!--坐标--> &lt;groupId>com.codeanime&lt;/groupId> &lt;artifactId>project01&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;properties> &lt;project.build.sourceEncoding>UTF-8&lt;/project.build.sourceEncoding> &lt;maven.compiler.source>1.8&lt;/maven.compiler.source> &lt;maven.compiler.target>1.8&lt;/maven.compiler.target> &lt;/properties> &lt;!--依赖列表--> &lt;dependencies> &lt;!--单元测试--> &lt;dependency> &lt;groupId>junit&lt;/groupId> &lt;artifactId>junit&lt;/artifactId> &lt;version>4.11&lt;/version> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;/build> &lt;/project> 修改pom.xml文件 (1)加入mybatis依赖, mysql驱动,junit &lt;!--依赖列表--> &lt;dependencies> &lt;!--单元测试--> &lt;dependency> &lt;groupId>junit&lt;/groupId> &lt;artifactId>junit&lt;/artifactId> &lt;version>4.11&lt;/version> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;!-- mybatis依赖 --> &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --> &lt;dependency> &lt;groupId>org.mybatis&lt;/groupId> &lt;artifactId>mybatis&lt;/artifactId> &lt;version>3.5.2&lt;/version> &lt;/dependency> &lt;!-- mysql驱动 --> &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;version>5.1.46&lt;/version> &lt;/dependency> &lt;/dependencies> (2)在中加入资源插件 &lt;build> &lt;!--资源插件 处理src/main/java目录下的xml--> &lt;resources> &lt;resource> &lt;directory>src/main/java&lt;/directory>&lt;!--所在的目录--> &lt;includes>&lt;!--包括目录下的.properties,.xml 文件都会扫描到--> &lt;include>**/*.properties&lt;/include> &lt;include>**/*.xml&lt;/include> &lt;/includes> &lt;filtering>false&lt;/filtering> &lt;/resource> &lt;/resources> &lt;plugins> &lt;!-- 指定jdk版本的插件,可加可不加,因为在上面已经指定过jdk的版本 --> &lt;plugin> &lt;artifactId>maven-compiler-plugin&lt;/artifactId> &lt;version>3.1&lt;/version> &lt;configuration> &lt;source>1.8&lt;/source> &lt;target>1.8&lt;/target> &lt;/configuration> &lt;/plugin> &lt;/plugins> &lt;/build> 完整pom.xml配置: &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;!--坐标--> &lt;groupId>com.codeanime&lt;/groupId> &lt;artifactId>project01&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;properties> &lt;project.build.sourceEncoding>UTF-8&lt;/project.build.sourceEncoding> &lt;maven.compiler.source>1.8&lt;/maven.compiler.source> &lt;maven.compiler.target>1.8&lt;/maven.compiler.target> &lt;/properties> &lt;!--依赖列表--> &lt;dependencies> &lt;!--单元测试--> &lt;dependency> &lt;groupId>junit&lt;/groupId> &lt;artifactId>junit&lt;/artifactId> &lt;version>4.11&lt;/version> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;!-- mybatis依赖 --> &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --> &lt;dependency> &lt;groupId>org.mybatis&lt;/groupId> &lt;artifactId>mybatis&lt;/artifactId> &lt;version>3.5.2&lt;/version> &lt;/dependency> &lt;!-- mysql驱动 --> &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;version>5.1.46&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;!--资源插件 处理src/main/java目录下的xml--> &lt;resources> &lt;resource> &lt;directory>src/main/java&lt;/directory>&lt;!--所在的目录--> &lt;includes>&lt;!--包括目录下的.properties,.xml 文件都会扫描到--> &lt;include>**/*.properties&lt;/include> &lt;include>**/*.xml&lt;/include> &lt;/includes> &lt;filtering>false&lt;/filtering> &lt;/resource> &lt;/resources> &lt;plugins> &lt;!-- 指定jdk版本的插件,可加可不加,因为在上面已经指定过jdk的版本 --> &lt;plugin> &lt;artifactId>maven-compiler-plugin&lt;/artifactId> &lt;version>3.1&lt;/version> &lt;configuration> &lt;source>1.8&lt;/source> &lt;target>1.8&lt;/target> &lt;/configuration> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> 出国年间实体类Student, 定义属性,属性名和列名保持一致 package com.codeanime.domain; public class Student &#123; private Integer id; private String name; private String email; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"学生实体信息&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", email='\" + email + '\\'' + \", age=\" + age + '&#125;'; &#125; &#125; 创建Dao接口, 定义操作数据库方法 package com.codeanime.dao; import com.codeanime.domain.Student; public interface StudentDao &#123; &#x2F;&#x2F;查询一个学生 Student selectStudentById(Integer id); &#125; 创建xml文件(mapper文件),写sql语句 mybatis框架是把sql语句和java代码分开 mapper文件:定义和dao接口在同一目录,一个表一个mapper文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?> &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> &lt;mapper namespace=\"com.codeanime.dao.StudentDao\"> &lt;!-- &lt;select id=\"selectBlog\" resultType=\"Blog\">--> &lt;!-- select * from Blog where id = #&#123;id&#125;--> &lt;!-- &lt;/select>--> &lt;!--查询一个学生Student &lt;select>: 表示查询操作,里面是select语句 id: 要执行的sql语句的唯一标识,是一个自定义的字符串 推荐使用dao接口中的方法名称 resultType: 告诉mybatis,执行sql语句,把数据赋值给那个类型的java对象 resultType的值现在使用的是java对象的全限定名称 --> &lt;select id=\"selectStudentById\" resultType=\"com.codeanime.domain.Student\"> select id,name,email,age from student where id=1001 &lt;/select> &lt;/mapper> &lt;!-- 1.约束文件 http://mybatis.org/dtd/mybatis-3-mapper.dtd 约束文件的作用: 定义和限制当前文件中可以出现的标签和属性,以及标签出现的顺序 2.mapper是根标签 namespace: 命名空间,必须有值,不能为空,唯一值. 推荐使用Dao接口的全限定名称. 作用: 参与识别sql语句的作用. 3.在mapper里面可以写&lt;insert>,&lt;update>,&lt;delete>,&lt;select> &lt;insert>里面是insert语句,表示执行的insert操作 ... --> 创建mybatis的主配置文件(xml文件):有一个, 放在resources目录下 (1)定义创建连接实例的数据源(DataSource)对象 (2)指定其他mapper文件的位置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?> &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"> &lt;configuration> &lt;environments default=\"development\"> &lt;environment id=\"development\"> &lt;transactionManager type=\"JDBC\"/> &lt;!--配置数据源: 创建Connection对象--> &lt;dataSource type=\"POOLED\"> &lt;!--driver:驱动的内容--> &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/> &lt;!-- &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/>--> &lt;!--连接数据库url--> &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8\"/> &lt;!-- &lt;property name=\"url\" value=\"$&#123;url&#125;\"/>--> &lt;!--用户名--> &lt;property name=\"username\" value=\"root\"/> &lt;!-- &lt;property name=\"username\" value=\"$&#123;username&#125;\"/>--> &lt;!--密码--> &lt;property name=\"password\" value=\"123456\"/> &lt;!-- &lt;property name=\"password\" value=\"$&#123;password&#125;\"/>--> &lt;/dataSource> &lt;/environment> &lt;/environments> &lt;!--指定其他mapper文件的位置: 指定其他的mapper文件目的是找到其他文件的sql语句 --> &lt;mappers> &lt;!--使用mapper的resource属性指定mapper文件的路径 这个路径是从target/classed路径开启的 使用注意: resource=\"mapper文件的路径,只用 / 分割路径\" 一个mapper resource指定一个mapper文件 --> &lt;mapper resource=\"com/codeanime/dao/StudentDao.xml\"/> &lt;/mappers> &lt;/configuration> 创建测试的内容 使用main方法,测试mybatis访问数据库 也可以使用junit访问数据库 创建MyTest类测试: package com.codeanime; import com.codeanime.domain.Student; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.junit.Test; import java.io.IOException; import java.io.InputStream; public class MyTest &#123; //测试mybatis执行sql语句 @Test public void testSelectStudentById() throws IOException &#123; //调用mybatis讴歌对象的方法,执行mapper文件中的sql语句 //mybatis核心类:SqlSessionFactory //1.定义mybatis主配置文件的位置,从类路径开始相对路径 String config = \"mybatis.xml\"; //2.读取主配置文件,使用mybatis框架中的Resources类 InputStream inputStream = Resources.getResourceAsStream(config); //3.创建SqlSessionFactory对象,使用SqlSessionFactoryBuild类 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); //4.获取SqlSession对象 SqlSession session = factory.openSession(); //5.指定要执行的sql语句的id // sql的id = nameSpace+\".\"+select|update|insert|delete标签的id属性值 String sqlId = \"com.codeanime.dao.StudentDao\"+\".\"+\"selectStudentById\"; //6.通过SqlSession的方法,执行sql语句 Student student = session.selectOne(sqlId); System.out.println(\"使用mybatis查询一个学生:\"+student); //7.关闭SqlSession对象 session.close(); &#125; &#125; 运行测试程序: 五.mybatis概念1.占位符用一个占位符替换这个id 修改: #&#123;studentId&#125;:占位符,表示从java程序中传入过来的数据 &lt;select id=\"selectStudentById\" resultType=\"com.codeanime.domain.Student\"> select id,name,email,age from student where id = #&#123;studentId&#125; &lt;/select> 在测试类里面添加一个方法2: @Test public void testSelectStudentById2() throws IOException &#123; //调用mybatis讴歌对象的方法,执行mapper文件中的sql语句 //mybatis核心类:SqlSessionFactory //1.定义mybatis主配置文件的位置,从类路径开始相对路径 String config = \"mybatis.xml\"; //2.读取主配置文件,使用mybatis框架中的Resources类 InputStream inputStream = Resources.getResourceAsStream(config); //3.创建SqlSessionFactory对象,使用SqlSessionFactoryBuild类 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); //4.获取SqlSession对象 SqlSession session = factory.openSession(); //5.指定要执行的sql语句的id // sql的id = nameSpace+\".\"+select|update|insert|delete标签的id属性值 String sqlId = \"com.codeanime.dao.StudentDao\"+\".\"+\"selectStudentById\"; //6.通过SqlSession的方法,执行sql语句 Student student = session.selectOne(sqlId,1001);//&lt;--------------修改,传入id的值为1001 System.out.println(\"使用mybatis查询一个学生:\"+student); //7.关闭SqlSession对象 session.close(); 运行测试方法2: 2.日志在配置文件mybatis.xml中添加日志配置: &lt;settings> &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/> &lt;/settings> 再运行测试方法2: 3.事务(1)自动提交:当你的sql语句执行完毕后,提交事务,数据库更新操作直接保存数据 (2) 3.1 在接口StudentDao中添加代码实现插入操作接口中每一个方法对应一条sql语句 //添加一个学生(返回值int表示本次操作影响的数据库行数) int insertStudent(Student student); 3.2 在mapper(StudentDao.xml)配置中添加代码&lt;!-- 添加insert --> &lt;insert id=\"insertStudent\"> insert into student values(1002,\"lisi\",\"lisi@163.com\",18) &lt;/insert> 3.3 在MyTest类中添加测试方法insertStudent因为绝大多数代码都是重复的,所以可以直接复制上一个测试方法 @Test public void testInsertStudent() throws IOException &#123; String config = \"mybatis.xml\"; InputStream inputStream = Resources.getResourceAsStream(config); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession session = factory.openSession(); String sqlId = \"com.codeanime.dao.StudentDao\"+\".\"+\"insertStudent\"; int rows = session.insert(sqlId); System.out.println(\"使用mybatis添加一个学生,rows = \"+rows); session.close(); &#125; 执行测试方法: 测试方法执行成功,而且影响行数为:1 问题来了: 当检查数据库到底插入进去了没有时, 发现没有,那么问题出在哪里,我们仔细观察刚才的日志,发现自动提交事务关闭了! 解决: 在测试方法中添加提交事务代码: //mybatis默认执行sql语句是,手动提交事务模式,在左insert,delete,update时需要提交事务 session.commit(); 再次执行代码,并检查数据库: 成功! insert语句使用占位符: 在测试分类MyTest中添加测试方法testInsertStudent2 @Test public void testInsertStudent2() throws IOException &#123; String config = \"mybatis.xml\"; InputStream inputStream = Resources.getResourceAsStream(config); //3.创建SqlSessionFactory对象,使用SqlSessionFactoryBuild类 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); //4.获取SqlSession对象 SqlSession session = factory.openSession(); //5.指定要执行的sql语句的id // sql的id = nameSpace+\".\"+select|update|insert|delete标签的id属性值 String sqlId = \"com.codeanime.dao.StudentDao\"+\".\"+\"insertStudent2\"; Student student = new Student(); student.setId(1003); student.setName(\"wangwu\"); student.setEmail(\"wangwu@163.com\"); student.setAge(19); System.out.println(\"使用mybatis插入一个学生:\"+student); int rows = session.insert(sqlId,student); //mybatis默认执行sql语句是,手动提交事务模式,在左insert,delete,update时需要提交事务 session.commit(); //7.关闭SqlSession对象 session.close(); &#125; 在mapper配置文件(StudentDao.xml)中添加一条insert语句 &lt;!-- insert占位符 如果传入给mybatis是一个java对象,使用#&#123;属性名&#125; 获取属性的值 属性值放到 #&#123;&#125;占位符的位置,mybatis执行此属性对应的getxxx() 例如,#&#123;id&#125;,执行getId(); --> &lt;insert id=\"insertStudent2\"> insert into student values(#&#123;id&#125;,#&#123;name&#125;,#&#123;email&#125;,#&#123;age&#125;) &lt;/insert> 执行测试方法testInsertStudent2: 对比一下数据库: 六.mybatis重要对象 Resources mybatis框架中的对象,作用就是:读取主配置信息 InputStream inputStream = Resources.getResourceAsStream(\"mybatis.xml\"); SqlSessionFactoryBuild 负责创建SqlSessionFactory对象 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); SqlSessionFactory 重要对象!!!!! 创建此对象需要更多的资源和时间. 在项目中有一个就可以了. SqlSessionFactory是一个接口:作用是SqlSession的工厂,就是创建SqlSession对象. DefaultSqlSessionFactory实现类 public class DefaultSqlSessionFactory implements SqlSessionFactory &#123;&#125; SqlSessionFactory接口中的方法: openSession():获取以恶搞默认的SqlSession对象,默认是手动提交事务的. openSession(boolean): boolean参数表示是否提交事务 true: 创建一个自动提交事务的SqlSession false: 等同于没有参数的openSession 自动提交事务,例如: @Test public void testInsertStudent2() throws IOException &#123; String config = \"mybatis.xml\"; InputStream inputStream = Resources.getResourceAsStream(config); //3.创建SqlSessionFactory对象,使用SqlSessionFactoryBuild类 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); //4.获取SqlSession对象 SqlSession session = factory.openSession(true); //5.指定要执行的sql语句的id // sql的id = nameSpace+\".\"+select|update|insert|delete标签的id属性值 String sqlId = \"com.codeanime.dao.StudentDao\"+\".\"+\"insertStudent2\"; Student student = new Student(); student.setId(1004); student.setName(\"zhaoliu\"); student.setEmail(\"zhaoliu@163.com\"); student.setAge(20); System.out.println(\"使用mybatis插入一个学生:\"+student); int rows = session.insert(sqlId,student); //mybatis默认执行sql语句是,手动提交事务模式,在左insert,delete,update时需要提交事务 //session.commit(); //7.关闭SqlSession对象 session.close(); &#125; SqlSession对象 SqlSession是通过SqlSessionFactory获取的,SqlSession本事就是接口 DefaultSqlSession实现类 public class DefaultSqlSession implements SqlSession &#123;&#125; SqlSession作用就是提供了大量的执行sql语句的方法 SelectOne:执行sql语句,最多得到一行记录,多余1行是错误 SelectList:执行sql语句,可以返回多行数据 SelectMap:执行sql语句,得到一个Map Insert:执行insert语句 update:执行update语句 delete:执行delete语句 commit:提交事务 rollback:回滚事务 注意: SqlSession对象不是线程安全的,使用的步骤: ①:在方法的内部,执行sql语句之前,先获取SqlSession对象 ②:调用SqlSession的方法,执行sql语句 ③:关闭SqlSession对象,执行SqlSession.close() 七.属性配置文件在resources目录下新建jdbc.properties文件 内容: jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8\" jdbc.username=root jdbc.password=123456 修改mybatis配置文件mybatis.xml &lt;configuration> &lt;!-- 外部的属性配置文件 resource:指定类路径下的某个属性配置文件 因为:resources目录下的文件最中编译到target/classes根目录下的 classes是类目录的根 resource=\"jdbc.properties\"指定的是classes目录下的某个文件 --> &lt;properties resource=\"jdbc.properties\" /> &lt;settings> &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/> &lt;/settings> &lt;environments default=\"development\"> &lt;environment id=\"development\"> &lt;transactionManager type=\"JDBC\"/> &lt;!--配置数据源: 创建Connection对象--> &lt;dataSource type=\"POOLED\"> &lt;!--driver:驱动的内容--> &lt;!-- &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>--> &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/> &lt;!--连接数据库url--> &lt;!-- &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8\"/>--> &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/> &lt;!--用户名--> &lt;!-- &lt;property name=\"username\" value=\"root\"/>--> &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/> &lt;!--密码--> &lt;!-- &lt;property name=\"password\" value=\"123456\"/>--> &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/> &lt;/dataSource> &lt;/environment> &lt;/environments> &lt;!--指定其他mapper文件的位置: 指定其他的mapper文件目的是找到其他文件的sql语句 --> &lt;/configuration> 运行代码测试无误即可. 八.完整的代码文件结构: pom.xml: &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;!--坐标--> &lt;groupId>com.codeanime&lt;/groupId> &lt;artifactId>project01&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;properties> &lt;project.build.sourceEncoding>UTF-8&lt;/project.build.sourceEncoding> &lt;maven.compiler.source>1.8&lt;/maven.compiler.source> &lt;maven.compiler.target>1.8&lt;/maven.compiler.target> &lt;/properties> &lt;!--依赖列表--> &lt;dependencies> &lt;!--单元测试--> &lt;dependency> &lt;groupId>junit&lt;/groupId> &lt;artifactId>junit&lt;/artifactId> &lt;version>4.11&lt;/version> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;!-- mybatis依赖 --> &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --> &lt;dependency> &lt;groupId>org.mybatis&lt;/groupId> &lt;artifactId>mybatis&lt;/artifactId> &lt;version>3.5.2&lt;/version> &lt;/dependency> &lt;!-- mysql驱动 --> &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;version>5.1.46&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;!--资源插件 处理src/main/java目录下的xml--> &lt;resources> &lt;resource> &lt;directory>src/main/java&lt;/directory>&lt;!--所在的目录--> &lt;includes>&lt;!--包括目录下的.properties,.xml 文件都会扫描到--> &lt;include>**/*.properties&lt;/include> &lt;include>**/*.xml&lt;/include> &lt;/includes> &lt;filtering>false&lt;/filtering> &lt;/resource> &lt;/resources> &lt;plugins> &lt;!-- 指定jdk版本的插件,可加可不加,因为在上面已经指定过jdk的版本 --> &lt;plugin> &lt;artifactId>maven-compiler-plugin&lt;/artifactId> &lt;version>3.1&lt;/version> &lt;configuration> &lt;source>1.8&lt;/source> &lt;target>1.8&lt;/target> &lt;/configuration> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> mybatis.xml: &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?> &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"> &lt;configuration> &lt;!-- 外部的属性配置文件 resource:指定类路径下的某个属性配置文件 因为:resources目录下的文件最中编译到target/classes根目录下的 classes是类目录的根 resource=\"jdbc.properties\"指定的是classes目录下的某个文件 --> &lt;properties resource=\"jdbc.properties\" /> &lt;settings> &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/> &lt;/settings> &lt;environments default=\"development\"> &lt;environment id=\"development\"> &lt;transactionManager type=\"JDBC\"/> &lt;!--配置数据源: 创建Connection对象--> &lt;dataSource type=\"POOLED\"> &lt;!--driver:驱动的内容--> &lt;!-- &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>--> &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/> &lt;!--连接数据库url--> &lt;!-- &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8\"/>--> &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/> &lt;!--用户名--> &lt;!-- &lt;property name=\"username\" value=\"root\"/>--> &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/> &lt;!--密码--> &lt;!-- &lt;property name=\"password\" value=\"123456\"/>--> &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/> &lt;/dataSource> &lt;/environment> &lt;/environments> &lt;!--指定其他mapper文件的位置: 指定其他的mapper文件目的是找到其他文件的sql语句 --> &lt;mappers> &lt;!--使用mapper的resource属性指定mapper文件的路径 这个路径是从target/classed路径开启的 使用注意: resource=\"mapper文件的路径,只用 / 分割路径\" 一个mapper resource指定一个mapper文件 --> &lt;mapper resource=\"com/codeanime/dao/StudentDao.xml\"/> &lt;/mappers> &lt;/configuration> StudentDao.xml(mapper): &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?> &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"> &lt;mapper namespace=\"com.codeanime.dao.StudentDao\"> &lt;!-- &lt;select id=\"selectBlog\" resultType=\"Blog\">--> &lt;!-- select * from Blog where id = #&#123;id&#125;--> &lt;!-- &lt;/select>--> &lt;!--查询一个学生Student &lt;select>: 表示查询操作,里面是select语句 id: 要执行的sql语句的唯一标识,是一个自定义的字符串 推荐使用dao接口中的方法名称 resultType: 告诉mybatis,执行sql语句,把数据赋值给那个类型的java对象 resultType的值现在使用的是java对象的全限定名称 #&#123;studentId&#125;:占位符,表示从java程序中传入过来的数据 --> &lt;select id=\"selectStudentById\" resultType=\"com.codeanime.domain.Student\"> select id,name,email,age from student where id = #&#123;studentId&#125; &lt;/select> &lt;!-- 添加insert --> &lt;insert id=\"insertStudent\"> insert into student values(1002,\"lisi\",\"lisi@163.com\",18) &lt;/insert> &lt;!-- insert占位符 如果传入给mybatis是一个java对象,使用#&#123;属性名&#125; 获取属性的值 属性值放到 #&#123;&#125;占位符的位置,mybatis执行此属性对应的getxxx() 例如,#&#123;id&#125;,执行getId(); --> &lt;insert id=\"insertStudent2\"> insert into student values(#&#123;id&#125;,#&#123;name&#125;,#&#123;email&#125;,#&#123;age&#125;) &lt;/insert> &lt;/mapper> &lt;!-- 1.约束文件 http://mybatis.org/dtd/mybatis-3-mapper.dtd 约束文件的作用: 定义和限制当前文件中可以出现的标签和属性,以及标签出现的顺序 2.mapper是根标签 namespace: 命名空间,必须有值,不能为空,唯一值. 推荐使用Dao接口的全限定名称. 作用: 参与识别sql语句的作用. 3.在mapper里面可以写&lt;insert>,&lt;update>,&lt;delete>,&lt;select> &lt;insert>里面是insert语句,表示执行的insert操作 ... --> jdbc.properties: jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8\" jdbc.username=root jdbc.password=123456 StudentDao接口: package com.codeanime.dao; import com.codeanime.domain.Student; public interface StudentDao &#123; //查询一个学生 Student selectStudentById(Integer id); //添加一个学生(返回值int表示本次操作影响的数据库行数) int insertStudent(Student student); &#125; Student类: package com.codeanime.domain; public class Student &#123; private Integer id; private String name; private String email; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"学生实体信息&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", email='\" + email + '\\'' + \", age=\" + age + '&#125;'; &#125; &#125; MyTest测试类: package com.codeanime; import com.codeanime.domain.Student; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.junit.Test; import java.io.IOException; import java.io.InputStream; public class MyTest &#123; //测试mybatis执行sql语句 @Test public void testSelectStudentById() throws IOException &#123; //调用mybatis讴歌对象的方法,执行mapper文件中的sql语句 //mybatis核心类:SqlSessionFactory //1.定义mybatis主配置文件的位置,从类路径开始相对路径 String config = \"mybatis.xml\"; //2.读取主配置文件,使用mybatis框架中的Resources类 InputStream inputStream = Resources.getResourceAsStream(config); //3.创建SqlSessionFactory对象,使用SqlSessionFactoryBuild类 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); //4.获取SqlSession对象 SqlSession session = factory.openSession(); //5.指定要执行的sql语句的id // sql的id = nameSpace+\".\"+select|update|insert|delete标签的id属性值 String sqlId = \"com.codeanime.dao.StudentDao\"+\".\"+\"selectStudentById\"; //6.通过SqlSession的方法,执行sql语句 Student student = session.selectOne(sqlId); System.out.println(\"使用mybatis查询一个学生:\"+student); //7.关闭SqlSession对象 session.close(); &#125; @Test public void testSelectStudentById2() throws IOException &#123; //调用mybatis讴歌对象的方法,执行mapper文件中的sql语句 //mybatis核心类:SqlSessionFactory //1.定义mybatis主配置文件的位置,从类路径开始相对路径 String config = \"mybatis.xml\"; //2.读取主配置文件,使用mybatis框架中的Resources类 InputStream inputStream = Resources.getResourceAsStream(config); //3.创建SqlSessionFactory对象,使用SqlSessionFactoryBuild类 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); //4.获取SqlSession对象 SqlSession session = factory.openSession(); //5.指定要执行的sql语句的id // sql的id = nameSpace+\".\"+select|update|insert|delete标签的id属性值 String sqlId = \"com.codeanime.dao.StudentDao\"+\".\"+\"selectStudentById\"; //6.通过SqlSession的方法,执行sql语句 Student student = session.selectOne(sqlId,1001); System.out.println(\"使用mybatis查询一个学生:\"+student); //7.关闭SqlSession对象 session.close(); &#125; @Test public void testInsertStudent() throws IOException &#123; String config = \"mybatis.xml\"; InputStream inputStream = Resources.getResourceAsStream(config); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession session = factory.openSession(); String sqlId = \"com.codeanime.dao.StudentDao\"+\".\"+\"insertStudent\"; int rows = session.insert(sqlId); System.out.println(\"使用mybatis添加一个学生,rows = \"+rows); //mybatis默认执行sql语句是,手动提交事务模式,在左insert,delete,update时需要提交事务 session.commit(); session.close(); &#125; @Test public void testInsertStudent2() throws IOException &#123; String config = \"mybatis.xml\"; InputStream inputStream = Resources.getResourceAsStream(config); //3.创建SqlSessionFactory对象,使用SqlSessionFactoryBuild类 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); //4.获取SqlSession对象 SqlSession session = factory.openSession(); //5.指定要执行的sql语句的id // sql的id = nameSpace+\".\"+select|update|insert|delete标签的id属性值 String sqlId = \"com.codeanime.dao.StudentDao\"+\".\"+\"insertStudent2\"; Student student = new Student(); student.setId(1003); student.setName(\"wangwu\"); student.setEmail(\"wangwu@163.com\"); student.setAge(19); System.out.println(\"使用mybatis插入一个学生:\"+student); int rows = session.insert(sqlId,student); //mybatis默认执行sql语句是,手动提交事务模式,在左insert,delete,update时需要提交事务 session.commit(); //7.关闭SqlSession对象 session.close(); &#125; &#125;","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://codeanime.cc/categories/MyBatis/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://codeanime.cc/tags/MySQL/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://codeanime.cc/tags/MyBatis/"},{"name":"mybatis","slug":"mybatis","permalink":"https://codeanime.cc/tags/mybatis/"},{"name":"maven","slug":"maven","permalink":"https://codeanime.cc/tags/maven/"}]},{"title":"Maven小记","slug":"Maven小记","date":"2021-10-10T01:28:12.000Z","updated":"2021-10-10T01:41:01.422Z","comments":true,"path":"Maven小记.html","link":"","permalink":"https://codeanime.cc/Maven%E5%B0%8F%E8%AE%B0.html","excerpt":"","text":"Maven小记一.Maven简介Maven是由Apache开发的一个工具软件。用来管理java项目，依赖管理(jar包的管理)，项目构建. 二.Maven的作用Maven的作用可以分成三类: 项目构建 依赖管理 统一开发结构 HelloMaven(Maven工程的根目录，目录名可以自定义) |-- pom.xml(Maven工程的核心配置文件) |-- src(存放源码的目录) |-- main(主程序，简单来说就是我们写的非测试代码) | |-- java(主程序的Java代码) | |-- resources(主程序的配置文件，xml文件，properties文件等) |-- test(测试程序) |-- java(测试程序的Java代码) |-- resources(测试程序的配置文件，xml文件，properties文件等) 三.Maven环境搭建3.1,下载maven压缩包maven官网:https://maven.apache.org/ maven下载地址:http://maven.apache.org/download.cgi 我下的.zip的 下载下来解压即可. 各目录的作用: bin：可执行程序目录， boot：maven自身的启动加载器 conf：maven配置文件的存放目录 lib：maven运行所需库的存放目录 3.2,配置环境变量配置JAVA_HOME—你的java安装目录 配置maven环境变量:在系统变量—Path—配置你的maven的bin目录 测试配置后的结果:—cmd–mvn -v 出现一堆信息表示配置成功. 四.Maven核心概念4.1 仓库仓库:用于存储资源，主要是各种jar包 maven仓库可以分为两种:本地仓库和远程仓库. **本地仓库:**开发者自己电脑上存储资源的仓库，也可从远程仓库获取资源 **远程仓库:**可以分为中央仓库和私服 中央仓库:maven团队维护的仓库, 仓库地址 私服:各公司/部门等小范围内存储资源的仓库，私服也可以从中央仓库获取资源 4.2 坐标坐标元素: groupId : 定义当前Maven项目组织名称（通常是域名反写，如：org.mybatis；） artifactId : 定义实际项目名称 version : 定义当前项目的当前版本或者是所依赖的jar包的版本 &lt;groupId>com.codeanime&lt;/groupId> &lt;artifactId>HelloMaven&lt;/artifactId> &lt;version>1.0.1&lt;/version> 坐标的作用: 使用唯一标识，唯一性定义资源位置，通过该标识可以将资源的识别与下载工作交由机器完成 4.3 生命周期Maven生命周期就是为了对所有的构建过程进行抽象和统一。包括项目清理、初始化、编译、打包、测 试、部署等几乎所有构建步骤。生命周期可以理解为构建工程的步骤。 maven生命周期（项目构建的过程）： 对项目进行清理、编译、测试、报告、打包、安装、部署上传到私服的过程。 清理（mvn clean）：它删除在构建编译和测试时在项目目录中生成target目录的文件。但是已经install到仓库里的包不会删除。编译（mvn compile）：maven可以批量的把程序源代码编译为执行代码（.java编译成.class），maven可以同时把成千上百的文件编译为class，javac不一样，javac一次编译一个文件。在pom.xml同级目录下生成target目录存放主程序编译之后的.class字节码文件。测试编译（mvn test-compile）：maven可以批量的同时执行测试程序代码以及测试功能，验证功能正确性，在pom.xml目录下生成target目录存放主程序编译之后的.class字节码文件。测试（mvn test）：maven可以批量的同时测试很多功能，在pom.xml同级目录下生成surefire-reports目录，保存测试结果。报告：生成测试结果的文件存放在surefire-reports目录，测试通过没有。打包（mvn package）：把你的项目中src/main/java目录下所有的.class文件，src/main/resources目录下配置文件等所有资源放到一个压缩文件中。这个压缩文件就是项目的结果文件，通常java程序，压缩文件是.jar扩展名的。对于web应用，压缩文件扩展名是.war。总而言之，会把编译、编译测试、测试、并且按照pom.xml配置把主程序打包生成jar包或者war包。安装（mvn install）：把打包（mvn package）中生成的文件jar、war安装到本地仓库。会把本工程打包，并且按照本工程的项目坐标（三个参数）保存到本地仓库中。部署（mvn deploy）：程序安装后可以执行，把本工程打包，按照本项目工程的项目坐标（三个参数）保存到本地仓库中，并且还会保存到私服仓库中以及自动把项目部署到web容器中。注意:执行以上命令必须在命令行进入pom.xml所在目录！ 常用命令: mvn -version 查看maven的版本及配置信息 mvn compile 编译项目代码 mvn package 打包项目 mvn test 运行单元测试 mvn clean 清除编译产生的target文件夹内容，可以配合相应命令一起使用，如mvn clean package， mvn clean test mvn install 打包后将其安装在本地仓库 mvn deploy 打包后将其安装到pom文件中配置的远程仓库 mvn site 生成站点目录 4.4 pom文件 pom.xml是maven的核心文件，是maven的灵魂。 pom.xml结构说明: 4.41 modelVersionMaven模型的版本，对于Maven2和Maven3来说，它只能是4.0.0 &lt;modelVersion>4.0.0&lt;/modelVersion> 4.42 groupid组织id,一般是公司域名的倒写: 例如:com.baidu或者com.baidu.project &lt;groupId>com.baidu&lt;/groupId> &lt;groupId>com.baidu.project&lt;/groupId> 4.43 artifactId项目名称，也是模块名称，对应groupId中项目中的子项目 &lt;artifactId>projectname&lt;/artifactId> 4.44 version项目版本号。如果项目还在开发中，是不稳定版本,通常在版本后带-SNAPSHOT，version使用三位数字标识，例如1.0.1 4.45 gavgroupId、artifactId、version三个元素合并在一起统称为项目坐标，项目坐标具有唯一性，称之为唯一值，在互联网中唯一标识一个项目的，在中央仓库中就是根据项目坐标的唯一值，在资源库中搜索下载相应的jar包 &lt;groupId>公司域名的倒序&lt;/groupId> &lt;artifactId>项目名称&lt;/artifactId> &lt;version>版本号&lt;/version> 假如,获取mysql5.0.8连接驱动，必须在pom.xml中声明mysql连接驱动在仓库中唯一性项目坐标搜索下载jar包。打开地址：https://mvnrepository.com/，键入mysql关键字找到对应版本。 &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;version>5.0.8&lt;/version> &lt;/dependency> 4.46 packaging项目打包的类型，可以是jar、rar、ear、pom，web应用是war， packaging可以不写，默认是jar 4.47 依赖（dependencies和dependency）项目中要使用的各种资源说明，比我的项目要使用mysql驱动，Maven的一个重要作用就是管理jar包，为了一个项目可以构建或运行，项目中不可避免的，会依赖很多其他的jar包，在 Maven中，这些jar就被称为依赖，使用标签dependency来配置。而这种依赖的配置正是通过坐标来定位的，由此我们也不难看出，maven把所有的jar包也都视为项目存在了 &lt;!-- 依赖 相当于java代码中的 import --> &lt;dependencies> &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;version>5.0.8&lt;/version> &lt;/dependency> &lt;!--单元测试程序的依赖 --> &lt;dependency> &lt;groupId>junit&lt;/groupId> &lt;artifactId>junit&lt;/artifactId> &lt;version>4.11&lt;/version> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;/dependencies> 4.48 propertiesproperties是用来定义一些配置属性的，例如project.build.sourceEncoding(项目构建源码编码方式)，可以设置为UTF-8，防止中文乱码，也可定义相关构建版本号，便于日后统一升级 &lt;!--配置属性 --> &lt;properties> &lt;!--构建源码编码方式 --> &lt;project.build.sourceEncoding>UTF-8&lt;/project.build.sourceEncoding> &lt;!--jdk版本 --> &lt;java.version>1.8&lt;/java.version> &lt;!--maven构建版本号 --> &lt;maven.compiler.source>1.8&lt;/maven.compiler.source> &lt;maven.compiler.target>1.8&lt;/maven.compiler.target> &lt;/properties> 4.49 bulid表示与构建相关的配置，例如设置编译插件的jdk版本、插件配置等。 例如，使用maven项目骨架快速创建java项目时，会自动生成一堆的maven生命周期的插件，都放在build中： &lt;build> &lt;pluginManagement>&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --> &lt;plugins> &lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --> &lt;plugin> &lt;artifactId>maven-clean-plugin&lt;/artifactId> &lt;version>3.1.0&lt;/version> &lt;/plugin> &lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --> &lt;plugin> &lt;artifactId>maven-resources-plugin&lt;/artifactId> &lt;version>3.0.2&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-compiler-plugin&lt;/artifactId> &lt;version>3.8.0&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-surefire-plugin&lt;/artifactId> &lt;version>2.22.1&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-jar-plugin&lt;/artifactId> &lt;version>3.0.2&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-install-plugin&lt;/artifactId> &lt;version>2.5.2&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-deploy-plugin&lt;/artifactId> &lt;version>2.8.2&lt;/version> &lt;/plugin> &lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --> &lt;plugin> &lt;artifactId>maven-site-plugin&lt;/artifactId> &lt;version>3.7.1&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-project-info-reports-plugin&lt;/artifactId> &lt;version>3.0.0&lt;/version> &lt;/plugin> &lt;/plugins> &lt;/pluginManagement> &lt;/build> 4.5 Maven命令和插件maven命令：maven独立使用，通过命令，完成maven的生命周期的执行。maven可以使用命令，完成项目的清理，编译，测试等等 maven的插件：maven命令执行时，真正完成功能的是插件，插件是一些jar文件，一些类 4.6 单元测试junit单元测试：用的是junit，是一个专门测试的框架（工具) junit测试内容：测试的是类中的方法，每一个方法都是独立测试的。方法是测试的基本单位(单元) maven借助单元测试，批量测试类中的大量方法是否符合预期的 使用: (1)在pom.xml中加入依赖 &lt;!--单元测试程序的依赖 --> &lt;dependency> &lt;groupId>junit&lt;/groupId> &lt;artifactId>junit&lt;/artifactId> &lt;version>4.11&lt;/version> &lt;scope>test&lt;/scope> &lt;/dependency> 五.Maven项目搭建5.1 仓库配置我们要在自己的电脑上开发,那么首先就是要配置本地仓库 在maven的配置文件conf/settings.xml中可以找到它的说明 &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository &lt;localRepository>/path/to/local/repo&lt;/localRepository> --> 修改为: &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository &lt;localRepository>/path/to/local/repo&lt;/localRepository> --> &lt;localRepository>E:\\maven-repository&lt;/localRepository> 5.2 Maven项目搭建HelloMaven //项目文件夹 \\src \\main //主程序目录(完成项目功能的代码和配置文件) \\java //源代码(包和相关的类定义) \\resources //配置文件 \\test //放置测试程序代码的 \\java //测试代码(junit) \\resources //测试程序需要的配置文件 \\pom.xml //maven的配置文件 5.2.1 手动搭建maven项目（1）在E盘下创建目录MavenProject并进入该目录，作为我们的操作目录 （2）创建我们的maven项目，创建一个目录project-java作为我们的项目文件夹，并进入到该目录 （3）创建java代码（源代码）所在目录，即创建src/main/java （4）创建配置文件所在目录，即创建src/main/resources （5）创建测试源代码所在目录，即创建src/test/java （6）创建测试存放配置文件存放目录，即src/test/resources （7）在src/main/java中创建一个包（注意在windos文件夹下就是创建目录）com/codeanime，在该目录下创建HelloMaven.java文件，作为演示所需java程序，内容如下: package com.codeanime; public class HelloMaven&#123; public static void main(String args[])&#123; HelloMaven hm = new HelloMaven(); int result = hm.addNumber(10,20); System.out.println(\"在main方法中执行addNumber方法\"+result); &#125; public int addNumber(int n1,int n2)&#123; System.out.println(\"HelloMaven--addNumber\"); return n1+n2; &#125; &#125; （8）在src/test/java中创建一个测试包（目录）com/codeanime，在该包下创建测试程序TestHelloMaven.java package com.codeanime; import org.junit.Assert; import org.junit.Test; public class TestHelloMaven&#123; //定义多个独立的测试方法,每个方法都是独立的 @test public void testAddNumber()&#123; System.out.println(\"执行测试方法testAddNumber\"); HelloMaven hm = new HelloMaven(); int result = hm.addNumber(10,20); //把计算结果result交给junit判断 //期望值,实际值 Assert.assertEquals(30,result); &#125; &#125; (9）在project-java/src下创建pom.xml文件，编辑如下 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;!--父工程--> &lt;groupId>com.codeanime&lt;/groupId> &lt;artifactId>project-java&lt;/artifactId> &lt;version>1.0.1&lt;/version> &lt;packaging>jar&lt;/packaging> &lt;!-- 导入依赖--> &lt;dependencies> &lt;!-- junit--> &lt;dependency> &lt;groupId>junit&lt;/groupId> &lt;artifactId>junit&lt;/artifactId> &lt;version>4.12&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;/project> 通过前面的操作，我们已经搭建好了maven的项目结构，下面要通过maven来构建我们的项目 maven的构建命令以mvn开头，后面添加功能参数，可以一次性执行多个命令，用空格分离 mvn compile：编译 mvn clean：清理 mvn test：测试 mvn package：打包 mvn install：安装到本地仓库 下面我们来进行操作： （1）进入priject-java目录(目录中有src和pom.xml)运行cmd,执行命令mvn compile: 第一次运行maven会下载很多东西 出现BUILD SUCESS说明成功: 编译完成后在项目project-java下多了一个目录target，在这个目录下就存放的是maven编译好的一些东西 我们可以进入到target目录查看 其中生成的classes目录就是编译好的字节码文件 （2）当然如果我们想清理掉这些东西，我们只需执行mvn clean命令即可，清理掉后target目录也就消失了 （3）如果我们要执行测试包中的测试程序，我们只需执行mvn test命令即可 期望值和实际值一致,则正常编译执行 如果把程序中期望值改为其他的: 例如: 则会抛出异常. (4）使用mvn package命令进行打包，如下 在生成的target目录中可以看到打包的结果 当然，如果仔细看DOS窗口输出的我们会发现，mvn package命令的时候maven会把前面两个命令mvn compile,mvn test都执行一遍 (5）使用mvn install命令进行安装，将项目打好的包存入本地仓库 仔细查看输出会发现mvn install命令执行的时候也会将前面的命令都执行一遍 此时我们可以去本地仓库中查找 maven是按照groupId/artifactId/version的结构在本地仓库进行存储 5.2.2 IDEA工具搭建maven项目前面学习的基本都是通过命令来构建和管理项目，但是这在实际开发过程中基本不常用，常用的是通过相关IDE工具来进行项目的构建和管理，因此我们使用IDEA工具进行maven项目的搭建 需要注意的是：Maven和IDEA在版本上存在一些兼容性问题，因为要合理的选择Maven和IDEA的版本，本课程中提供安装maven-3.6.1版本是可用的 -DarchetypeCatalog=internal maven 创建项目时,会从网络中下载一个archetype-catelog.xml作为项目模版文件,加上-DarchetypeCatalog=internal告诉maven创建项目时不要下载这个文件,加快创建maven项目的速度. 然后在设置这个,作用是对新建的或者导入的项目也使用同样的maven设置 设置跟刚才一样 创建maven模块 加载完毕即可 创建好的maven目录 那么如何使用maven呢 首先,编写java程序: package com.codeanime; public class HelloMaven &#123; public int addNumber(int n1,int n2)&#123; return n1+n2; &#125; public static void main(String[] args) &#123; HelloMaven helloMaven = new HelloMaven(); int result = helloMaven.addNumber(10,20); System.out.println(\"result = \"+result); &#125; &#125; 执行测试一下: 编写测试代码: package com.codeanime; import org.junit.Assert; import org.junit.Test; public class TestHelloMaven &#123; @Test public void testAddNumber1()&#123; System.out.println(\"testAddNumber1正在运行中-----------\"); HelloMaven helloMaven = new HelloMaven(); int result = helloMaven.addNumber(10, 20); Assert.assertEquals(30,result); &#125; @Test public void testAddNumber2()&#123; System.out.println(\"testAddNumber2正在运行中=============\"); HelloMaven helloMaven = new HelloMaven(); int result = helloMaven.addNumber(10, 20); Assert.assertEquals(30,result); &#125; &#125; 如果期望值和实际值不一样,则会抛出异常: Assert.assertEquals(40,result); maven使用技巧: 点击最右侧maven窗口: 可以使用和命令行一样的功能,至此,maven先学到这里了!","categories":[{"name":"Maven","slug":"Maven","permalink":"https://codeanime.cc/categories/Maven/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/tags/Java/"},{"name":"Maven","slug":"Maven","permalink":"https://codeanime.cc/tags/Maven/"}]},{"title":"Java多线程--sleep()方法小记","slug":"Java多线程-sleep-方法小记","date":"2021-10-06T14:01:38.000Z","updated":"2021-10-06T14:07:06.569Z","comments":true,"path":"Java多线程-sleep-方法小记.html","link":"","permalink":"https://codeanime.cc/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-sleep-%E6%96%B9%E6%B3%95%E5%B0%8F%E8%AE%B0.html","excerpt":"","text":"Java多线程–sleep()方法小记代码:package Thread01; public class TestThread01 &#123; public static void main(String[] args) &#123; Thread t = new MyThread(); t.setName(\"t\"); t.start(); try &#123; //这段代码会让线程t进入休眠吗? t.sleep(1000 * 5); //在执行的时候回转换成Thread.sleep(1000 * 5) &#125; catch (InterruptedException e) &#123; //作用:让当前线程进入休眠,也就是main线程 e.printStackTrace(); //sleep()方法为静态方法 &#125; System.out.println(\"Hello Thread!\"); &#125; &#125; class MyThread extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 100000; i++) &#123; System.out.println(Thread.currentThread().getName()+\"----->\"+i); &#125; &#125; &#125; 运行结果:五秒后打印Hello Thread!","categories":[{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://codeanime.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java线程安全问题-模拟对同一银行账户进行取款","slug":"Java线程安全问题-模拟对同一银行账户进行取款","date":"2021-10-06T14:01:27.000Z","updated":"2021-10-06T14:08:39.649Z","comments":true,"path":"Java线程安全问题-模拟对同一银行账户进行取款.html","link":"","permalink":"https://codeanime.cc/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-%E6%A8%A1%E6%8B%9F%E5%AF%B9%E5%90%8C%E4%B8%80%E9%93%B6%E8%A1%8C%E8%B4%A6%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%8F%96%E6%AC%BE.html","excerpt":"","text":"Java线程安全问题-模拟对同一银行账户进行取款代码:package ThreadSafe; /** * 银行账户 * 不适用线程同步机制,多线程对同一个账户进行取款,出现线程安全问题 */ public class Account &#123; private String actNo; private double balance; public Account() &#123; &#125; public Account(String actNo, double balance) &#123; this.actNo = actNo; this.balance = balance; &#125; public String getActNo() &#123; return actNo; &#125; public void setActNo(String actNo) &#123; this.actNo = actNo; &#125; public double getBalance() &#123; return balance; &#125; public void setBalance(double balance) &#123; this.balance = balance; &#125; //取款方法 public void withdraw(double money)&#123; //取款之前的余额 double before = this.getBalance(); //取款之后的余额 double after = before-money; //如果加上这段模拟网络延迟,一定会出问题 //try &#123; //Thread.sleep(1000); //&#125; catch (InterruptedException e) &#123; //e.printStackTrace(); //&#125; //更新余额 //思考:t1执行到这里,但还没来得及执行这行代码,t2线程进来执行了withdraw方法,此时会发生问题. this.setBalance(after); &#125; &#125; package ThreadSafe; public class AccountThread extends Thread&#123; //两个线程必须共享同一个账户对象 private Account act; //通过构造方法传递过来账户对象 public AccountThread(Account act)&#123; this.act = act; &#125; @Override public void run() &#123; //run方法的执行表示取款操作,假设存款有5000块 double money = 5000; //取款,多线程并发执行这个方法 act.withdraw(money); System.out.println(Thread.currentThread().getName()+\"对\"+act.getActNo()+\"取款成功,余额\"+act.getBalance()); &#125; &#125; package ThreadSafe; public class Test &#123; public static void main(String[] args) &#123; //创建账户对象(只创建一个) Account act = new Account(\"act-001\",10000); //创建两个线程 Thread t1 = new AccountThread(act); Thread t2 = new AccountThread(act); //设置name t1.setName(\"t1\"); t2.setName(\"t2\"); //自动线程取款 t1.start(); t2.start(); &#125; &#125; 执行结果: 加上模拟延迟代码后执行结果: 解决线程安全问题:只需要修改Account类: package ThreadSafe2; /** * 银行账户 * 不适用线程同步机制,多线程对同一个账户进行取款,出现线程安全问题 */ public class Account &#123; private String actNo; private double balance; public Account() &#123; &#125; public Account(String actNo, double balance) &#123; this.actNo = actNo; this.balance = balance; &#125; public String getActNo() &#123; return actNo; &#125; public void setActNo(String actNo) &#123; this.actNo = actNo; &#125; public double getBalance() &#123; return balance; &#125; public void setBalance(double balance) &#123; this.balance = balance; &#125; //取款方法 public void withdraw(double money)&#123; //以下这几行代码必须是线程排队的,不能并发 //一个线程把这里的代码全部执行结束之后,另一个线程才能进来 synchronized (this)&#123; double before = this.getBalance(); double after = before-money; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.setBalance(after); &#125; &#125; &#125; 运行结果是: 线程同步机制的语法是:synchronized()&#123; //线程同步代码块 &#125; /* synchronized后面小括号中传入的数据十分重要 这个数据必须是多线程共享的数据.才能达到多线程排队 ()中写什么 那要看你想让那些线程同步 假设t1,t2,t3,t4,t5 有5个线程 你只希望t1,t2,t3排队,t4,t5不需要排队, 你一定要在()中写一个t1,t2,t3共享的对象,而这个 对象对于t4,t5来说不是共享的 */","categories":[{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://codeanime.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java多线程-死锁","slug":"Java多线程-死锁","date":"2021-10-06T14:01:16.000Z","updated":"2021-10-06T14:10:13.652Z","comments":true,"path":"Java多线程-死锁.html","link":"","permalink":"https://codeanime.cc/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E6%AD%BB%E9%94%81.html","excerpt":"","text":"Java多线程-死锁死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 代码:package DealLock; public class DealLock &#123; public static void main(String[] args) &#123; Object o1 = new Object(); Object o2 = new Object(); //t1和t2两个线程 Thread t1 = new MyThread1(o1, o2); Thread t2 = new MyThread2(o1, o2); t1.start(); t2.start(); &#125; &#125; class MyThread1 extends Thread&#123; Object o1; Object o2; public MyThread1(Object o1,Object o2)&#123; this.o1 = o1; this.o2 = o2; &#125; @Override public void run() &#123; synchronized (o1)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (o2)&#123; &#125; &#125; &#125; &#125; class MyThread2 extends Thread&#123; Object o1; Object o2; public MyThread2(Object o1,Object o2)&#123; this.o1 = o1; this.o2 = o2; &#125; @Override public void run() &#123; synchronized (o2)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (o1)&#123; &#125; &#125; &#125; &#125; 运行结果: 发生死锁现象,程序无法结束,也没有任何错误提示.","categories":[{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://codeanime.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"死锁","slug":"死锁","permalink":"https://codeanime.cc/tags/%E6%AD%BB%E9%94%81/"}]},{"title":"bat批量修改文件夹,文件名字","slug":"bat批量修改文件夹-文件名字","date":"2021-10-06T14:00:19.000Z","updated":"2021-10-06T14:12:34.833Z","comments":true,"path":"bat批量修改文件夹-文件名字.html","link":"","permalink":"https://codeanime.cc/bat%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%A4%B9-%E6%96%87%E4%BB%B6%E5%90%8D%E5%AD%97.html","excerpt":"","text":"bat批量修改文件夹,文件名字批量修改文件名字新建一个.txt文件,把以下代码复制进去,然后修改文件名后缀为.bat 代码: @echo off set a&#x3D;00 setlocal EnableDelayedExpansion for %%n in (*.txt) do ( set &#x2F;A a+&#x3D;1 ren &quot;%%n&quot; &quot;小说!a!.txt&quot; ) 双击运行即可批量修改文件名 如果发生乱码,修改解码方式为ANSI 另一种修改文件名代码,实现同样的效果: @echo off&amp;setlocal EnableDelayedExpansion set a&#x3D;1 for &#x2F;f &quot;delims&#x3D;&quot; %%i in (&#39;dir &#x2F;b *.jpg&#39;) do ( if not &quot;%%~ni&quot;&#x3D;&#x3D;&quot;%~n0&quot; ( if !a! LSS 10 (ren &quot;%%i&quot; &quot;img!a!.jpg&quot;) else ren &quot;%%i&quot; &quot;list!a!.jpg&quot; set&#x2F;a a+&#x3D;1 ) ) 批量修改文件夹名字同理:新建一个.txt文件,把以下代码复制进去,然后修改文件名后缀为.bat 代码: set a&#x3D;1000 setlocal EnableDelayedExpansion FOR &#x2F;f &quot;tokens&#x3D;*&quot; %%i IN (&#39;dir &#x2F;a:d &#x2F;b&#39;) DO ( set &#x2F;A a+&#x3D;1 ren &quot;%%i&quot; &quot;电影!a!&quot; ) 双击运行: 如果发生乱码,修改解码方式为ANSI","categories":[{"name":"bat","slug":"bat","permalink":"https://codeanime.cc/categories/bat/"}],"tags":[{"name":"bat","slug":"bat","permalink":"https://codeanime.cc/tags/bat/"},{"name":"批量修改文件夹,文件名字","slug":"批量修改文件夹-文件名字","permalink":"https://codeanime.cc/tags/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%A4%B9-%E6%96%87%E4%BB%B6%E5%90%8D%E5%AD%97/"}]},{"title":"Microsoft Store无法下载更新任何应用程序","slug":"Microsoft-Store无法下载更新任何应用程序","date":"2021-10-06T13:59:44.000Z","updated":"2021-10-06T14:14:43.005Z","comments":true,"path":"Microsoft-Store无法下载更新任何应用程序.html","link":"","permalink":"https://codeanime.cc/Microsoft-Store%E6%97%A0%E6%B3%95%E4%B8%8B%E8%BD%BD%E6%9B%B4%E6%96%B0%E4%BB%BB%E4%BD%95%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F.html","excerpt":"","text":"Microsoft Store无法下载更新任何应用程序 错误代码是0x80D02017 解决:1.重置应用商店Windows+R–输入WSReset.exe 2.运行Windows应用商店应用的疑难解答进行修复“设置”—“更新和安全”—“疑难解答”—选择“Windows 应用商店应用”—点击“运行疑难解答”，按照提示操作 3.以管理员身份运行命令提示符，运行命令来重新注册Windows商店应用:在小娜或搜索框中搜索CMD， 右键”命令提示符“，选择”以管理员身份运行“分别输入以下2条命令，每条后面按下“Enter”键PowerShell -ExecutionPolicy Unrestricted$manifest = (Get-AppxPackage Microsoft.WindowsStore).InstallLocation + &#39;\\AppxManifest.xml&#39; ; Add-AppxPackage -DisableDevelopmentMode -Register $manifest（注意标点符号之间的空格） 4、临时禁用或卸载第三方防护软件测试安装一个应用，如果问题得以解决，建议使用自带的Windows Defender。 5.修复损坏的Windows文件在小娜或搜索框中搜索“CMD“， 右键”命令提示符“，选择”以管理员身份运行“输入命令：Dism /online /cleanup-image /restorehealth Sfc /scannow检查这些命令的输出. 如果发现问题但是没有解决, 建议使用还原点还原到一个可以正常运行的Windows 配置。","categories":[{"name":"踩坑","slug":"踩坑","permalink":"https://codeanime.cc/categories/%E8%B8%A9%E5%9D%91/"}],"tags":[{"name":"Microsoft Store","slug":"Microsoft-Store","permalink":"https://codeanime.cc/tags/Microsoft-Store/"}]},{"title":"Qt ：libpng warning iCCP known incorrect sRGB profile警告信息之解决方法","slug":"Qt-：libpng-warning-iCCP-known-incorrect-sRGB-profile警告信息之解决方法","date":"2021-10-06T13:59:25.000Z","updated":"2021-10-06T14:16:09.935Z","comments":true,"path":"Qt-：libpng-warning-iCCP-known-incorrect-sRGB-profile警告信息之解决方法.html","link":"","permalink":"https://codeanime.cc/Qt-%EF%BC%9Alibpng-warning-iCCP-known-incorrect-sRGB-profile%E8%AD%A6%E5%91%8A%E4%BF%A1%E6%81%AF%E4%B9%8B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.html","excerpt":"","text":"Qt ：libpng warning: iCCP: known incorrect sRGB profile警告信息之解决方法1、从ImageMagick的官网下载压缩包，地址： http://www.imagemagick.org/script/binary-releases.php 根据平台下载相对应的压缩包，如Windows下载 ImageMagick-7.0.4-0-portable-Q16-x64.zip 2、把下载完的压缩包解压到 D:/ImageMagick/ImageMagick 3、在Qt的资源文件夹下（Qt调用资源的目录）新建 ImageMagick-Fix-PNG.bat 文件 打开后编辑内容： @echo off echo ImageMagick fix libpng warning: iCCP: Not recognizing known sRGB profile ...... echo Search PNG in subdirs and process ... set fn&#x3D;D:\\ImageMagick\\ImageMagick\\convert.exe for &#x2F;f &quot;tokens&#x3D;*&quot; %%i in (&#39;dir&#x2F;s&#x2F;b *.png&#39;) do &quot;%fn%&quot; &quot;%%i&quot; -strip &quot;%%i&quot; pause 4、保存退出，单击打开bat批处理，警告就消除了！","categories":[{"name":"踩坑","slug":"踩坑","permalink":"https://codeanime.cc/categories/%E8%B8%A9%E5%9D%91/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://codeanime.cc/tags/%E8%B8%A9%E5%9D%91/"},{"name":"python","slug":"python","permalink":"https://codeanime.cc/tags/python/"}]},{"title":"Git踩坑----fatal unable to access 'httpgithub.comjpdjpdimg.git' OpenSSL SSL_read Connection was reset, errno 1005","slug":"Git踩坑-fatal-unable-to-access-httpgithub-comjpdjpdimg-git-OpenSSL-SSL-read-Connection-was-reset-errno-1005","date":"2021-10-06T13:59:03.000Z","updated":"2021-10-06T14:17:22.960Z","comments":true,"path":"Git踩坑-fatal-unable-to-access-httpgithub-comjpdjpdimg-git-OpenSSL-SSL-read-Connection-was-reset-errno-1005.html","link":"","permalink":"https://codeanime.cc/Git%E8%B8%A9%E5%9D%91-fatal-unable-to-access-httpgithub-comjpdjpdimg-git-OpenSSL-SSL-read-Connection-was-reset-errno-1005.html","excerpt":"","text":"Git踩坑—-fatal: unable to access ‘http://github.com/jpdjpd/img.git/&#39;: OpenSSL SSL_read: Connection was reset, errno 10054今天把github一个仓库删了,然后重新上传,执行命令git push -u origin master出现报错fatal: unable to access &#39;http://github.com/jpdjpd/img.git/&#39;: OpenSSL SSL_read: Connection was reset, errno 10054 找了一些教程,说是把 .git/cofig中的url里https改成http就OK,但试了之后没有成功,可能由于我本地有两个不同的github账号的原因吧 还有一种说法就是:解除ssl验证后，再上传就OK了git config --global http.sslVerify &quot;false&quot;,但是也没有成功. 我这里的正解:修改.git/config中的url为你github上仓库的ssh连接即可 把: 原来配置的git remote add origin https://github.com/jpdjpd/img.git [remote \"origin\"] url = https://github.com/jpdjpd/img.git fetch = +refs/heads/*:refs/remotes/origin/* 改为: [remote \"origin\"] url = git@github.com:jpdjpd/img.git fetch = +refs/heads/*:refs/remotes/origin/* 再进行git push -u origin master即可","categories":[{"name":"git","slug":"git","permalink":"https://codeanime.cc/categories/git/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://codeanime.cc/tags/%E8%B8%A9%E5%9D%91/"},{"name":"git","slug":"git","permalink":"https://codeanime.cc/tags/git/"}]},{"title":"Hbuilder快捷键","slug":"Hbuilder快捷键","date":"2021-10-06T13:58:15.000Z","updated":"2021-10-06T14:18:40.690Z","comments":true,"path":"Hbuilder快捷键.html","link":"","permalink":"https://codeanime.cc/Hbuilder%E5%BF%AB%E6%8D%B7%E9%94%AE.html","excerpt":"","text":"Hbuilder 快捷键最近在学习javaweb 在学前端的时候用到了一款国产编辑器 很棒 Hbuilder 快捷键 Ctrl + d 删除整行内容 Ctrl + Shift +R 复制当前行到下一行 Ctrl + Shift +D 重新编辑 Ctrl + 方向键 当前行整行内容上移或下移 Alt + ↓ 跳转到下一个可编辑区 Ctrl + Alt + j 与下一行合并 Ctrl + Alt + ← 选择助手 Shift + 回车 生成换行符 Ctrl + 回车 向下插入空行 Ctrl + Shift + 回车 向上插入空行 Ctrl + Shift +F 格式化代码 Shift + 空格 全角/半角输入 Alt + [ 匹配括号 tab 选中代码整体向右缩进 tab+shift 选中代码整体向左缩进 ctrl+shift+空格 从当前行向上另起一行 ctrl+空格 从当前行向下另起一行","categories":[{"name":"Hbuilder","slug":"Hbuilder","permalink":"https://codeanime.cc/categories/Hbuilder/"}],"tags":[{"name":"Hbuilder","slug":"Hbuilder","permalink":"https://codeanime.cc/tags/Hbuilder/"},{"name":"快捷键","slug":"快捷键","permalink":"https://codeanime.cc/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"}]},{"title":"HTML----CSS复习","slug":"HTML-CSS复习","date":"2021-10-06T13:57:56.000Z","updated":"2021-10-10T01:41:29.572Z","comments":true,"path":"HTML-CSS复习.html","link":"","permalink":"https://codeanime.cc/HTML-CSS%E5%A4%8D%E4%B9%A0.html","excerpt":"","text":"HTML—-CSS复习1.标题HTML 标题（Heading）是通过 - 等标签进行定义的。 &lt;h1>这是一个标题&lt;/h1> &lt;h2>这是一个标题&lt;/h2> &lt;h3>这是一个标题&lt;/h3> 2.段落&lt;p>这是一个段落。&lt;/p> &lt;p>这是另外一个段落。&lt;/p> 3.链接&lt;a href=\"https://codeanime.cc/\">这个是我的博客链接&lt;/a> 注释：在 href 属性中指定链接的地址。 4.图像HTML 图像是通过 &lt;img&gt; 标签进行定义的。 &lt;img src=\"https://cdn.jsdelivr.net/gh/jpdjpd/img/animation/74.jpg\" width=\"50%\" height=\"50%\" /> 注意： 图像的名称和尺寸是以属性的形式提供的 5.元素HTML 元素 HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码 &lt;p>这是一个段落&lt;/p> &lt;a href=\"https://codeanime.cc/\">这是一个链接&lt;/a> &lt;br> 开始标签 元素内容 结束标签 这是一个段落 这是一个链接 换行 开始标签常被称为起始标签（opening tag），结束标签常称为闭合标签（closing tag） 6.属性 HTML 标签可以拥有属性 属性可以在元素中添加附加信息 属性一般描述于开始标签 属性总是以名称/值对的形式出现，比如：*name=”value”*。 属性总是在 HTML 元素的开始标签中规定 实例: HTML 链接由 标签定义。链接的地址在 href 属性中指定： &lt;a href=\"https://codeanime.cc/\">这是一个链接&lt;/a> 属性值应该始终被包括在引号内。 双引号是最常用的，不过使用单引号也没有问题 注意: 属性值本身就含有双引号，那么必须使用单引号 属性和属性值对大小写不敏感。 不过，万维网联盟在其 HTML 4 推荐标准中推荐小写的属性/属性值。 7.水平线 标签在 HTML 页面中创建水平线。 hr 元素可用于分隔内容。 8.注释注释：开始括号之后（左边的括号）需要紧跟一个叹号，结束括号之前（右边的括号） &lt;!----&gt; &lt;!-- 这是注释 --> 9.样式style 属性用于改变 HTML 元素的样式 &lt;body> &lt;h1>这是一级标签,测试style属性&lt;/h1> &lt;p style=\"font-family: verdana;color: red;font-size: 50px;\">这是p标签,测试style属性,颜色为红色,字体大小为50px&lt;/p> &lt;/body> 10.文本格式化 bia 定义粗体文本 定义大号字 定义着重文字 定义斜体字 定义小号字 定义加重语气 定义下标字 定义上标字 定义插入字 定义删除字 定义计算机代码 定义键盘码 定义计算机代码样本 定义变量 定义预格式文本 定义缩写 定义地址 定义文字方向 定义长的引用 定义短的引用语 定义引用、引证 定义一个定义项目 11.头部&lt;head&gt; 元素包含了所有的头部标签元素。在 &lt;head&gt;元素中你可以插入脚本（scripts）, 样式文件（CSS），及各种meta信息。 可以添加在头部区域的元素标签为: &lt;title&gt;, &lt;style&gt;, &lt;meta&gt;, &lt;link&gt;, &lt;script&gt;, &lt;noscript&gt; 和 &lt;base&gt; 12.标题&lt;title&gt; 标签定义了不同文档的标题。 &lt;title&gt; 在 HTML/XHTML 文档中是必须的。 &lt;title&gt; 元素: 定义了浏览器工具栏的标题 当网页添加到收藏夹时，显示在收藏夹中的标题 显示在搜索引擎结果页面的标题 13.CSSCSS (Cascading Style Sheets) 用于渲染HTML元素标签的样式 CSS 可以通过以下方式添加到HTML中: 内联样式- 在HTML元素中使用”style” 属性 内部样式表 -在HTML文档头部 区域使用 元素 来包含CSS 外部引用 - 使用外部 CSS 文件 最好的方式是通过外部引用CSS文件. 内联样式: 当特殊的样式需要应用到个别元素时，就可以使用内联样式。 使用内联样式的方法是在相关的标签中使用样式属性。样式属性可以包含任何 CSS 属性。以下实例显示出如何改变段落的颜色和左外边距 &lt;p style=\"color:blue;margin-left:20px;\">这是一个段落。&lt;/p> 背景颜色: 背景色属性（background-color）定义一个元素的背景颜色： &lt;body style=\"background-color:yellow;\"> &lt;h2 style=\"background-color:red;\">这是一个2级标题&lt;/h2> &lt;p style=\"background-color:green;\">这是一个段落。&lt;/p> &lt;/body> 字体,字体颜色,字体大小 可以使用font-family（字体），color（颜色），和font-size（字体大小）属性来定义字体的样式: &lt;h1 style=\"font-family:verdana;\">这是一个一级标题&lt;/h1> &lt;p style=\"font-family:arial;color:red;font-size:20px;\">这是一个段落。&lt;/p> 现在通常使用font-family（字体），color（颜色），和font-size（字体大小）属性来定义文本样式，而不是使用标签 文本对齐方式: 使用 text-align（文字对齐）属性指定文本的水平与垂直对齐方式： &lt;h1 style=\"text-align:center;\">居中对齐的1级标题&lt;/h1> &lt;p>这是一个段落。&lt;/p> 内部样式表: 当单个文件需要特别样式时，就可以使用内部样式表。你可以在 部分通过 标签定义内部样式表: &lt;head> &lt;style type=\"text/css\"> body &#123;background-color:yellow;&#125; p &#123;color:blue;&#125; &lt;/style> &lt;/head> 外部样式表: 当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点的外观 &lt;head> &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\"> &lt;/head> 14.表格表格由 标签来定义。每个表格均有若干行（由 标签定义），每行被分割为若干单元格（由 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等 &lt;table border=\"1\"> &lt;tr> &lt;td>1,1&lt;/td> &lt;td>1,2&lt;/td> &lt;/tr> &lt;tr> &lt;td>2,1&lt;/td> &lt;td>2,2&lt;/td> &lt;/tr> &lt;/table> 表格边框属性(border): 如果不定义边框属性，表格将不显示边框 表头: 表格的表头使用 标签进行定义 大多数浏览器会把表头显示为粗体居中的文本： &lt;table border=\"1\"> &lt;tr> &lt;th>11111111111&lt;/th> &lt;th>22222222222&lt;/th> &lt;/tr> &lt;tr> &lt;td>1,1&lt;/td> &lt;td>1,2&lt;/td> &lt;/tr> &lt;tr> &lt;td>2,1&lt;/td> &lt;td>2,2&lt;/td> &lt;/tr> &lt;/table> 15.列表:HTML 支持有序、无序和定义列表: 无序列表: 无序列表是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记 无序列表使用 标签: &lt;ul> &lt;li>水果&lt;/li> &lt;li>蔬菜&lt;/li> &lt;/ul> 有序列表: 同样，有序列表也是一列项目，列表项目使用数字进行标记。 有序列表始于 标签。每个列表项始于 标签 &lt;ol> &lt;li>水果&lt;/li> &lt;li>蔬菜&lt;/li> &lt;/ol> 16.区块元素:HTML 可以通过 和 将元素组合起来 大多数 HTML 元素被定义为块级元素或内联元素。 块级元素在浏览器显示时，通常会以新行来开始（和结束）。 实例: , , , 内联元素: 在显示时通常不会以新行开始。 实例: , , , div元素: HTML 元素是块级元素，它可用于组合其他 HTML 元素的容器。 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。 如果与 CSS 一同使用， 元素可用于对大的内容块设置样式属性。 元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。使用 元素进行文档布局不是表格的正确用法。 元素的作用是显示表格化的数据 span元素: HTML 元素是内联元素，可用作文本的容器 元素也没有特定的含义。 当与 CSS 一同使用时， 元素可用于为部分文本设置样式属性 17.框架通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面。 &lt;iframe src=\"https://codeanime.cc/\" width=\"500px\" height=\"500px\">&lt;/iframe> 移除边框: frameborder 属性用于定义iframe表示是否显示边框。 设置属性值为 “0” 移除iframe的边框: &lt;iframe frameborder=\"0\" src=\"https://codeanime.cc/\" width=\"500px\" height=\"500px\">&lt;/iframe> 使用ifranme作为链接的目标 &lt;iframe name=\"if\" frameborder=\"0\" src=\"https://cdn.jsdelivr.net/gh/jpdjpd/img/animation/32.jpg\" width=\"500px\" height=\"500px\">&lt;/iframe> &lt;p>&lt;a href=\"https://codeanime.cc\" target=\"if\" rel=\"noopener\">樱花庄&lt;/a>&lt;/p> 18.表单表单是一个包含表单元素的区域。 表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。 表单使用表单标签 来设置: &lt;form> . input 元素 . &lt;/form> 输入元素: 多数情况下被用到的表单标签是输入标签&lt;input&gt; 输入类型是由类型属性（type）定义的。大多数经常被用到的输入类型如下： 文本域: 文本域通过 标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。 &lt;form> First name: &lt;input type=\"text\" name=\"firstname\">&lt;br> Last name: &lt;input type=\"text\" name=\"lastname\"> &lt;/form> **注意:**表单本身并不可见。同时，在大多数浏览器中，文本域的默认宽度是 20 个字符。 密码字段: 密码字段通过标签 来定义: &lt;form> First name: &lt;input type=\"text\" name=\"firstname\">&lt;br> Last name: &lt;input type=\"text\" name=\"lastname\">&lt;br> password:&lt;input type=\"password\" name=\"passwoed\"/>&lt;br> &lt;/form> **注意:**密码字段字符不会明文显示，而是以星号或圆点替代。 单选按钮: 标签定义了表单单选框选项 &lt;form> First name: &lt;input type=\"text\" name=\"firstname\">&lt;br> Last name: &lt;input type=\"text\" name=\"lastname\">&lt;br> password:&lt;input type=\"password\" name=\"passwoed\"/>&lt;br> 男&lt;input type=\"radio\" name=\"sex\" value=\"male\" checked=\"男\"/> 女&lt;input type=\"radio\" name=\"sex\" value=\"female\"/>&lt;br> &lt;/form> checked:表示默认选择男 复选框: 定义了复选框. 用户需要从若干给定的选择中选取一个或若干选项。 &lt;form> First name: &lt;input type=\"text\" name=\"firstname\">&lt;br> Last name: &lt;input type=\"text\" name=\"lastname\">&lt;br> password:&lt;input type=\"password\" name=\"passwoed\"/>&lt;br> 男&lt;input type=\"radio\" name=\"sex\" checked=\"男\"/> 女&lt;input type=\"radio\" name=\"sex\"/>&lt;br> 篮球&lt;input type=\"checkbox\" name=\"select\" value=\"basketball\"/> 看番&lt;input type=\"checkbox\" name=\"select\" value=\"game\"/> 逛街&lt;input type=\"checkbox\" name=\"select\" value=\"guangjie\"/> &lt;/form> 提交按钮: 定义了提交按钮. &lt;form name=\"input\" action=\"form_action.php\" method=\"get\"> First name: &lt;input type=\"text\" name=\"firstname\">&lt;br> Last name: &lt;input type=\"text\" name=\"lastname\">&lt;br> password:&lt;input type=\"password\" name=\"passwoed\"/>&lt;br> 男&lt;input type=\"radio\" name=\"sex\" checked=\"男\"/> 女&lt;input type=\"radio\" name=\"sex\"/>&lt;br> 篮球&lt;input type=\"checkbox\" name=\"select\" value=\"basketball\"/> 看番&lt;input type=\"checkbox\" name=\"select\" value=\"game\"/> 逛街&lt;input type=\"checkbox\" name=\"select\" value=\"guangjie\"/> &lt;input type=\"submit\" value=\"submit\"/>&lt;br> &lt;/form> 表单练习(俺好菜): 原版: 盗版: &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>表单练习&lt;/title> &lt;style type=\"text/css\"> #card-primary&#123; position: absolute; top: 50px; left: 50%; width: 300px; height: 423px; background-color: #fff; border-radius: 10px; &#125; .form-group&#123; margin-bottom: 25px; &#125; #card-heard&#123; width: 330; height: 70px; &#125; a&#123; font-size: 1px; &#125; input&#123; position: absolute; left: 20px; border-radius: 2px; &#125; label&#123; &#125; button&#123; position: relative; width: 280px; height: 40px; left: 10px; border-radius: 2px; background-color: #6777ef; &#125; &lt;/style> &lt;/head> &lt;body style=\"background-color: #f4f6f9;\"> &lt;div id=\"card-primary\"> &lt;div id=\"card-heard\"> &lt;h4> &lt;font style=\"vertical-align: inherit;\" size=\"4px\" color=\"#6777ef\">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;登录&lt;/font> &lt;/h4> &lt;/div> &lt;form name=\"input\" action=\"javascript:void(0)\" method=\"get\"> &lt;div id=\"card-body\"> &lt;div \" class=\"form-group\"> &lt;label for=\"email\"> &lt;font style=\"vertical-align: inherit;\" size=\"2px\" color=\"#34395E\">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;邮箱&lt;/font> &lt;/label> &lt;br> &lt;input class=\"form-control\" type=\"email\" name=\"email\" id=\"input\"/>&lt;br> &lt;/div>&lt;br> &lt;div class=\"form-group\"> &lt;label for=\"password\"> &lt;font style=\"vertical-align: inherit;\" size=\"2px\" color=\"#34395E\">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;密码&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/font> &lt;/label> &lt;a href=\"\" >忘记密码&lt;/a>&lt;br> &lt;input class=\"form-control\" type=\"password\" name=\"password\" id=\"input\"/> &lt;/div>&lt;br> &lt;div class=\"form-group\"> &lt;input type=\"checkbox\" name=\"remeber\"/> &lt;label> &lt;font size=\"2.5px\">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;记得我&lt;/font> &lt;/label> &lt;/div>&lt;br> &lt;div class=\"form-group\"> &lt;button style=\"border-radius: 5px;\" tabindex=\"4\" type=\"button\"> &lt;label> &lt;font color=\"#fff\">登录&lt;/font> &lt;/label> &lt;/button> &lt;/div> &lt;/div> &lt;br> &lt;/form> &lt;/div> &lt;/body> &lt;/html> 19.网站布局练习&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>网页布局&lt;/title> &lt;style type=\"text/css\"> *&#123; margin: 0px; padding: 0px; &#125; #primary&#123; width: 1000px; height: 500px; background-color: #6777EF; &#125; #head&#123; width: 100%; background-color: aquamarine; &#125; #left&#123; float: left; width: 100px; height: 400px; background-color: bisque; &#125; #right&#123; float: left; background-color: blueviolet; width: 900px; height: 400px; &#125; #bottom&#123; position: absolute; width: 62.5rem; height: 36.8px; top: 463.2px; background-color: cadetblue; &#125; &lt;/style> &lt;/head> &lt;body> &lt;div id=\"primary\"> &lt;div id=\"head\"> &lt;font size=\"50px\" color=\"#fff\">网站标题&lt;/font> &lt;/div> &lt;div id=\"left\"> &lt;b>菜单&lt;/b> &lt;ul> &lt;li> 第一条 &lt;/li> &lt;li> 第二条 &lt;/li> &lt;li> 第三条 &lt;/li> &lt;/ul> &lt;/div> &lt;div id=\"right\"> 网站内容 &lt;/div> &lt;div id=\"bottom\"> 版权--copyright--codeanime.cc &lt;/div> &lt;/div> &lt;/body> &lt;/html>","categories":[{"name":"HTML","slug":"HTML","permalink":"https://codeanime.cc/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://codeanime.cc/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://codeanime.cc/tags/CSS/"}]},{"title":"Java io流---拷贝文件夹下的所有文件和目录","slug":"Java-io流-拷贝文件夹下的所有文件和目录","date":"2021-09-28T08:43:19.000Z","updated":"2021-09-28T08:46:19.173Z","comments":true,"path":"Java-io流-拷贝文件夹下的所有文件和目录.html","link":"","permalink":"https://codeanime.cc/Java-io%E6%B5%81-%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95.html","excerpt":"","text":"Java io流—拷贝文件夹下的所有文件和目录代码:package demo01; import java.io.*; import java.util.TreeMap; public class CopyAll &#123; public static void main(String[] args) &#123; //拷贝源 File srcFile = new File(\"E:\\\\学习\\\\a\"); //拷贝目标 File destFile = new File(\"C:\\\\Users\\\\22721\\\\Desktop\"); //调用copyDri方法 copyDri(srcFile,destFile); &#125; /** * 拷贝目录 * @param srcFile 拷贝源 * @param destFile 拷贝目标 */ private static void copyDri(File srcFile, File destFile) &#123; if (srcFile.isFile())&#123; //src.File //是文件就拷贝,且边读边写 FileInputStream in = null; FileOutputStream out = null; File file; try &#123; //读srcFile这个文件 in = new FileInputStream(srcFile); String path = destFile.getAbsolutePath() + srcFile.getAbsolutePath().substring(2); out = new FileOutputStream(path); //一边读一边写 //一次性复制1m byte[] bytes = new byte[1024*1024]; int readCount = 0; while ((readCount= in.read(bytes))!=-1)&#123; out.write(bytes,0, readCount); &#125; out.flush(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if (out!=null)&#123; try &#123; out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (in!=null)&#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //srcFile如果是一个文件,结束递归 return; &#125; //获取源下面的子目录(拿到当前文件夹srcFile下的子文件) File[] files = srcFile.listFiles(); //代码测试(写一点测试一点) //System.out.println(files.length); for (File file:files) &#123; //获取所有文件的绝对路径(包括目录和文件) //System.out.println(file.getAbsolutePath()); //这个file可能是文件或者目录 // if (file.isDirectory())&#123; //System.out.println(file.getAbsolutePath()); String srcDri = file.getAbsolutePath(); //获取原目标路径,去掉前两位(E:\\\\学习\\\\a)---->(\\\\学习\\a) //System.out.println(srcDri.substring(2)); String destDri = destFile.getAbsolutePath() + srcDri.substring(2); File newFile = new File(destDri); //如果newFile不存在,则新建 if (!newFile.exists())&#123; newFile.mkdirs(); &#125; //测试输出文件路径 //System.out.println(destDri); &#125; copyDri(file,destFile); &#125; &#125; &#125; 运行结果: 运行后文件被拷贝到桌面(目标文件夹):","categories":[{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/tags/Java/"},{"name":"练习","slug":"练习","permalink":"https://codeanime.cc/tags/%E7%BB%83%E4%B9%A0/"},{"name":"IO流","slug":"IO流","permalink":"https://codeanime.cc/tags/IO%E6%B5%81/"}]},{"title":"Java io流---拷贝目录","slug":"Java-io流-拷贝目录","date":"2021-09-28T08:42:50.000Z","updated":"2021-09-28T08:45:12.666Z","comments":true,"path":"Java-io流-拷贝目录.html","link":"","permalink":"https://codeanime.cc/Java-io%E6%B5%81-%E6%8B%B7%E8%B4%9D%E7%9B%AE%E5%BD%95.html","excerpt":"","text":"Java io流—拷贝目录代码:package demo01; import java.io.File; public class CopyAll &#123; public static void main(String[] args) &#123; //拷贝源 File srcFile = new File(\"E:\\\\学习\\\\a\"); //拷贝目标 File destFile = new File(\"C:\\\\Users\\\\22721\\\\Desktop\"); //调用copyDri方法 copyDri(srcFile,destFile); &#125; /** * 拷贝目录 * @param srcFile 拷贝源 * @param destFile 拷贝目标 */ private static void copyDri(File srcFile, File destFile) &#123; if (srcFile.isFile())&#123; //src.File //srcFile如果是一个文件,结束递归 return; &#125; //获取源下面的子目录(拿到当前文件夹srcFile下的子文件) File[] files = srcFile.listFiles(); //代码测试(写一点测试一点) //System.out.println(files.length); for (File file:files) &#123; //获取所有文件的绝对路径(包括目录和文件) //System.out.println(file.getAbsolutePath()); //这个file可能是文件或者目录 // if (file.isDirectory())&#123; //System.out.println(file.getAbsolutePath()); String srcDri = file.getAbsolutePath(); //获取原目标路径,去掉前两位(E:\\\\学习\\\\a)---->(\\\\学习\\a) //System.out.println(srcDri.substring(2)); String destDri = destFile.getAbsolutePath() + srcDri.substring(2); File newFile = new File(destDri); //如果newFile不存在,则新建 if (!newFile.exists())&#123; newFile.mkdirs(); &#125; //测试输出文件路径 //System.out.println(destDri); &#125; copyDri(file,destFile); &#125; &#125; &#125; 运行结果: 拷贝目标,即桌面上出现了:","categories":[{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/tags/Java/"},{"name":"练习","slug":"练习","permalink":"https://codeanime.cc/tags/%E7%BB%83%E4%B9%A0/"},{"name":"IO流","slug":"IO流","permalink":"https://codeanime.cc/tags/IO%E6%B5%81/"}]},{"title":"Git使用手册--超级详细,自己都看哭了","slug":"Git使用手册-超级详细-自己都看哭了","date":"2021-09-24T11:12:37.000Z","updated":"2021-10-04T00:10:02.939Z","comments":true,"path":"Git使用手册-超级详细-自己都看哭了.html","link":"","permalink":"https://codeanime.cc/Git%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C-%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86-%E8%87%AA%E5%B7%B1%E9%83%BD%E7%9C%8B%E5%93%AD%E4%BA%86.html","excerpt":"","text":"Git一.git简介Git是目前世界上最先进的分布式版本控制系统（没有之一）。 关于版本控制系统: 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统.有了它你就可以将选定的文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等 二.安装在使用Git前我们需要先安装 Git。Git 目前支持 Linux/Unix、Solaris、Mac和 Windows 平台上运行。 Git 各平台安装包下载地址为：http://git-scm.com/downloads Linux 平台上安装 Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。 在有 yum 的系统上（比如 Fedora）或者有 apt-get 的系统上（比如 Debian 体系），可以用下面的命令安装： 各 Linux 系统可以使用其安装包管理工具（apt-get、yum 等）进行安装： Debian/Ubuntu Debian/Ubuntu Git 安装命令为： $ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\ libz-dev libssl-dev $ apt-get install git $ git --version git version 1.8.1.2 Centos/RedHat 如果你使用的系统是 Centos/RedHat 安装命令为： $ yum install curl-devel expat-devel gettext-devel \\ openssl-devel zlib-devel $ yum -y install git-core $ git --version git version 1.7.1 源码安装 我们也可以在官网下载源码包来安装，最新源码包下载地址：https://git-scm.com/download 安装指定系统的依赖包： # Centos/RedHat $ yum install curl-devel expat-devel gettext-devel \\ openssl-devel zlib-devel # Debian/Ubuntu $ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\ libz-dev libssl-dev 解压安装下载的源码包： $ tar -zxf git-1.7.2.2.tar.gz $ cd git-1.7.2.2 $ make prefix=/usr/local all $ sudo make prefix=/usr/local install Windows 平台上安装 在 Windows 平台上安装 Git 同样轻松，有个叫做 msysGit 的项目提供了安装包，可以到 GitHub 的页面上下载 exe 安装文件并运行： 安装包下载地址：https://gitforwindows.org/ 官网慢，可以用国内的镜像：https://npm.taobao.org/mirrors/git-for-windows/。 三.创建版本库我们先来理解下 Git 工作区、暂存区和版本库概念： 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录 **.git，这个不算工作区，而是 Git 的版本库。版本库又名仓库，英文名repository**，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 1.创建一个目录作或者选择一个有内容的目录为工作区2.使用当前目录作为Git仓库，我们只需使它初始化git init Git 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。 在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变。 补充: 使用指定目录作为Git仓库 git init newtest 初始化后，会在 newtest 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。 3.把文件添加到版本库这里我在工作区里添加一个文本文件作为演示: 一个文件放到Git仓库只要三步( 把大象当冰箱 ): (1)把文件放到工作区或者新建文件,保证文件是在工作区目录下或子目录下 (2)用git add 命令把文件添加到暂存区 : git add read.txt (3)用git commit命令用把文件提交到仓库 git commit -m \"第一次提交\" # -m后面输入的是本次提交的说明(message) 提交后发现和git add一样没有任何反应,在linux中没有反应是最好的反应 四.版本回退git log命令:查看历史提交记录 假如说我修改read.txt文件,添加一行文字测试修改 使用git log命令查看提交记录 如果提交次数很多,可以使用git log --pretty=oneline查看提交记录 说明: 提交记录里面那一大串字符``(20b123….)是 commit id`（版本号） 版本回退: 使用命令git reset回退版本: 说明: 在Git中，用HEAD表示当前版本，也就是最新的提交20b123....，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100 git reset --hard HEAD^ 打开之前添加的文字修改,发现回退到第一次提交的版本 用命令git log查看版本历史,我们如果想再回到最新版本(添加文字修改过的那个版本)怎么办: git reset --hard 20b123 id没必要写全,前几位就可以了，Git会自动去找 问题来了,假如说,我关机了,或者关掉git了,ID不知道怎么办.在git中,总有后悔药可以吃: 使用命令git reflog查看命令历史 知道了id不是想怎么玩就怎么玩! 五.查看仓库当前的状态命令git status查看仓库当前的状态，显示有变更的文件 我在工作区中再添加一个文件 使用命令: git status me.txt文件没有被添加,所以它的状态是Untracked。 那现在来添加一下,再查看: 提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的(working tree clean) 六.添加远程仓库–Github首先你需要你个Github账户,再者你要创建一个仓库,注册账户就不说了,闭上眼注册就行了,我们来说一下创建仓库吧 接着确定就行了…. 创建好的效果如图: 接着,我们从这里找到github仓库的地址 执行命令: git remote add origin https://github.com/code-anime/test.git 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的 下一步，就可以把本地库的所有内容推送到远程库上： git push -u origin master 执行完毕后我们可以看到github上远程仓库内容和本地的内容一样. 注意： 执行途中可能遇到的问题: (1)SSH错误 由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息： 使用以下命令生成 SSH Key： $ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 后面的 &#121;&#111;&#x75;&#x72;&#95;&#101;&#109;&#x61;&#105;&#x6c;&#x40;&#x79;&#111;&#x75;&#x72;&#101;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d; 改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。 成功的话会在 ~/ 下生成 .ssh 文件夹，进去，打开 id_rsa.pub，复制里面的 key。 $ ssh-keygen -t rsa -C \"2272166487@qq.com\" Generating public/private rsa key pair. Enter file in which to save the key (/Users/tianqixin/.ssh/id_rsa): Enter passphrase (empty for no passphrase): # 直接回车 Enter same passphrase again: # 直接回车 Your identification has been saved in /Users/tianqixin/.ssh/id_rsa. Your public key has been saved in /Users/tianqixin/.ssh/id_rsa.pub. The key fingerprint is: SHA256:MDKVidPTDXIQoJwoqUmI4LBAsg5XByBlrOEzkxrwARI 429240967@qq.com The key's randomart image is: +---[RSA 3072]----+ |E*+.+=**oo | |%Oo+oo=o. . | |%**.o.o. | |OO. o o | |+o+ S | |. | | | | | | | +----[SHA256]-----+ 回到 github 上，进入 Account =&gt; Settings（账户配置）。 左边选择 SSH and GPG keys，然后点击 New SSH key 按钮,title 设置标题，可以随便填，粘贴在你电脑上生成的 key。 添加成功后界面如下所示 为了验证是否成功，输入以下命令： $ ssh -T git@github.com The authenticity of host 'github.com (52.74.223.119)' can't be established. RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes # 输入 yes Warning: Permanently added 'github.com,52.74.223.119' (RSA) to the list of known hosts. Hi tianqixin! You've successfully authenticated, but GitHub does not provide shell access. # 成功信息 以下命令说明我们已成功连上 Github。 (2)下面这个错误 warning: redirecting to https://github.com/code-anime/test.git/ To http://github.com/code-anime/test.git ! [rejected] master -> master (non-fast-forward) error: failed to push some refs to 'http://github.com/code-anime/test.git' hint: Updates were rejected because the tip of your current branch is behind hint: its remote counterpart. Integrate the remote changes (e.g. hint: 'git pull ...') before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. 解决: 执行命令: git pull --rebase origin master 接着再试一下: git push -u origin master 七.移除远程仓库如果添加的时候地址写错了，或者就是想删除远程库,可以用git remote rm &lt;name&gt; 建议执行该命令之前执行git remote -v查看远程库信息 然后根据名字删除,比如删除origin 此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。 查看.git目录下的config文件,发现原来的这条没有了: [remote \"origin\"] url = https://github.com/code-anime/test.git fetch = +refs/heads/*:refs/remotes/origin/* 如果想重新建立与远程库之间的连接: git remote add origin git remote add origin https://github.com/code-anime/test.git git add . git commit -m \"第三次提交\" git push -u origin master 八.从远程库克隆上面所讲到的是先有本地库,后有远程库,如何关联远程库. 现在,我们来说先有远程库,再有本地库(从远程库克隆),这里我把本地test工作区删除,github上面的test仓库也删除了.从零开始演示.毕竟是test 接着就是创建github仓库,这里不做赘述了. 我在桌面新建了一个文件夹repos,没别的意思就是repository的简写 然后打开文件夹 , 然后git bash here 执行命令: git clone git@github.com:code-anime/test.git 上面git clone后跟的是仓库地址. 执行命令后,会发现repos目录里面多了一个test文件夹(就是克隆github上的test仓库) 打开test文件夹后我们会发现,和远程仓库内容是一样的 注意: GitHub给出的地址不止一个，还可以用https://github.com/code-anime/test.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。 使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https 九.分支管理首先,列出分支: git branch 意思就是，我们有一个叫做 master 的分支，并且该分支是当前分支.当你执行 git init 的时候，默认情况下 Git 就会为你创建 master 分支。 如果我们要手动创建一个分支。执行 git branch (branchname) 即可。 创建一个testing分支: git branch testing 现在我们可以看到，有了一个新分支 testing。 当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 testing 分支，Git 将还原你的工作目录到你创建分支时候的样子。 我们切换到testing分支进行实验: git checkout testing 接下来我们将演示如何切换分支，我们用git checkout (branch) 切换到我们要修改的分支。 我们在testing分支上正常提交，比如创建文件readme.txt,内容写上: 测试testing分支 然后提交: git add . git commit -m \"添加文字测试testing分支\" 现在我们切换会master分支后,再查看readme.txt文件,文件不见了! ! 当我们满怀怀疑的时候我们切换回来testing分支,发现还在 因为那个提交是在testing分支上，而master分支此刻的提交点并没有变： 现在，我们把testing分支的工作成果合并到master分支上： git checkout master git merge testing 合并完成后，就可以放心地删除testing分支了： git branch -d testing 十.合并冲突合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。 git branch * master cat readme.txt 测试testing分支 现在我们只有一条主分支master且readme.txt文件中只有测试testing分支这一段文字. 首先,我们创建一个test1分支, 切换过去，我们将readme.txt文件添加123三个数字 将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的内容,没有123 我们再次修改 readme.txt文件,添加数字456 现在这些改变已经记录到我的 master分支了。接下来我们将 test1分支合并过来。 git merge test1 Auto-merging readme.txt CONFLICT (content): Merge conflict in readme.txt Automatic merge failed; fix conflicts and then commit the result. 打开文件,看见冲突内容 我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存： 123456 再提交: git add . git commit -m \"分支冲突解决\" 用带参数的git log也可以看到分支的合并情况： git log --graph --pretty=oneline --abbrev-commit 最后,删除分支: git branch -d test1 十一.标签管理如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。 比如说，我们想为我们的 test项目发布一个1.0版本。 我们可以用 git tag V1.0 命令给最新一次提交打上（HEAD）v1.0的标签。 首先，切换到需要打标签的分支上： git tag v1.0 当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。 可以用命令git tag查看所有标签： git tag v1.0 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，本该在昨天打的tag没打怎么办? 方法是找到历史提交的commit id，然后打上就可以了： git log --pretty=oneline --abbrev-commit 比方说要对添加456三个数组这次提交打标签，它对应的commit id是fe6c8d7，敲入命令： git tag v0.9 fe6c8d7 再用命令git tag查看标签： $ git tag v0.9 v1.0 注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show &lt;tagname&gt;查看标签信息： git show v0.9 可以看到，v0.9确实打在add 添加456三个数字这次提交上。 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： $ git tag -a v0.6 -m \"version 0.6 released\" 1094adb 用命令git show &lt;tagname&gt;可以看到说明文字： git show v0.6 用命令git tag -d &lt;tagname&gt;删除标签 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。 git tag -d v0.6 如果要推送某个标签到远程，使用命令git push origin &lt;tagname&gt;： git push origin v1.0 或者，一次性推送全部尚未推送到远程的本地标签： $ git push origin --tags 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除： $ git tag -d v1.0 然后，从远程删除。删除命令也是push，但是格式如下： $ git push origin :refs/tags/v1.0 要看看是否真的从远程库删除了标签，可以登陆GitHub查看。 十二.Gitee使用(hexo博客部署到gitee)如果你-ssh密钥删除了或者不见了,新建一个ssh密钥 需要重新上传到github 打开你本地生成的ssh密钥(默认路径是C:\\user\\你的电脑用户名\\ .ssh\\id_rua_pub) 放到github上: 第一次要密码,输入你创建ssh密钥时候的密码即可. 使用Gitee和使用GitHub类似，我们在Gitee上注册账号并登录后，需要先上传自己的SSH公钥。选择右上角用户头像 -&gt; 菜单“修改资料”，然后选择“SSH公钥”，填写一个便于识别的标题，然后把用户主目录下的.ssh/id_rsa.pub文件的内容粘贴进去 这里我来演示一下在gitee上搭建Hexo博客吧,顺便复习一下: 准备: 安装git,nodejs,npm (1)首先,创建一个工作目录作为我们的博客目录 右键git bash here hexo init 初始化hexo (2)下载主题安装,这里以butterfly主题为例在你的 Hexo 根目目录 git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly 修改 Hexo 根目录下的 _config.yml，把主題为butterfly theme: butterfly (3)安装插件npm install hexo-renderer-pug hexo-renderer-stylus --save 在 hexo 的根目录创建一个文件 _config.butterfly.yml，并把主题目录的 _config.yml 内容复制到_config.butterfly.yml去。 注意： 不要把主題目录的 _config.yml 刪掉 以后只需要在 _config.butterfly.yml進行配置就行。 Hexo会自动合并主题中的_config.yml和 config.butterfly.yml里的配置，如果存在同名配置，會使用config.butterfly.yml的配置，其优先度较高 然后执行: hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 在浏览器打开http://localhost:4000: 能打开说明是好的 (4)部署到gitee 安装组件: npm install hexo-deployer-git --save 然后: hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 最后出现下面那个图为正解. (5)开启网页服务 直接点击生成即可，就会显示已开启 Gitee Pages 服务，网站地址： xxxxxx 至此，一个用户名.gitee.io的博客网站部署完成","categories":[{"name":"Git","slug":"Git","permalink":"https://codeanime.cc/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://codeanime.cc/tags/Git/"},{"name":"Github","slug":"Github","permalink":"https://codeanime.cc/tags/Github/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://codeanime.cc/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"Gitee","slug":"Gitee","permalink":"https://codeanime.cc/tags/Gitee/"}]},{"title":"JDBC小记","slug":"JDBC小记","date":"2021-09-21T02:43:07.000Z","updated":"2021-10-10T01:41:51.264Z","comments":true,"path":"JDBC小记.html","link":"","permalink":"https://codeanime.cc/JDBC%E5%B0%8F%E8%AE%B0.html","excerpt":"","text":"JDBC小记前言昨天刚冲完了jdbc,今天来总结一下 一.JDBC介绍JDBC (百度百科): Java数据库连接，（Java Database Connectivity，简称JDBC）是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。JDBC也是Sun Microsystems的商标。我们通常说的JDBC是面向关系型数据库的。 说白了 JDBC就是Java数据库连接，就是用Java语言来操作数据库。原来我们操作数据库是在控制台使用SQL语句来操作数据库，JDBC是用Java语言向数据库发送SQL语句. 二.JDBC原理图 三.JDBC的本质:JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。 JDBC到底是什么 SUN公司制定的一套接口(interface)，(在java.sql.*;包下有很多接口) 目的：解耦合——&gt;降低程序的耦合度，提高程序的扩展力 **附:**java链接MySQL驱动包最新版下载地址:https://dev.mysql.com/downloads/connector/j/,解压后得到jar库文件,然后在项目中导入该库文件. 博主使用的版本是mysql-connector-java-5.1.47.jar 四.什么是驱动驱动，是指驱动计算机里软件的程序。驱动程序全称设备驱动程序，是添加到操作系统中的特殊程序，其中包含有关硬件设备的信息。此信息能够使计算机与相应的设备进行通信。驱动程序是硬件厂商根据操作系统编写的配置文件，可以说没有驱动程序，计算机中的硬件就无法工作。 例如：网卡，声卡，显卡等等 必须要安装驱动程序，不然这些硬件就无法正常工作。 五.为什么要面向接口编程？解耦合:降低程序的耦合度，提高程序的扩展力多态机制就是非常典型的：面向抽象编程(不要面向具体编程) Animal a = new Cat(); Animal a = new Dog(); //喂养的方法 public void feed(Animal a )&#123; //面向父类型编程 &#125; 不建议： Dog d = new Dog(); Cat c = new Cat(); 思考：为什么sun公司要制定一套JDBC接口呢？因为每个数据库的实现原理不一样，oracle、mysql、ms sqlserver都有自己的原理,每个数据库产品都有自己独特的实现原理. 六.JDBC核心类（接口）介绍JDBC中的核心类有：DriverManager、Connection、Statement，和ResultSet DriverManger（驱动管理器）的作用有两个： 注册驱动：这可以让JDBC知道要使用的是哪个驱动； DriverManager.registerDriver(new com.mysql.jdbc.Driver()); 获取Connection：如果可以获取到Connection，那么说明已经与数据库连接上了。 DriverManager.getConnection(url,username,password) Connection对象表示连接，与数据库的通讯都是通过这个对象展开的： Connection最为重要的一个方法就是用来获取Statement对象； Statement stmt = con.createStatement(); Statement是用来向数据库发送SQL语句的，这样数据库就会执行发送过来的SQL语句 void executeUpdate(String sql)：执行更新操作（insert、update、delete等）； ResultSet executeQuery(String sql)：执行查询操作，数据库在执行查询后会把查询结果，查询结果就是ResultSet； ResultSet对象表示查询结果集，只有在执行查询操作后才会有结果集的产生。结果集是一个二维的表格，有行有列。操作结果集要学习移动ResultSet内部的“行光标”，以及获取当前行上的每一列上的数据： boolean next()：使“行光标”移动到下一行，并返回移动后的行是否存在； rs.next();//光标移动到第一行 rs.getInt(1);//获取第一行第一列的数据 XXX getXXX(int col)：获取当前行指定列上的值，参数就是列数，列数从1开始，而不是0。 //常用的方法 Object getObject(int col) String getString(int col) int getInt(int col) double getDouble(int col) 七.JDBC编程6步（超级重要,需要背会!!!!）第1步：注册驱动 (只做一次) 第2步：获取数据库连接对象(Connection) 第3步：获取数据库操作对象(Statement) 第4步：执行sql语句(增删改查) 第5步：处理查询结果集(ResultSet) 第6步：释放资源 第1步：注册驱动 (只做一次)作用：告诉java程序，即将要连接的是哪个牌子的数据库. 注册驱动的两种方法 (例如,注册MySQL的数据库驱动) : // 第一种: 推荐 Class.forName(“com.mysql.jdbc.Driver”); Class.forName是把这个类加载到JVM中，加载的时候，就会执行其中的静态初始化块，完成驱动的初始化的相关工作。 // 第二种: 不推荐 DriverManager.registerDriver(new com.mysql.jdbc.Driver()); // DriverManager类的registerDriver()方法的参数是java.sql.Driver，但java.sql.Driver是一个接口，实现类由mysql驱动来提供，mysql驱动中的java.sql.Driver接口的实现类为com.mysql.jdbc.Driver 上面代码虽然可以注册驱动，但是出现硬编码（代码依赖mysql驱动jar包），如果将来想连接Oracle数据库，那么必须要修改代码的。并且其实这种注册驱动的方式是注册了两次驱动！ 通过初始化驱动类com.mysql.jdbc.Driver，该类就在 mysql-connector-java-5.0.8-bin.jar中。如果你使用的是oracle数据库那么该驱动类将不同。 注意：Class.forName需要捕获ClassNotFoundException. try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; 第2步：获取数据库连接对象(Connection)表示jvm的进程和数据库进程之间的通道打开了，这属于进程之间的通信，重量级的，使用完一定要关闭 可以使用 DriverManager.getConnection()方法建立连接。根据传入参数的不同，有三种重载的DriverManager.getConnection()方法： getConnection(String url) getConnection(String url, Properties prop) getConnection(String url, String user, String password) 还可以在url中提供参数： jdbc:mysql://localhost:3306/mydb?useUnicode=true&amp;characterEncoding=UTF8 useUnicode参数指定这个连接数据库的过程中，使用的字节集是Unicode字节集； characherEncoding参数指定穿上连接数据库的过程中，使用的字节集编码为UTF-8编码。请注意，mysql中指定UTF-8编码是给出的是UTF8，而不是UTF-8。 这里每个格式都需要一个数据库URL。 数据库URL是指向数据库的地址。制定数据库URL是建立连接相关联的大多数错误问题发生的地方。各数据库对应的URL如下所示： 假设我们现在需要连接MySQL数据库，格式为：jdbc:mysql://hostname：port/datebaseName。我们需要的信息是hostname主机名和端口号，一般默认为localHost：3306；还需要datebaseName数据库名，假设为mydb；当然还有URL格式未包含的也是必须的信息：连接数据库的用户名和密码，假设为root和123456。那么就有URL： ```1 String url = “jdbc:mysql//localhost:3306/mydb”; 下面分别使用四种方法来实现： - 使用一个URL作为参数的方式：需要将username+password以参数的形式放到URL中，但是每种数据库的放置都不太相同 &#96;&#96;&#96;java &#x2F;&#x2F;连接mysql的纯URL String url &#x3D; &quot;jdbc:mysql&#x2F;&#x2F;localhost:3306&#x2F;mydb?username&#x3D;root&amp;password&#x3D;123456&quot;; Connection conn &#x3D; DriverManager.getConnection(url,p); &#x2F;&#x2F;连接Oracle的纯URL String url &#x3D; &quot;jdbc:oracle:thin:root&#x2F;123456@192.0.0.10:1521:mydb&quot;;Connection conn &#x3D; DriverManager.getConnection(url); 使用URL、properties作为参数的方式：即需要将username和password以键值对形式存放在properties对象中作为参数 //MySql String url = \"jdbc:mysql//localhost:3306/mydb\"; Properties p = new Properties(); p.put(\"username\",\"root\"); p.put(\"password\",\"123456\"); Connection conn = DriverManager.getConnection(url,p); 使用URL、username、password三个参数分开的方式（推荐） String url = \"jdbc:mysql//localhost:3306/mydb\"; String username = \"root\"; String password = \"123456\"; Connection conn = DriverManager.getConnection(url,username,password); 利用java.sql.Drivermanager类中的getConnection()方法与数据库建立连接。 Connection c = DriverManager.getConnection(\"jdbc:mysql://127.0.0.1:3306/mydb?characterEncoding=UTF-8\", \"root\", \"123456\"); // 说明: // DriverManager.getConnection(“jdbc:mysql://数据库地址:端口号/数据库名”,”用户名”, “密码”); // 数据库服务端的IP地址:127.0.0.1 (这是本机，如果连接其他电脑上的数据库，需填写相应的IP地址) // 数据库的端口号： 3306 （mysql专用端口号） // 数据库名称 mydb（根据你自己数据库中的名称填写） // 编码方式 UTF-8 // 账号 root // 密码 123456（如果你在创建数据库的时候没有使用默认的账号和密码，请填写自己设置的账号和密码） 注意: Connection是与特定数据库连接回话的接口，使用的时候需要导包，而且必须在程序结束的时候将其关闭。getConnection方法也需要捕获SQLException异常。 因为在进行数据库的增删改查的时候都需要与数据库建立连接，所以可以在项目中将建立连接写成一个工具方法，用的时候直接调用即可： /** * 取得数据库的连接 * @return 一个数据库的连接 */ public static Connection getConnection()&#123; Connection conn = null; try &#123; //初始化驱动类com.mysql.jdbc.Driver Class.forName(\"com.mysql.jdbc.Driver\"); conn = DriverManager.getConnection(\"jdbc:mysql://127.0.0.1:3306/mydb?characterEncoding=UTF-8\",\"root\", \"123456\"); //该类就在 mysql-connector-java-5.0.8-bin.jar中,如果忘记了第一个步骤的导包，就会抛出ClassNotFoundException &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;catch (SQLException e) &#123; e.printStackTrace(); &#125; return conn; &#125; 第3步：获取数据库操作对象(Statement或者PreparedStatement)SQL语句的执行对象按理说有Statement和PreparedStatement两个，但我们一般都不会去使用Statement，先看下两者的基本描述： Statement 是 Java 执行数据库操作的一个重要接口，用于在已经建立数据库连接的基础上，向数据库发送要执行的SQL语句。Statement对象，用于执行不带参数的简单SQL语句，即静态SQL语句。 PreparedStatement 继承于Statement。实例包含已编译的 SQL 语句，这就是使语句“准备好”。包含于 PreparedStatement 对象中的 SQL 语句可具有一个或多个 IN 参数。IN参数的值在 SQL 语句创建时未被指定。相反的，该语句为每个 IN 参数保留一个问号（“？”）作为占位符。每个问号的值必须在该语句执行之前，通过适当的setXXX（） 方法来提供。 简言之，Statement执行静态SQL语句，而它的子类PreparedStatement执行预编译SQL，即可传入参数。两者相比之下，PreparedStatement有以下优势： 预编译处理，可动态执行SQL语句。很明显，SQL语句的预编译，使用占位符？去代替未知数据，因而一个句子可以执行多种不同的SQL，而Statement需要重新书写SQL语句，笨重。 速度快，执行效率高。SQL语句会预编译在数据库系统中。执行计划同样会被缓存起来，它允许数据库做参数化查询。使用预处理语句比普通的查询更快，因为它做的工作更少（数据库对SQL语句的分析，编译，优化已经在第一次查询前完成了）。我们要利用预编译的特性 (1). 利用java.sql.Connection创建用于执行SQL语句的Statement。Statement stmt = connection.createStatement(); 注意:使用Statement会引起sql注入问题,在实际开发中很少使用,用的的更多的是它的子类PreparedStatement 比如sql注入问题如下: String sql = \"SELECT * FROM users WHERE name = '\" + userName + \"' and pw = '\"+ passWord +\"';\" 验证需要用户输入用户名和密码，正确则执行查询语句（登录），但如果这样输入： userName &#x3D; &quot;1&#39; OR &#39;1&#39;&#x3D;&#39;1&quot;; passWord &#x3D; &quot;1&#39; OR &#39;1&#39;&#x3D;&#39;1&quot;; 那么执行语句就变成了： 1 String sql = \"SELECT * FROM users WHERE name = '1' OR '1'='1' and pw = '1' OR '1'='1';\" 这样，where语句恒为真，就能实现无账号登录。此外便可能被恶意修改甚至删除数据表。然而使用PreparedStatement的参数化的查询可以阻止大部分的SQL注入。在使用参数化查询的情况下，数据库系统（eg:MySQL）不会将参数的内容视为SQL指令的一部分来处理，而是在数据库完成SQL指令的编译后，才套用参数运行，且占位符?不允许多值，只能填入一个值，因此就算参数中含有破坏性的指令，也不会被数据库所运行。 (2) .使用Connection对象的PreparedStatement（sql）方法进行获取：String sql = \"select * from user where name=? and ange=?\";//预处理，需要我们先写好sql语句 PreparedStatement ps = conn.preparedStatement(sql);//conn是连接对象，参数为sql语句 第4步：执行sql语句(增删改查)SQL语言共分为四大类：数据查询语言DQL，数据操纵语言DML，数据定义语言DDL，数据控制语言DCL sql语句有增删查改等几种类型，所以执行方法有以下三种： execute()：执行SQL语句，可以是任何种类的 SQL 语句。返回值是boolean类型。 executeQuery()：执行SQL语句查询，查询结果返回为**ResultSet 对象**。 executeUpdate() ：执行更新语句。该语句必须是一个 SQL 数据操作语言（Data Manipulation Language，DML）语句，比如 INSERT、UPDATE 或 DELETE 语句；或者是无返回内容的 SQL 语句，比如 DDL 语句。返回值是int。 例如本例中的语句是查询语句，所以执行代码为： ```java//执行查询语句，并把结果集返回给集合ResultSetResultSet rs = ps.executeQuery(); ### **第5步：处理查询结果集(ResultSet)** 如果返回值是boolean或者int很好处理，但如果是查询结果集ResultSet对象，一般使用while循环来处理： &#96; ResultSet&#96; 对象具有指向其当前数据行的光标。最初，光标被置于第一行之前。&#96;next()&#96; 方法将光标移动到下一行；因为该方法在 &#96;ResultSet&#96; 对象没有下一行时返回 &#96;false&#96;，所以可以在 &#96;while&#96; 循环中使用它来**迭代**结果集。另外，可以使用ResultSet对象的getXXX（int columnIndex）获得游标所在行指定列的值。原理如下图所示： ![下载 (1)](https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;09&#x2F;21&#x2F;vhreUMbBG5En1KH.png) 所以，本例的结果集处理如下： &#96;&#96;&#96;java 1 while(rs.next())&#123; 2 system.out.println(rs.getString(1)); 3 system.out.println(rs.getInt(2)); 4 &#125; 第6步：释放资源在JDBC程序结束之后，显式地需要关闭与数据库的所有连接以结束每个数据库会话。 但是，如果在编写程序中忘记了关闭也没有关系，Java的垃圾收集器将在清除过时的对象时也会关闭这些连接。 依靠垃圾收集，特别是数据库编程，是一个非常差的编程实践。所以应该要使用与连接对象关联的close()方法关闭连接。要确保连接已关闭，可以将关闭连接的代码中编写在“finally”块中。 一个finally块总是会被执行，不管是否发生异常。 conn.close(); 八.JDBCUtils工具类因为传统JDBC的开发，注册驱动，获得连接，释放资源这些代码都是重复编写的。所以可以将重复的代码提取到一个类中来完成 import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; /** * JDBC的工具类 * @author CodeAnime * */ public class JDBCUtils &#123; private static final String driverClassName; private static final String url; private static final String username; private static final String password; static&#123; driverClassName=\"com.mysql.jdbc.Driver\"; url=\"jdbc:mysql:///web_test3\"; username=\"root\"; password=\"123456\"; &#125; /** * 注册驱动的方法 */ public static void loadDriver()&#123; try &#123; Class.forName(driverClassName); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; /** * 获得连接的方法 */ public static Connection getConnection()&#123; Connection conn = null; try&#123; // 将驱动一并注册: loadDriver(); // 获得连接 conn = DriverManager.getConnection(url,username, password); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return conn; &#125; /** * 释放资源的方法 */ public static void release(Statement stmt,Connection conn)&#123; if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; stmt = null; &#125; if(conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; conn = null; &#125; &#125; public static void release(ResultSet rs,Statement stmt,Connection conn)&#123; // 资源释放： if(rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; rs = null; &#125; if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; stmt = null; &#125; if(conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; conn = null; &#125; &#125; &#125; 测试案例：导入工具类，查询用户信息 import java.sql.Connection; import java.sql.ResultSet; import java.sql.Statement; import org.junit.Test; import com.xdr630.jdbc.utils.JDBCUtils; /** * JDBC工具类的测试 * @author xdr * */ public class JDBCDemo3 &#123; @Test /** * 查询操作：使用工具类 */ public void demo1()&#123; Connection conn = null; Statement stmt = null; ResultSet rs = null; try&#123; // 获得连接: conn = JDBCUtils.getConnection(); // 创建执行SQL语句的对象: stmt = conn.createStatement(); // 编写SQL: String sql = \"select * from user\"; // 执行查询: rs = stmt.executeQuery(sql); // 遍历结果集: while(rs.next())&#123; System.out.println(rs.getInt(\"id\")+\" \"+rs.getString(\"username\")+\" \"+rs.getString(\"password\")); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; // 释放资源: JDBCUtils.release(rs, stmt, conn); &#125; &#125; &#125; 另一种写法: jdbc.properties属性文件 注意：属性配置文件必须以properties结尾，且存储在src源目录下 driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mydb user=root password=123456 JDBCUtils.java工具类 public class JDBCUtil()&#123; //类文件属性，可以在类文件所有的方法中使用 private Connection conn = null; private PreparedStatement ps = null; /** * 在当前类文件第一次被加载到JVM时，JVM将会自动调用当前类文件静态语句块 */ static &#123; //1. 注册数据库服务器提供的Driver接口实现类 try&#123; ResourceBundle bundle = ResourceBundle.getBundle(\"jdbc\"); String driver = bundle.getString(\"driver\"); Class.forName(driver); &#125;catch(ClassNotFoundException e)&#123; e.printStackTrace(); &#125; &#125; /** * 封装Connection对象创建细节 * @return 数据库连接的对象 */ //这里我们选择抛出异常，而不是自行内部处理。是让调用此方法的人知道出现异常时的控制台出现的异常信息 public Connection creatConnection() throws SQLException &#123; //采用资源绑定器来绑定属性配置文件 ResourceBundle bundle = ResourceBundle.getBundle(\"jdbc\"); String url = bundle.getString(\"url\"); String username = bundle.getString(\"username\"); String password = bundle.getString(\"password\"); //2. 创建一个连接通道交给Connection接口的实例对象[Connection]管理 conn = DriverManager.getConnection(url,username,password); return conn; &#125; /** * 封装PreparedStatement对象创建细节 * @param sql sql语句 * @return */ public PreparedStatement createStatement(String sql) throws SQLException &#123; Connection conn = creatConnection(); //3. 创建一个交通工具交给 PreparedStatement 接口的实例对象[PreparedStatement]管理 ps = conn.prepareStatement(sql); //4. 由交通工具在Java工程与数据库服务器之间进行传输，推送SQL命令并带回执行结果 return ps; &#125; /** * 封装PreparedStatement与Connection对象销毁细节 */ public void close()&#123; if (ps != null)&#123; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 封装PreparedStatement与Connection与ResultSet对象销毁细节 * @param rs 查询结果集 */ public void close(ResultSet rs)&#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; close(); &#125; &#125; JDBCTest01.java测试 public class JDBCTest01 &#123; public static void main(String[] args) &#123; //创建JDBC工具类对象 JdbcUtil util = new JdbcUtil(); PreparedStatement ps = null; ResultSet rs = null; try &#123; String sql = \"select * from studnet where studentid = ?\"; //这里由于在工具类中是抛出异常的，那么在调用时再抛出异常给JVM虚拟机就显然不太合理了，此时我们选择try...catch...内部处理 ps = util.createStatement(sql); ps.setString(5,\"田七\"); rs = ps.executeQuery(); while (rs.next())&#123; System.out.println(rs.getInt(\"studentid\") + rs.getString(\"studnetname\")); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; //在finally语句块中的语句必定执行 util.close(rs); &#125; &#125; &#125; 参考文章: 作者 : Jungle_Rao 链接：https://blog.csdn.net/Jungle_Rao/article/details/81274720 作者 : Qiao_Zhi https://www.cnblogs.com/qlqwjy/p/8227665.html 作者 : 叫我玉弟大人 https://www.cnblogs.com/jwyddr/p/11661096.html 作者 : 风大 https://www.cnblogs.com/fzz9/p/8970210.html 作者 : newwaylau https://zhuanlan.zhihu.com/p/114709445","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://codeanime.cc/categories/JDBC/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://codeanime.cc/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://codeanime.cc/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://codeanime.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"JDBC","slug":"JDBC","permalink":"https://codeanime.cc/tags/JDBC/"}]},{"title":"JDBC练习五","slug":"JDBC练习五","date":"2021-09-20T11:24:19.000Z","updated":"2021-09-20T11:40:03.919Z","comments":true,"path":"JDBC练习五.html","link":"","permalink":"https://codeanime.cc/JDBC%E7%BB%83%E4%B9%A0%E4%BA%94.html","excerpt":"","text":"JDBC练习五/* 执行DQL语句 */ import java.sql.*; import java.util.*; public class JDBCTest05 &#123; public static void main(String[] args) &#123; // 1、注册驱动 // 2、建立连接 // 3、获取数据库操作对象 // 4、执行sql语句 // 5、获取查询结果集 // 6、释放资源 Connection conn = null; Statement stmt = null; ResultSet rs = null; try&#123; ResourceBundle rb = ResourceBundle.getBundle(\"jdbc\"); String driver = rb.getString(\"driver\"); String url = rb.getString(\"url\"); String user = rb.getString(\"user\"); String password = rb.getString(\"password\"); Class.forName(driver); conn = DriverManager.getConnection(url,user,password); stmt = conn.createStatement(); rs = stmt.executeQuery(\"select * from student\"); while(rs.next())&#123; /* String studentid = rs.getString(1); String studentname = rs.getString(2); System.out.println(studentid + \",\" + studentname); */ /* // 按下标取出，程序不健壮 String studentid = rs.getString(\"studentid\"); String studentname = rs.getString(\"studentname\"); System.out.println(studentid + \",\" + studentname); */ /* // 以指定的格式取出 int studentid = rs.getInt(1); String studentname = rs.getString(2); System.out.println(studentid + \",\" + studentname); */ int studentid = rs.getInt(\"studentid\"); String studentname = rs.getString(\"studentname\"); System.out.println(studentid + \",\" + studentname); &#125; &#125; catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; if(rs != null)&#123; try&#123; rs.close(); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; if(stmt != null)&#123; try&#123; stmt.close(); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try&#123; conn.close(); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; 运行结果:","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://codeanime.cc/categories/JDBC/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://codeanime.cc/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://codeanime.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"JDBC","slug":"JDBC","permalink":"https://codeanime.cc/tags/JDBC/"},{"name":"练习","slug":"练习","permalink":"https://codeanime.cc/tags/%E7%BB%83%E4%B9%A0/"}]},{"title":"JDBC练习四","slug":"JDBC练习四","date":"2021-09-20T11:24:13.000Z","updated":"2021-09-20T11:36:24.146Z","comments":true,"path":"JDBC练习四.html","link":"","permalink":"https://codeanime.cc/JDBC%E7%BB%83%E4%B9%A0%E5%9B%9B.html","excerpt":"","text":"JDBC练习四import java.sql.*; import java.util.*; /* 使用资源绑定器 */ public class JDBCTest04 &#123; public static void main(String[] args) &#123; ResourceBundle bundle = ResourceBundle.getBundle(\"jdbc\"); String driver = bundle.getString(\"driver\"); String url = bundle.getString(\"url\"); String user = bundle.getString(\"user\"); String password = bundle.getString(\"password\"); Connection conn = null; Statement stmt = null; try &#123; Class.forName(driver); conn = DriverManager.getConnection(url,user,password); stmt = conn.createStatement(); int count = stmt.executeUpdate(\"insert into student values(5,'田七')\"); System.out.println(count == 1? \"保存成功\":\"保存失败\"); &#125; catch(SQLException e)&#123; e.printStackTrace(); &#125; catch(ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if(conn != null) &#123; try &#123; conn.close(); &#125; catch(SQLException e)&#123; e.printStackTrace(); &#125; &#125; if(stmt != null) &#123; try &#123; stmt.close(); &#125; catch(SQLException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; 资源绑定器: 资源绑定器内容为: driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mydb user=root password=123456 运行结果:","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://codeanime.cc/categories/JDBC/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://codeanime.cc/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://codeanime.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"JDBC","slug":"JDBC","permalink":"https://codeanime.cc/tags/JDBC/"},{"name":"练习","slug":"练习","permalink":"https://codeanime.cc/tags/%E7%BB%83%E4%B9%A0/"}]},{"title":"JDBC练习三","slug":"JDBC练习三","date":"2021-09-20T11:24:08.000Z","updated":"2021-09-20T12:13:39.025Z","comments":true,"path":"JDBC练习三.html","link":"","permalink":"https://codeanime.cc/JDBC%E7%BB%83%E4%B9%A0%E4%B8%89.html","excerpt":"","text":"JDBC练习三import java.sql.*; /* 注册驱动的另一种方式 */ public class JDBCTest03 &#123; public static void main(String[] args) &#123; try&#123; // 注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); // 获取连接 Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\",\"root\",\"123456\"); System.out.println(conn); &#125; catch(SQLException e)&#123; e.printStackTrace(); &#125; catch(ClassNotFoundException e)&#123; e.printStackTrace(); &#125; &#125; &#125; 运行结果:","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://codeanime.cc/categories/JDBC/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://codeanime.cc/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://codeanime.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"JDBC","slug":"JDBC","permalink":"https://codeanime.cc/tags/JDBC/"},{"name":"练习","slug":"练习","permalink":"https://codeanime.cc/tags/%E7%BB%83%E4%B9%A0/"}]},{"title":"JDBC练习二","slug":"JDBC练习二","date":"2021-09-20T11:24:00.000Z","updated":"2021-09-20T11:30:37.639Z","comments":true,"path":"JDBC练习二.html","link":"","permalink":"https://codeanime.cc/JDBC%E7%BB%83%E4%B9%A0%E4%BA%8C.html","excerpt":"","text":"JDBC练习二import java.sql.*; /* JDBC完成Delete */ public class JDBCTest02 &#123; public static void main(String[] args) &#123; // 1、注册驱动 // 2、获取连接 // 3、获取数据库操作对象 // 4、执行sql语句 // 5、获取查询结果集 // 6、释放资源 Connection conn = null; Statement stmt = null; try &#123; Driver driver = new com.mysql.jdbc.Driver(); DriverManager.registerDriver(driver); String url = \"jdbc:mysql://127.0.0.1:3306/mydb\"; String user = \"root\"; String password = \"123456\"; conn = DriverManager.getConnection(url,user,password); stmt = conn.createStatement(); int count = stmt.executeUpdate(\"delete from student where studentid = 5\"); System.out.println(count == 1? \"删除成功\":\"删除失败\"); &#125; catch(SQLException e)&#123; e.printStackTrace(); &#125; finally &#123; if(conn != null) &#123; try &#123; conn.close(); &#125; catch(SQLException e)&#123; e.printStackTrace(); &#125; &#125; if(stmt != null) &#123; try &#123; stmt.close(); &#125; catch(SQLException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; 运行结果:","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://codeanime.cc/categories/JDBC/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://codeanime.cc/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://codeanime.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"JDBC","slug":"JDBC","permalink":"https://codeanime.cc/tags/JDBC/"},{"name":"练习","slug":"练习","permalink":"https://codeanime.cc/tags/%E7%BB%83%E4%B9%A0/"}]},{"title":"JDBC练习一","slug":"JDBC练习一","date":"2021-09-20T11:23:50.000Z","updated":"2021-09-20T11:25:57.533Z","comments":true,"path":"JDBC练习一.html","link":"","permalink":"https://codeanime.cc/JDBC%E7%BB%83%E4%B9%A0%E4%B8%80.html","excerpt":"","text":"JDBC练习一import java.sql.*; public class JDBCTest01 &#123; public static void main(String[] args) &#123; Connection conn = null; Statement stmt = null; try&#123; // 1、注册驱动 Driver driver = new com.mysql.jdbc.Driver(); //多态，父类型引用指向子类型对象 DriverManager.registerDriver(driver); // 2、获取连接 /* url包括哪几部分: 协议 IP Port 资源名 eg：http://180.101.49.11:80/index.html http:// 通信协议 180.101.49.11 IP地址 80 端口号 index.html 资源名 */ // static Connection getConnection(String url, String user, String password) String url = \"jdbc:mysql://127.0.0.1:3306/mydb\"; String user = \"root\"; String password = \"123456\"; conn = DriverManager.getConnection(url,user,password); System.out.println(\"数据库连接对象\" + conn); //数据库连接对象com.mysql.jdbc.JDBC4Connection@1ae369b7 // 3、获取数据库操作对象 // Statement createStatement() 创建一个 Statement 对象来将 SQL 语句发送到数据库。 stmt = conn.createStatement(); // 4、执行sql语句 // int executeUpdate(String sql) // 专门执行DML语句 // 返回值是“影响数据库中的记录条数” int count = stmt.executeUpdate(\"insert into student values(5,'田七')\"); System.out.println(count == 1 ? \"保存成功\":\"保存失败\"); // 5、处理查询结果集 &#125; catch(SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 6、释放资源 // 从小到大依次关闭(后进先出) if(stmt != null) &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; 运行结果:","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://codeanime.cc/categories/JDBC/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://codeanime.cc/tags/JDBC/"},{"name":"练习","slug":"练习","permalink":"https://codeanime.cc/tags/%E7%BB%83%E4%B9%A0/"}]},{"title":"In aggregated query without GROUP BY, expression","slug":"In-aggregated-query-without-GROUP-BY-expression-2-of-SELECT-list-contains-nonaggregated-column","date":"2021-09-16T08:22:52.000Z","updated":"2021-09-16T08:23:57.959Z","comments":true,"path":"In-aggregated-query-without-GROUP-BY-expression-2-of-SELECT-list-contains-nonaggregated-column.html","link":"","permalink":"https://codeanime.cc/In-aggregated-query-without-GROUP-BY-expression-2-of-SELECT-list-contains-nonaggregated-column.html","excerpt":"","text":"ERROR 1140 (42000): In aggregated query without GROUP BY, expression #1 of SELECT list contains nonaggregated column ‘mydb.student.sname’; this is incompatible with sql_mode=only_full_group_bymaven项目报错error:expression #2 of SELECT list contains nonaggregated column ‘newhelp.appr.title’; this is incompatible with sql_mode=only_full_group_by 这是因为随着MySQL版本更新带来的问题，在MySQL5.7版本之后对group by进行了优化。他默认启动改进之后的 版本启动了ONLY_FULL_GROUP_BY模式。 这种模式的官方解释：ONLY_FULL_GROUP_BY是MySQL数据库提供的一个sql_mode，通过这个sql_mode来保证 SQL语句“分组求最值”合法性的检查。这种模式采用了与Oracle、DB2等数据库的处理方式。即不允许select target list 中出现语义不明确的列。 通俗的讲就是：对于用到GROUP BY的select语句，查出来的列必须是group by后面声明的列，或者是聚合函数里面的列 有这样一个数据库的表 select语句：select id, sum(appr_id) from appr group by id————————————(合法) select语句：select id, user_id, sum(appr_id) from appr group by id————————-(合法) select语句：select id, sum(appr_id) from appr group by role———————————-(不合法) select语句：select id, user_id, sum(appr_id) from appr group by role———————–(不合法) select语句：select * from appr group by role——————————————————-(不合法) 经过大量测试：笔者发现了ONLY_FULL_GROUP_BY这种模式的特点： 1：只要有聚合函数sum()，count()，max()，avg()等函数就需要用到group by，否则就会报上面的错误。 2：group by id(id是主键)的时候，select什么都没有问题，包括有聚合函数。 3：group by role(非主键)的时候，select只能是聚合函数和role(group by的字段),否则报错 如果我们不想用用ONLY_FULL_GROUP_BY的模式。有两种解决这种问题的方案： 1：命令行中输入： set @@GLOBAL.sql_mode=’’; set sql_mode =’STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION _BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION’; 不过这种情况治标不治本，一旦mysql重启之后又会恢复。 2：修改MySQL的配置文件， 1、windows下找到MySQL的安装目录的my.ini文件，修改其中的配置为不启动ONLY_FULL_GROUP_BY模式 删掉带有ONLY_FULL_GROUP_BY的模式就ok了，如果没有找到my.ini文件。 去系统的隐藏文件夹查看，在某个盘下输入%ProgramData%然后搜索MySQL的my.ini文件 2、linux下找到my.cnf文件，这个是配置MySQL的文件。一般这个文件是在etc文件夹下。 vi my.cnf 编辑这个文件，然后在图示的位置上加入sql_mode = “STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FO R_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER” 然后重启MySQL服务：service mysqld restart 注意：服务重启之后不一定立即生效，尤其是你买的服务器，存在延时。所以可能等一两个小时才生效。 goodluck！————————————————版权声明：本文为CSDN博主「不坠青云之志」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_43279637/article/details/84842189","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://codeanime.cc/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://codeanime.cc/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://codeanime.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库错误 ERROR 1366 (HY000) Incorrect string value xD4xF8xBBxAA for column Sname at row 1解决","slug":"数据库错误-ERROR-1366-HY000-Incorrect-string-value-xD4xF8xBBxAA-for-column-Sname-at-row-1解决","date":"2021-09-16T08:15:07.000Z","updated":"2021-09-16T08:16:43.435Z","comments":true,"path":"数据库错误-ERROR-1366-HY000-Incorrect-string-value-xD4xF8xBBxAA-for-column-Sname-at-row-1解决.html","link":"","permalink":"https://codeanime.cc/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E8%AF%AF-ERROR-1366-HY000-Incorrect-string-value-xD4xF8xBBxAA-for-column-Sname-at-row-1%E8%A7%A3%E5%86%B3.html","excerpt":"","text":"数据库错误 ERROR 1366 (HY000): Incorrect string value: ‘\\xD4\\xF8\\xBB\\xAA’ for column ‘Sname’ at row 1解决一.原因:插入数据时有中文字符出现 二.解决方案1.查看当前服务器状态 : status或者\\s 2.修改数据库的默认编码方式使用命令: alter database mydb character set gbk; 查看修改是否成功:使用命令：\\s或则status；可以看到Db characterset:gbk 设置成功了。 插入数据试一下: 发现依旧报错.报错的原因是，在修改数据库mydb编码方式前，表department就已经建立了。因此，表department它的编码还是数据库之前默认的编码方式latin1，这个可以通过下面的命令来得到确认： show create table department; 因此，还需要修改表格的编码方式。 修改表格的默认编码方式,并插入数据试一下 alter table department character set gbk; 发现还是不行,,,,,,,,, 使用命令:status或\\s 发现表的编码方式已经是gbk了,但是dname的编码仍然是latin1,所以我们应该对dname属性进行编码方式修改,使用命令: alter table department modify dname varchar(20) character set gbk; 发现已经成功了! 另外,我们也可以在创建表的时候指定字符集,这里我就不做演示了,感兴趣的小伙伴可以在下方留言. 还有我们可以修改mysql默认字符集编码方式 找到Mysql数据库安装路径,打开my.ini配置文件 修改默认字符集编码方式为gbk,(没有就加上) 重新登录到mysql数据库就可以了","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://codeanime.cc/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://codeanime.cc/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://codeanime.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"又学MySQL","slug":"又学MySQL","date":"2021-09-13T14:36:03.000Z","updated":"2021-10-10T16:14:06.482Z","comments":true,"path":"又学MySQL.html","link":"","permalink":"https://codeanime.cc/%E5%8F%88%E5%AD%A6MySQL.html","excerpt":"","text":"又学MySQL一、数据库的基本操作1.1、启动net start mysql -- 启动 1.2、断开net stop mysql -- 断开 1.3、连接mysql -uroot -p -- 连接数据库 Enter password:****** 1.4、退出exit -- 退出 1.5、创建数据库create database 数据库名; -- 例如，创建一个叫db1的数据库 show create database db1; 1.6、删除数据库drop datebase 数据库名 -- 例如，删除db1数据库 drop database db1; 1.7、切换数据库use 数据库名 -- 例如，使用db1数据库 use db1; 1.8、查询出MySQL中所有的数据库show databases; 1.9、查看当前使用的数据库select database(); 二、数据表的基本操作2.1、创建数据表create table 表名( 字段1 字段类型, 字段2 字段类型, … 字段n 字段类型 ); -- 例如，创建一个student表 create table student( id int, name varchar(20), gender varchar(10), birthday date ); 2.2、查看数据表show tables; -- 查看当前数据库中所有表 show create table student; -- 查student表的基本信息 desc student; -- 查看student表的字段信息 -- PS：此处desc是describe的缩写，用法： desc 表名/查询语句 2.3、修改数据表alter table student rename to stu; -- 修改student表名为stu alter table stu change name sname varchar(10); -- 修改stu表name字段名为sname alter table stu modify sname int; -- 修改sname字段数据类型为int -- PS：此处modify意为修改、调整的意思。 alter table stu add address varchar(50); -- 增加address字段 alter table stu drop address; -- 删除stu表中address字段 2.4、删除数据表drop table 表名; -- 例如，删除stu数据表 drop table stu; 三、数据表的约束 约束条件 说明 PRIMARY KEY 主键约束用于唯一标识对应的记录 FOREIGN KEY 外键约束 NOT NULL 非空约束 UNIQUE 唯一性约束 DEFAULT 默认值约束，用于设置字段的默认值 以上五种约束条件针对表中字段进行限制从而保证数据表中数据的正确性和唯一性。换句话说，表的约束实际上就是表中数据的限制条件。 3.1、主键约束主键约束即primary key用于唯一的标识表中的每一行。被标识为主键的数据在表中是唯一的且其值不能为空。这点类似于我们每个人都有一个身份证号，并且这个身份证号是唯一的。 -- 主键约束基本语法： 字段名 数据类型 primary key; -- 设置主键约束(primary key)的第一种方式 create table student( id int primary key, name varchar(20) ); -- 设置主键约束(primary key)的第二种方式 create table student01( id int, name varchar(20), primary key(id) ); 3.2、非空约束非空约束即 NOT NULL指的是字段的值不能为空 -- 基本的语法格式 字段名 数据类型 NOT NULL; -- 例如，给name字段加上非空约束 create table student02( id int, name varchar(20) not null ); 3.3、默认值约束默认值约束即DEFAULT用于给数据表中的字段指定默认值，即当在表中插入一条新记录时若未给该字段赋值，那么，数据库系统会自动为这个字段插人默认值 -- 基本的语法格式 字段名 数据类型 DEFAULT 默认值； -- 例如，给字段gender添加默认值约束 create table student03( id int, name varchar(20), gender varchar(10) default 'male' ); 3.4、唯一性约束唯一性约束即UNIQUE用于保证数据表中字段的唯一性，即表中字段的值不能重复出现 -- 基本的语法格式 字段名 数据类型 UNIQUE; -- 例如，给字段name添加唯一性约束 create table student04( id int, name varchar(20) unique ); 3.5、外键约束外键约束即FOREIGN KEY常用于多张表之间的约束 -- 在创建数据表时语法如下： CONSTRAINT 外键名 FOREIGN KEY (从表外键字段) REFERENCES 主表 (主键字段) -- 将创建数据表创号后语法如下： ALTER TABLE 从表名 ADD CONSTRAINT 外键名 FOREIGN KEY (从表外键字段) REFERENCES 主表 (主键字段); -- PS：constraint意为限制 -- 例如： -- 创建一个学生表 create table student05( id int primary key, name varchar(20) ); -- 创建一个班级表 create table class( classid int primary key, studentid int ); -- 学生表作为主表，班级表作为副表设置外键 alter table class add constraint fk_class_studentid foreign key(studentid) references student05(id); 建立外键是为了保证数据的完整和统一性。但是，如果主表中的数据被删除或修改从表中对应的数据，从表中对应的数据也应该被删除，否则数据库中会存在很多无意义的垃圾数据 -- 删除外键 alter table 从表名 drop foreign key 外键名; -- 例如，删除班级表外键 alter table class drop foreign key fk_class_studentid; 关于外键约束需要注意的细节 1、从表里的外键通常为主表的主键2、从表里外键的数据类型必须与主表中主键的数据类型一致3、主表发生变化时应注意主表与从表的数据一致性问题 四、数据表插入数据在MySQL通过INSERT语句向数据表中插入数据 create table student( id int, name varchar(30), age int, gender varchar(30) ); 4.1、为表中所有字段插入数据每个字段与其值是严格一一对应的。也就是说：每个值、值的顺序、值的类型必须与对应的字段相匹配。但是，各字段也无须与其在表中定义的顺序一致，它们只要与 VALUES中值的顺序一致即可 -- 基本的语法格式 INSERT INTO 表名（字段名1,字段名2,...) VALUES (值 1,值 2,...); -- 例如，向学生表中插入一条学生信息 insert into student (id,name,age,gender) values (1,'bob',16,'male'); 4.2、为表中指定字段插入数据插入数据的方法基本和为表中所有字段插入数据，一样，只是需要插入的字段由你自己指定 -- 基本的语法格式 INSERT INTO 表名（字段名1,字段名2,...) VALUES (值 1,值 2,...); -- 例如，向学生表中插入一条学生信息 insert into student (id,name) values (2,'lak'); 4.3、同时插入多条记录在该方式中：(字段名1,字段名2,…)是可选的，它用于指定插人的字段名；(值 1,值 2,…),(值 1,值 2,…)表示要插人的记录，该记录可有多条并且每条记录之间用逗号隔开 -- 基本的语法格式 INSERT INTO 表名 [(字段名1,字段名2,...)]VALUES (值 1,值 2,…),(值 1,值 2,…),...; -- 例如，向学生表中插入多条学生信息 insert into student (id,name,age,gender) values (3,'lucy',17,'female'),(4,'jack',19,'male'),(5,'tom',18,'male'); 五、更新数据在MySQL通过UPDATE语句向数据表中更新数据 create table student( id int, name varchar(30), age int, gender varchar(30) ); -- 基本的语法格式 -- 在该语法中：字段名1、字段名2…用于指定要更新的字段名称；值1、值 2…用于表示字段的新数据；WHERE 条件表达式 是可选的，它用于指定更新数据需要满足的条件 UPDATE 表名 SET 字段名1=值1[,字段名2 =值2,…] [WHERE 条件表达式]; -- 1、UPDATE更新部分数据 -- 将name为tom的记录的age设置为20并将其gender设置为female update student set age=20,gender='female' where name='tom'; -- 2、UPDATE更新全部数据 -- 将所有记录的age设置为18 update student set age=18; 六、删除数据在MySQL通过DELETE语句删除数据表中的数据 TRUNCATE 删除数据 truncate table student; -- 创建学生表 create table student( id int, name varchar(30), age int, gender varchar(30) ); -- 插入数据 insert into student (id,name,age,gender) values (2,'lucy',17,'female'),(3,'jack',19,'male'),(4,'tom',18,'male'),(5,'sal',19,'female'),(6,'sun',20,'male') ,(7,'sad',13,'female'),(8,'sam',14,'male'); -- 基本的语法格式 -- 在该语法中：表名用于指定要执行删除操作的表；[WHERE 条件表达式]为可选参数用于指定删除的条件。 DELETE FROM 表名 [WHERE 条件表达式]; -- 1、DELETE删除部分数据 -- 删除age等于14的所有记录 delete from student where age=14; -- 2、DELETE删除全部数据 -- 删除student表中的所有记录 delete from student; -- 3、TRUNCATE删除数据 truncate table student; TRUNCATE和DETELE的区别TRUNCATE和DETELE都能实现删除表中的所有数据的功能，但两者也是有区别的：1、DELETE语句后可跟WHERE子句，可通过指定WHERE子句中的条件表达式只删除满足条件的部分记录；但是，TRUNCATE语句只能用于删除表中的所有记录。2、使用TRUNCATE语句删除表中的数据后，再次向表中添加记录时自动增加字段的默认初始值重新由1开始；使用DELETE语句删除表中所有记录后，再次向表中添加记录时自动增加字段的值为删除时该字段的最大值加13、DELETE语句是DML语句，TRUNCATE语句通常被认为是DDL语句 七、MySQL数据表查询语句-- 创建数据库 DROP DATABASE IF EXISTS mydb; CREATE DATABASE mydb; USE mydb; -- 创建student表 CREATE TABLE student ( sid CHAR(6), sname VARCHAR(50), age INT, gender VARCHAR(50) DEFAULT 'male' ); -- 向student表插入数据 INSERT INTO student (sid,sname,age,gender) VALUES ('S_1001', 'lili', 14, 'male'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1002', 'wang', 15, 'female'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1003', 'tywd', 16, 'male'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1004', 'hfgs', 17, 'female'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1005', 'qwer', 18, 'male'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1006', 'zxsd', 19, 'female'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1007', 'hjop', 16, 'male'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1008', 'tyop', 15, 'female'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1009', 'nhmk', 13, 'male'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1010', 'xdfv', 17, 'female'); 7.1、简单查询不含where的select语句 -- 1、查询所有字段 select * from student; -- 2、查询指定字段（sid、sname） select sid,sname from student; -- 3、常数的查询日期标记 select sid,sname,'2021-03-02' from student; -- 4、从查询结果中过滤重复数据（DISTINCT） -- 注：在SELECT查询语句中DISTINCT关键字只能用在第一个所查列名之前（distinct必须放在开头）。 select distinct gender from student; -- 5、在SELECT查询语句中使用加减乘除运算符，例如，查询学生10年后的年龄 select sname,age+10 from student; 7.2、条件查询 关系运算符 说明 = 等于 &lt;&gt; 不等于 != 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 -- 1、使用关系运算符查询 -- 查询年龄等于或大于17的学生的信息 select * from student where age>=17; -- 2、使用IN关键字查询 -- IN关键字用于判断某个字段的值是否在指定集合中。如果字段的值恰好在指定的集合中，则将字段所在的记录将査询出来 -- 例如，查询sid为S_1002和S_1003的学生信息 select * from student where sid in ('S_1002','S_1003'); -- 查询sid为S_1001以外的学生的信息 select * from student where sid not in ('S_1001'); -- 3、使用BETWEEN AND关键字查询 -- BETWEEN AND用于判断某个字段的值是否在指定的范围之内。如果字段的值在指定范围内，则将所在的记录将查询出来 -- 例如，查询15到18岁的学生信息 select * from student where age between 15 and 18; -- 查询不是15到18岁的学生信息 select * from student where age not between 15 and 18; -- 4、使用空值查询 -- 在MySQL中，使用 IS NULL关键字判断字段的值是否为空值。请注意：空值NULL不同于0，也不同于空字符串 -- 例如，查询sname不为空值的学生信息 select * from student where sname is not null; -- 5、使用AND关键字查询 -- 在MySQL中可使用AND关键字可以连接两个或者多个查询条件。 -- 例如，查询年纪大于15且性别为male的学生信息 select * from student where age>15 and gender='male'; -- 6、使用OR关键字查询 -- 在使用SELECT语句查询数据时可使用OR关键字连接多个査询条件。在使用OR关键字时，只要记录满足其中任意一个条件就会被查询出来 -- 例如，查询年纪大于15或者性别为male的学生信息 select * from student where age>15 or gender='male'; -- 7、使用LIKE关键字查询进行模糊查询（%、_） -- MySQL中可使用LIKE关键字可以判断两个字符串是否相匹配 -- 例如，查询sname中与wang匹配的学生信息 select * from student where sname like 'wang'; -- 查询学生姓名以li开始的记录，使用%（%用于匹配任意长度的字符串。例如，字符串“a%”匹配以字符a开始任意长度的字符串） select * from student where sname like 'li%'; -- 查询学生姓名以g结尾的记录 select * from student where sname like '%g'; -- 查询学生姓名包含s的记录 select * from student where sname like '%s%'; -- 查询学生姓名以zx开头且长度为4的记录，使用_（下划线通配符只匹配单个字符，如果要匹配多个字符，需要连续使用多个下划线通配符。例如，字符串“ab_”匹配以字符串“ab”开始长度为3的字符串，如abc、abp等等） select * from student where sname like 'zx__'; -- 8、使用LIMIT限制查询结果的数量 -- 当执行查询数据时可能会返回很多条记录，而用户需要的数据可能只是其中的一条或者几条 -- 例如，查询学生表中前三行同学,从第0行开始,查询3行数据 select * from student limit 3; -- limit 3 等价于limit 0,3 -- 查询学生表从索引从6取10行数据的同 select * from student limit 5,10; -- 9、使用GROUP BY进行分组查询 -- GROUP BY 子句可像切蛋糕一样将表中的数据进行分组，再进行查询等操作。换言之，可通俗地理解为：通过GROUP BY将原来的表拆分成了几张小表 -- 创建数据库 DROP DATABASE IF EXISTS mydb; CREATE DATABASE mydb; USE mydb; -- 创建员工表 CREATE TABLE employee ( id int, name varchar(50), salary int, departmentnumber int ); -- 向员工表中插入数据 INSERT INTO employee values(1,'tome',2000,1001); INSERT INTO employee values(2,'lucy',9000,1002); INSERT INTO employee values(3,'joke',5000,1003); INSERT INTO employee values(4,'wang',3000,1004); INSERT INTO employee values(5,'chen',3000,1001); INSERT INTO employee values(6,'yukt',7000,1002); INSERT INTO employee values(7,'rett',6000,1003); INSERT INTO employee values(8,'mujk',4000,1004); INSERT INTO employee values(9,'poik',3000,1001); -- GROUP BY和聚合函数一起使用 -- 例如，统计各部门员工个数 select count(*), departmentnumber from employee group by departmentnumber; -- 例如，统计部门编号大于1001的各部门员工个数 select count(*), departmentnumber from employee where departmentnumber>1001 group by departmentnumber; -- GROUP BY和聚合函数以及HAVING一起使用 -- 例如，统计工资总和大于8000的部门 select sum(salary),departmentnumber from employee group by departmentnumber having sum(salary)>8000; -- 10、使用ORDER BY对查询结果排序 -- 从表中査询出来的数据可能是无序的或者其排列顺序不是我们期望的。为此，我们可以使用ORDER BY对查询结果进行排序 -- 基本的语法格式，在该语法中：字段名1、字段名2是查询结果排序的依据；参数 ASC表示按照升序排序，DESC表示按照降序排序；默认情况下，按照ASC方式排序。通常情况下，ORDER BY子句位于整个SELECT语句的末尾 SELECT 字段名1,字段名2,… FROM 表名 ORDER BY 字段名1 [ASC 丨 DESC],字段名2 [ASC | DESC]; -- 例如，查询所有学生并按照年纪大小升序排列 select * from employee order by salary asc; -- 例如，查询所有学生并按照年纪大小降序排列 select * from employee order by salary desc; 7.3、多表连接查询 -- 1、交叉连接查询 -- 交叉连接返回的结果是被连接的两个表中所有数据行的笛卡儿积；比如：集合A=&#123;a,b&#125;，集合B=&#123;0,1,2&#125;，则集合A和B的笛卡尔积为&#123;(a,0),(a,1),(a,2),(b,0),(b,1),(b,2)&#125;。所以，交叉连接也被称为笛卡尔连接 -- 基本的语法格式，在该语法中：CROSS JOIN用于连接两个要查询的表，通过该语句可以查询两个表中所有的数据组合。 SELECT * FROM 表1 CROSS JOIN 表2; -- 2、内连接查询 -- 内连接(Inner Join)又称简单连接或自然连接，是一种非常常见的连接查询。内连接使用比较运算符对两个表中的数据进行比较并列出与连接条件匹配的数据行，组合成新的 记录。也就是说在内连接查询中只有满足条件的记录才能出现在查询结果中 -- 基本的语法格式，在该语法中：INNER JOIN用于连接两个表，ON来指定连接条件；其中INNER可以省略。 SELECT 查询字段1,查询字段2, ... FROM 表1 [INNER] JOIN 表2 ON 表1.关系字段=表2.关系字段 -- 若存在数据库mydb则删除 DROP DATABASE IF EXISTS mydb; -- 创建数据库mydb CREATE DATABASE mydb; -- 选择数据库mydb USE mydb; -- 创建部门表 CREATE TABLE department( did int (4) NOT NULL PRIMARY KEY, dname varchar(20) ); -- 创建员工表 CREATE TABLE employee ( eid int (4) NOT NULL PRIMARY KEY, ename varchar (20), eage int (2), departmentid int (4) NOT NULL ); -- 向部门表插入数据 INSERT INTO department VALUES(1001,'财务部'); INSERT INTO department VALUES(1002,'技术部'); INSERT INTO department VALUES(1003,'行政部'); INSERT INTO department VALUES(1004,'生活部'); -- 向员工表插入数据 INSERT INTO employee VALUES(1,'张三',19,1003); INSERT INTO employee VALUES(2,'李四',18,1002); INSERT INTO employee VALUES(3,'王五',20,1001); INSERT INTO employee VALUES(4,'赵六',20,1004); -- 例如，查询员工姓名及其所属部门名称 select ename,dname from department inner join employee on did=departmentid; -- 也可以这么写,都可以 select employee.ename,department.dname from department inner join employee on department.did=employee.departmentid; -- 3、外连接查询 -- 在使用内连接查询时我们发现：返回的结果只包含符合查询条件和连接条件的数据。但是，有时还需要在返回查询结果中不仅包含符合条件的数据，而且还包括左表、右表或两个表中的所有数据，此时我们就需要使用外连接查询。外连接又分为左(外)连接和右(外)连接 -- 基本的语法格式，由此可见，外连接的语法格式和内连接非常相似，只不过使用的是LEFT [OUTER] JOIN、RIGHT [OUTER] JOIN关键字。其中，关键字左边的表被称为左表，关键字右边的表被称为右表；OUTER可以省略。 -- 在使用左(外)连接和右(外)连接查询时，查询结果是不一致的，具体如下： -- （1）LEFT [OUTER] JOIN 左(外)连接：返回包括左表中的所有记录和右表中符合连接条件的记录。 -- （2）RIGHT [OUTER] JOIN 右(外)连接：返回包括右表中的所有记录和左表中符合连接条件的记录 SELECT 查询字段1,查询字段2, ... FROM 表1 LEFT | RIGHT [OUTER] JOIN 表2 ON 表1.关系字段=表2.关系字段 WHERE 条件 -- 若存在数据库mydb则删除 DROP DATABASE IF EXISTS mydb; -- 创建数据库mydb CREATE DATABASE mydb; -- 选择数据库mydb USE mydb; -- 创建班级表 CREATE TABLE class( cid int (4) NOT NULL PRIMARY KEY, cname varchar(20) ); -- 创建学生表 CREATE TABLE student ( sid int (4) NOT NULL PRIMARY KEY, sname varchar (20), sage int (2), classid int (4) NOT NULL ); -- 向班级表插入数据 INSERT INTO class VALUES(1001,'Java'); INSERT INTO class VALUES(1002,'C++'); INSERT INTO class VALUES(1003,'Python'); INSERT INTO class VALUES(1004,'PHP'); -- 向学生表插入数据 INSERT INTO student VALUES(1,'张三',20,1001); INSERT INTO student VALUES(2,'李四',21,1002); INSERT INTO student VALUES(3,'王五',24,1002); INSERT INTO student VALUES(4,'赵六',23,1003); INSERT INTO student VALUES(5,'Jack',22,1009); -- 准备这组数据有一定的特点，为的是让大家直观的看出左连接与右连接的不同之处 -- （1）班级编号为1004的PHP班级没有学生 -- （2）学号为5的学生王跃跃班级编号为1009，该班级编号并不在班级表中 -- 3.1、左（外）连接查询 -- 左(外)连接的结果包括LEFT JOIN子句中指定的左表的所有记录，以及所有满足连接条件的记录。如果左表的某条记录在右表中不存在则在右表中显示为空 -- 例如，查询每个班的班级ID、班级名称及该班的所有学生的名字 select class.cid,class.cname,student.sname from class left join student on class.cid=student.classid; -- 展示结果分析： -- （1）分别找出Java班、C++班、Python班的学生 -- （2）右表的王跃跃不满足查询条件故其没有出现在查询结果中 -- （3）虽然左表的PHP班没有学生，但是任然显示了PHP的信息；但是，它对应的学生名字为NULL -- 3.2、右（外）连接查询 -- 右(外)连接的结果包括RIGHT JOIN子句中指定的右表的所有记录，以及所有满足连接条件的记录。如果右表的某条记录在左表中没有匹配，则左表将返回空值 -- 例如，查询每个班的班级ID、班级名称及该班的所有学生的名字 select class.cid,class.cname,student.sname from class right join student on class.cid=student.classid; -- 展示结果分析： -- （1）分别找出Java班、C++班、Python班的学生 -- （2）左表的PHP班不满足查询条件故其没有出现在查询结果中 -- （3）虽然右表的jack没有对应班级，但是任然显示王跃跃的信息；但是，它对应的班级以及班级编号均为NULL 7.4、子查询子查询是指一个查询语句嵌套在另一个查询语句内部的查询；该查询语句可以嵌套在一个 SELECT、SELECT…INTO、INSERT…INTO等语句中。在执行查询时，首先会执行子查询中的语句，再将返回的结果作为外层查询的过滤条件。在子査询中通常可以使用比较运算符和IN、EXISTS、ANY、ALL等关键字 DROP TABLE IF EXISTS student; DROP TABLE IF EXISTS class; -- 创建班级表 CREATE TABLE class( cid int (4) NOT NULL PRIMARY KEY, cname varchar(20) ); -- 创建学生表 CREATE TABLE student ( sid int (4) NOT NULL PRIMARY KEY, sname varchar (20), sage int (2), classid int (4) NOT NULL ); -- 向班级表插入数据 INSERT INTO class VALUES(1001,'Java'); INSERT INTO class VALUES(1002,'C++'); INSERT INTO class VALUES(1003,'Python'); INSERT INTO class VALUES(1004,'PHP'); INSERT INTO class VALUES(1005,'Android'); -- 向学生表插入数据 INSERT INTO student VALUES(1,'张三',20,1001); INSERT INTO student VALUES(2,'李四',21,1002); INSERT INTO student VALUES(3,'王五',24,1003); INSERT INTO student VALUES(4,'赵六',23,1004); INSERT INTO student VALUES(5,'小明',21,1001); INSERT INTO student VALUES(6,'小红',26,1001); INSERT INTO student VALUES(7,'小亮',27,1002); -- 1、带比较运算符的子查询 -- 比较运算符前面我们提到过得，就是>、&lt;、=、>=、&lt;=、!=等 -- 例如，查询张三同学所在班级的信息 select * from class where cid=(select classid from student where sname='张三'); -- 例如，查询比张三同学所在班级编号还大的班级的信息 select * from class where cid>(select classid from student where sname='张三'); -- 2、带EXISTS关键字的子查询 -- EXISTS关键字后面的参数可以是任意一个子查询， 它不产生任何数据只返回TRUE或FALSE。当返回值为TRUE时外层查询才会 执行 -- 例如，假如王五同学在学生表中则从班级表查询所有班级信息 select * from class where exists (select * from student where sname='王五'); -- 3、带ANY关键字的子查询 -- ANY关键字表示满足其中任意一个条件就返回一个结果作为外层查询条件 -- 例如，查询比任一学生所属班级号还大的班级编号 select * from class where cid > any (select classid from student); -- 4、带ALL关键字的子查询 -- ALL关键字与ANY有点类似，只不过带ALL关键字的子査询返回的结果需同时满足所有内层査询条件 -- 例如，查询比所有学生所属班级号还大的班级编号 select * from class where cid > all (select classid from student); 八、函数-- 创建数据库 DROP DATABASE IF EXISTS mydb; CREATE DATABASE mydb; USE mydb; -- 创建student表 CREATE TABLE student ( sid CHAR(6), sname VARCHAR(50), age INT, gender VARCHAR(50) DEFAULT 'male' ); -- 向student表插入数据 INSERT INTO student (sid,sname,age,gender) VALUES ('S_1001', 'lili', 14, 'male'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1002', 'wang', 15, 'female'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1003', 'tywd', 16, 'male'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1004', 'hfgs', 17, 'female'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1005', 'qwer', 18, 'male'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1006', 'zxsd', 19, 'female'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1007', 'hjop', 16, 'male'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1008', 'tyop', 15, 'female'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1009', 'nhmk', 13, 'male'); INSERT INTO student (sid,sname,age,gender) VALUES ('S_1010', 'xdfv', 17, 'female'); -- 1、聚合函数 -- 在开发中，我们常常有类似的需求：统计某个字段的最大值、最小值、 平均值等等。为此，MySQL中提供了聚合函数来实现这些功能。所谓聚合，就是将多行汇总成一行；其实，所有的聚合函数均如此——输入多行，输出一行。聚合函数具有自动滤空的功能，若某一个值为NULL，那么会自动将其过滤使其不参与运算。 -- 聚合函数使用规则： -- 只有SELECT子句和HAVING子句、ORDER BY子句中能够使用聚合函数。例如，在WHERE子句中使用聚合函数是错误的 -- 1.1、count() -- 统计表中数据的行数或者统计指定列其值不为NULL的数据个数 -- 例如，查询有多少该表中有多少人 select count(*) from student; -- 1.2、max() -- 计算指定列的最大值，如果指定列是字符串类型则使用字符串排序运算 -- 例如，查询该学生表中年纪最大的学生 select max(age) from student; -- 1.3、min() -- 计算指定列的最小值，如果指定列是字符串类型则使用字符串排序运算 -- 例如，查询该学生表中年纪最小的学生 select sname,min(age) from student; -- 1.4、sum() -- 计算指定列的数值和，如果指定列类型不是数值类型则计算结果为0 -- 例如，查询该学生表中年纪的总和 select sum(age) from student; -- 1.5、avg() -- 计算指定列的平均值 -- 例如，查询该学生表中年纪的平均数 select avg(age) from student; -- 2.其他常用函数 -- 2.1、时间函数 SELECT NOW(); SELECT DAY (NOW()); SELECT DATE (NOW()); SELECT TIME (NOW()); SELECT YEAR (NOW()); SELECT MONTH (NOW()); SELECT CURRENT_DATE(); SELECT CURRENT_TIME(); SELECT CURRENT_TIMESTAMP(); SELECT ADDTIME('14:23:12','01:02:01'); SELECT DATE_ADD(NOW(),INTERVAL 1 DAY); SELECT DATE_ADD(NOW(),INTERVAL 1 MONTH); SELECT DATE_SUB(NOW(),INTERVAL 1 DAY); SELECT DATE_SUB(NOW(),INTERVAL 1 MONTH); SELECT DATEDIFF('2019-07-22','2019-05-05'); -- 2.2、字符串函数 -- 连接函数 SELECT CONCAT (); SELECT INSTR (); -- 统计长度 SELECT LENGTH(); -- 2.3、数学函数 -- 绝对值 SELECT ABS(-136); -- 向下取整 SELECT FLOOR(3.14); -- 向上取整 SELECT CEILING(3.14); 九、别名设置在査询数据时可为表和字段取別名，该别名代替表和字段的原名参与查询操作。 -- 1.为表取别名 -- 在查询操作时，假若表名很长使用起来就不太方便，此时可为表取一个別名，用该别名来代替表的名称 -- 基本的语法格式 SELECT * FROM 表名 [AS] 表的别名 WHERE .... ; -- 例如，将student改为stu查询整表 select * from student as stu; -- 2.为字段取别名 -- 在查询操作时，假若字段名很长使用起来就不太方便，此时可该字段取一个別名，用该别名来代替字段的名称 -- 基本的语法格式 SELECT 字段名1 [AS] 别名1 , 字段名2 [AS] 别名2 , ... FROM 表名 WHERE ... ; -- 例如，将student中的name取别名为“姓名” 查询整表 select name as '姓名',id from student; 十、表的关联关系在实际开发中数据表之间存在着各种关联关系。在此，介绍MySQL中数据表的三种关联关系。多对一多对一(亦称为一对多)是数据表中最常见的一种关系。例如：员工与部门之间的关系，一个部门可以有多个员工；而一个员工不能属于多个部门只属于某个部门。在多对一的表关系 中，应将外键建在多的一方否则会造成数据的冗余。多对多多对多是数据表中常见的一种关系。例如：学生与老师之间的关系，一个学生可以有多个老师而且一个老师有多个学生。通常情况下，为了实现这种关系需要定义一张中间表(亦称为连接表)该表会存在两个外键分别参照老师表和学生表。一对一在开发过程中，一对一的关联关系在数据库中并不常见；因为以这种方式存储的信息通常会放在同一张表中。 DROP TABLE IF EXISTS student; DROP TABLE IF EXISTS class; -- 创建班级表 CREATE TABLE class( cid int(4) NOT NULL PRIMARY KEY, cname varchar(30) ); -- 创建学生表 CREATE TABLE student( sid int(8) NOT NULL PRIMARY KEY, sname varchar(30), classid int(8) NOT NULL ); -- 为学生表添加外键约束 ALTER TABLE student ADD CONSTRAINT fk_student_classid FOREIGN KEY(classid) REFERENCES class(cid); -- 向班级表插入数据 INSERT INTO class(cid,cname)VALUES(1,'Java'); INSERT INTO class(cid,cname)VALUES(2,'Python'); -- 向学生表插入数据 INSERT INTO student(sid,sname,classid)VALUES(1,'tome',1); INSERT INTO student(sid,sname,classid)VALUES(2,'lucy',1); INSERT INTO student(sid,sname,classid)VALUES(3,'lili',2); INSERT INTO student(sid,sname,classid)VALUES(4,'domi',2); -- 1.关联查询 -- 查询Java班的所有学生 select * from student where classid=(select cid from class where cname='Java'); -- 2.关于关联关系的删除数据 -- 请从班级表中删除Java班级。在此，请注意：班级表和学生表之间存在关联关系；要删除Java班级，应该先删除学生表中与该班相关联的学生。否则，假若先删除Java班那么学生表中的cid就失去了关联 -- 例如，删除Java班 delete from student where classid=(select cid from class where cname='Java'); delete from class where cname='Java'; 十一、权限-- 用户和权限管理 -- 用户信息表：mysql.user -- 刷新权限 FLUSH PRIVILEGES -- 增加用户 CREATE USER kuangshen IDENTIFIED BY '123456' CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串) -- 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。 -- 只能创建用户，不能赋予权限。 -- 用户名，注意引号：如 'user_name'@'192.168.1.1' -- 密码也需引号，纯数字密码也要加引号 -- 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD -- 重命名用户 RENAME USER kuangshen TO kuangshen2 RENAME USER old_user TO new_user -- 设置密码 SET PASSWORD = PASSWORD('密码') -- 为当前用户设置密码 SET PASSWORD FOR 用户名 = PASSWORD('密码') -- 为指定用户设置密码 -- 删除用户 DROP USER kuangshen2 DROP USER 用户名 -- 分配权限/添加用户 GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] 'password'] - all privileges 表示所有权限 - *.* 表示所有库的所有表 - 库名.表名 表示某库下面的某表 -- 查看权限 SHOW GRANTS FOR root@localhost; SHOW GRANTS FOR 用户名 -- 查看当前用户权限 SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER(); -- 撤消权限 REVOKE 权限列表 ON 表名 FROM 用户名 REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名 -- 撤销所有权限 权限解释 -- 权限列表 ALL [PRIVILEGES] -- 设置除GRANT OPTION之外的所有简单权限 ALTER -- 允许使用ALTER TABLE ALTER ROUTINE -- 更改或取消已存储的子程序 CREATE -- 允许使用CREATE TABLE CREATE ROUTINE -- 创建已存储的子程序 CREATE TEMPORARY TABLES -- 允许使用CREATE TEMPORARY TABLE CREATE USER -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。 CREATE VIEW -- 允许使用CREATE VIEW DELETE -- 允许使用DELETE DROP -- 允许使用DROP TABLE EXECUTE -- 允许用户运行已存储的子程序 FILE -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE INDEX -- 允许使用CREATE INDEX和DROP INDEX INSERT -- 允许使用INSERT LOCK TABLES -- 允许对您拥有SELECT权限的表使用LOCK TABLES PROCESS -- 允许使用SHOW FULL PROCESSLIST REFERENCES -- 未被实施 RELOAD -- 允许使用FLUSH REPLICATION CLIENT -- 允许用户询问从属服务器或主服务器的地址 REPLICATION SLAVE -- 用于复制型从属服务器（从主服务器中读取二进制日志事件） SELECT -- 允许使用SELECT SHOW DATABASES -- 显示所有数据库 SHOW VIEW -- 允许使用SHOW CREATE VIEW SHUTDOWN -- 允许使用mysqladmin shutdown SUPER -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。 UPDATE -- 允许使用UPDATE USAGE -- “无权限”的同义词 GRANT OPTION -- 允许授予权限 -- 表维护 -- 分析和存储表的关键字分布 ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ... -- 检查一个或多个表是否有错误 CHECK TABLE tbl_name [, tbl_name] ... [option] ... option = &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125; -- 整理数据文件的碎片 OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... 十二、总结重要（从关键字分析）：查询语句的书写顺序和执行顺序select ===&gt; from ===&gt; where ===&gt; group by ===&gt; having ===&gt; order by ===&gt; limit查询语句的执行顺序from ===&gt; where ===&gt; group by ===&gt; having ===&gt; select ===&gt; order by ===&gt; limi 参考： 1、CSDN博主「老赖的小弟」链接：https://blog.csdn.net/weixin_45851945/article/details/114287877 2、狂神 链接：https://mp.weixin.qq.com/s/a4jA3B2j4KXBH7rci4C46w ​ https://mp.weixin.qq.com/s/-_-fRKNOi5rI6tb8RINZ0Q ​ https://mp.weixin.qq.com/s/dCt_v5KQCTpgBdlY__0BSA 3、菜鸟教程 链接：https://www.runoob.com/mysql/mysql-create-tables.html","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://codeanime.cc/categories/MySQL/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://codeanime.cc/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"MySQL","permalink":"https://codeanime.cc/tags/MySQL/"}]},{"title":"Markdown语法大全（笔记）","slug":"Markdown语法大全（笔记）","date":"2021-09-11T12:29:45.000Z","updated":"2021-10-10T01:42:25.200Z","comments":true,"path":"Markdown语法大全（笔记）.html","link":"","permalink":"https://codeanime.cc/Markdown%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89.html","excerpt":"","text":"Markdown语法大全（笔记）一、注释1、代码法&lt;div style='display: none'> 哈哈我是注释，不会在浏览器中显示。 &lt;/div> 2、html注释快捷键 comment + /。 &lt;!--哈哈我是注释，不会在浏览器中显示。--> &lt;!-- 哈哈我是多段注释， 不会在浏览器中显示。 --> 3、hack方法hack方法就是利用markdown的解析原理来实现注释的。 一般有的markdown解析器不支持上面的注释方法，这个时候就可以用hack方法。 hack方法比上面2种方法稳定得多，但是语义化太差。 [//]: # (哈哈我是最强注释，不会在浏览器中显示。) [^_^]: # (哈哈我是最萌注释，不会在浏览器中显示。) [//]: &lt;> (哈哈我是注释，不会在浏览器中显示。) [comment]: &lt;> (哈哈我是注释，不会在浏览器中显示。 二、标题Markdown 标题有两种格式。 1、使用 = 和 - 标记一级标题和二级标题 = 和 - 标记语法格式如下： 我是一级标题 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 我是二级标题 ----------------- 2、使用 # 标记使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 三、缩进、换行、空行、对齐方式 首行缩进 不同特殊占位符所占空白是不一样大的。 【1】 &amp;emsp;或&amp;#8195; //全角 【2】 &amp;ensp;或&amp;#8194; //半角 【3】 &amp;nbsp;或&amp;#160; //半角之半角 换行 由于markdown编辑器的不同,可能在一行字后面，直接换行回车，也能实现换行，但是在Visual Studio Code上，想要换行必须得在一行字后面空两个格子才行。 空行 在编辑的时候有多少个空行(只要这一行只有回车或者space没有其他的字符就算空行)，在渲染之后，只隔着一行。 对齐方式 代码： &lt;center>行中心对齐&lt;/center> &lt;p align=\"left\">行左对齐&lt;/p> &lt;p align=\"right\">行右对齐&lt;/p> 显示效果： 行中心对齐 行左对齐 行右对齐 四、字体Markdown 可以使用以下几种字体： *斜体文本* _斜体文本_ **粗体文本** __粗体文本__ ***粗斜体文本*** ___粗斜体文本___ 显示效果： 斜体文本斜体文本粗体文本粗体文本粗斜体文本粗斜体文本 五、分割线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： **** * ******- - ----------- 显示效果都一样 六、删除线如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下： 我是正常的~~我是删除线~~ 我是删除线 七、下划线下划线可以通过 HTML 的 标签来实现： &lt;u&gt;我是下划线&lt;&#x2F;u&gt; 显示效果如下所示： 我是下划线 八、脚注脚注是对文本的补充说明，Markdown 脚注的格式如下: [^我是脚注] 以下实例演示了脚注的用法： 创建脚注格式类似这样 [^RUNOOB]。[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！ 演示效果如下： 创建脚注格式类似这样 [1]。 九、列表Markdown 支持有序列表和无序列表。 1、无序列表无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记： * 第一项* 第二项* 第三项------ 分割线 ------+ 第一项+ 第二项+ 第三项------ 分割线 ------- 第一项- 第二项- 第三项 显示结果如下： 第一项 第二项 第三项—— 分割线 —— 第一项 第二项 第三项—— 分割线 —— 第一项 第二项 第三项 2、有序列表使用数字并加上 . 号来表示，如： 1. 第一项2. 第二项3. 第三项 显示结果如下： 第一项 第二项 第三项 3、列表嵌套列表嵌套只需在子列表中的选项添加四个空格即可： 1. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 显示结果如下： 第一项： 第一项嵌套的第一个元素 第一项嵌套的第二个元素 第二项： 第二项嵌套的第一个元素 第二项嵌套的第二个元素 十、区块1、区块引用Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号： &gt; 区块引用&gt; 菜鸟教程&gt; 学的不仅是技术更是梦想 效果如下： 区块引用菜鸟教程学的不仅是技术更是梦想 2、区块中使用列表区块中使用列表实例如下： &gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项 显示结果如下： 区块中使用列表 第一项 第二项 第一项 第二项 第三项 3、列表中使用区块如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。 区块中使用列表实例如下： * 第一项 &gt; 菜鸟教程 &gt; 学的不仅是技术更是梦想* 第二项 显示结果如下： 第一项 菜鸟教程学的不仅是技术更是梦想 第二项 4、多级引用语法说明： 引用需要在被引用的文本前加上&gt;符号和空格，允许多层嵌套，也允许你偷懒只在整个段落的第一行最前面加上 &gt; 。 代码： >>> 请问 Markdwon 怎么用？ - 小白>> 自己看教程！ - 愤青> 教程在哪？ - 小白 显示效果： 请问 Markdwon 怎么用？ - 小白 自己看教程！ - 愤青 教程在哪？ - 小白 十一、代码1、单行代码如果是单行代码或段落上的一个函数或片段的代码可以用反引号把它包起来（**`**），例如： &#96;printf()&#96; 函数 显示结果如下： printf() 函数 2、代码区块代码区块使用三个反引号对**```** 包裹一段代码，并指定一种语言（也可以不指定）： class CaseData: \"\"\"这是一个存放测试用例数据的类\"\"\" pass 显示结果如下： class CaseData: “””这是一个存放测试用例数据的类””” pass 十二、链接1、使用方法：[链接名称](链接地址)或者&lt;链接地址&gt; 例如： 这是一个链接 我是链接 直接使用链接地址： &lt;https:&#x2F;&#x2F;codeanime.cn&gt; 显示结果如下： https://codeanime.cn 2、高级链接链接也可以用变量来代替，文档末尾附带变量地址：这个链接用 1 作为网址变量 [Google][1]这个链接用 runoob 作为网址变量 [Runoob][runoob]然后在文档的结尾为变量赋值（网址） [1]: http:&#x2F;&#x2F;www.google.com&#x2F; [runoob]: http:&#x2F;&#x2F;www.runoob.com&#x2F; 显示结果如下： 链接也可以用变量来代替，文档末尾附带变量地址： 这个链接用 1 作为网址变量 Google 这个链接用 runoob 作为网址变量 Runoob 然后在文档的结尾为变量赋值（网址） 十三、图片Markdown 图片语法格式如下 ![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;) 开头一个感叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。 使用实例： ![RUNOOB 图标](https:&#x2F;&#x2F;www.cnblogs.com&#x2F;images&#x2F;logo_small.gif)![RUNOOB 图标](http:&#x2F;&#x2F;static.runoob.com&#x2F;images&#x2F;runoob-logo.png &quot;RUNOOB&quot;) 当然，你也可以像网址那样对图片网址使用变量: 这个链接用 1 作为网址变量 [RUNOOB][1].然后在文档的结尾位变量赋值（网址）[1]: http:&#x2F;&#x2F;static.runoob.com&#x2F;images&#x2F;runoob-logo.png 显示结果如下： 这个链接用 1 作为网址变量 RUNOOB. 然后在文档的结尾位变量赋值（网址） Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 标签。 &lt;img src&#x3D;&quot;http:&#x2F;&#x2F;static.runoob.com&#x2F;images&#x2F;runoob-logo.png&quot; width&#x3D;&quot;50%&quot;&gt; 十四、表格Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 语法格式如下： | 表头 | 表头 || ---- | ---- || 单元格 | 单元格 || 单元格 | 单元格 | 以上代码显示结果如下： 表头 表头 单元格 单元格 单元格 单元格 对齐方式 我们可以设置表格的对齐方式： -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 实例如下： | 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 | 以上代码显示结果如下： 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 十五、高级技巧1、支持HTML元素不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 目前支持的 HTML 元素有： 等 ，如： 使用 &lt;kbd&gt;Ctrl&lt;&#x2F;kbd&gt;+&lt;kbd&gt;Alt&lt;&#x2F;kbd&gt;+&lt;kbd&gt;Del&lt;&#x2F;kbd&gt; 重启电脑 输出结果为： 使用 Ctrl+Alt+Del 重启电脑 2、转义Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符： **文本加粗** \\*\\* 正常显示星号 \\*\\* 输出结果为： 文本加粗 ** 正常显示星号 ** Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \\ 反斜线&#96; 反引号* 星号_ 下划线&#123;&#125; 花括号[] 方括号() 小括号# 井字号+ 加号- 减号. 英文句点! 感叹号 3、流程图```graph LRA-->B``````sequenceDiagramA->>B: How are you?B->>A: Great!``` 显示效果： graph LRA-->B sequenceDiagramA->>B: How are you?B->>A: Great! 4、LaTex公式代码： 质能守恒方程可以用一个很简洁的方程式 `$E = m c^2 $`来表达。 显示效果： 质能守恒方程可以用一个很简洁的方程式 $E = m c^2 $来表达。 表示整行公式大部分的浏览器支持的 $$ 公式 $$ 有道云笔记 使用格式， ```mathE = mc^2``` 块级公式： ```mathx = \\dfrac&#123;-b \\pm \\sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; ``````math[\\frac&#123;1&#125;&#123;\\Bigl(\\sqrt&#123;\\phi \\sqrt&#123;5&#125;&#125;-\\phi\\Bigr) e^&#123;\\frac25 \\pi&#125;&#125; =1+\\frac&#123;e^&#123;-2\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-4\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-6\\pi&#125;&#125;&#123;1+\\frac&#123;e^&#123;-8\\pi&#125;&#125; &#123;1+\\ldots&#125; &#125; &#125; &#125;]``` 显示效果： x &#x3D; \\dfrac&#123;-b \\pm \\sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; [\\frac&#123;1&#125;&#123;\\Bigl(\\sqrt&#123;\\phi \\sqrt&#123;5&#125;&#125;-\\phi\\Bigr) e^&#123;\\frac25 \\pi&#125;&#125; &#x3D;1+\\frac&#123;e^&#123;-2\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-4\\pi&#125;&#125; &#123;1+\\frac&#123;e^&#123;-6\\pi&#125;&#125;&#123;1+\\frac&#123;e^&#123;-8\\pi&#125;&#125; &#123;1+\\ldots&#125; &#125; &#125; &#125;] 访问 MathJax 参考更多使用方法。 5、特殊字符 特殊字符 描述 字符的代码 空格符 &lt; 小于号 &lt; &gt; 大于号 &gt; &amp; 和号 &amp; ￥ 人民币 ¥ © 版权 © ® 注册商标 ® °C 摄氏度 °C ± 正负号 ± × 乘号 × ÷ 除号 ÷ ² 平方（上标²） ² ³ 立方（上标³） ³ 十六、文字颜色、大小、字体1、颜色在markdown中采用如下方式能够控制文字的颜色： &lt;font color&#x3D;&quot;#dd0000&quot;&gt;文字颜色预览&lt;&#x2F;font&gt; 2、字体大小size为1：&lt;font size&#x3D;&quot;1&quot;&gt;size为1&lt;&#x2F;font&gt;size为2：&lt;font size&#x3D;&quot;2&quot;&gt;size为2&lt;&#x2F;font&gt;size为3：&lt;font size&#x3D;&quot;3&quot;&gt;size为3&lt;&#x2F;font&gt;size为4：&lt;font size&#x3D;&quot;4&quot;&gt;size为4&lt;&#x2F;font&gt;size为6：&lt;font size&#x3D;&quot;6&quot;&gt;size为6&lt;&#x2F;font&gt; 效果如下： size为1：size为1size为2：size为2size为3：size为3size为4：size为4size为6：size为6 3、字体&lt;font face&#x3D;&quot;黑体&quot;&gt;我是黑体字&lt;&#x2F;font&gt; &lt;font face&#x3D;&quot;宋体&quot;&gt;我是宋体字&lt;&#x2F;font&gt; &lt;font face&#x3D;&quot;楷体&quot;&gt;我是楷体字&lt;&#x2F;font&gt; &lt;font face&#x3D;&quot;微软雅黑&quot;&gt;我是微软雅黑字&lt;&#x2F;font&gt; &lt;font face&#x3D;&quot;fantasy&quot;&gt;我是fantasy字&lt;&#x2F;font&gt;&lt;font face&#x3D;&quot;Helvetica&quot;&gt;我是Helvetica字&lt;&#x2F;font&gt; 效果如下： 我是黑体字我是宋体字我是楷体字我是微软雅黑字我是fantasy字我是Helvetica字 4、背景色语法如下： &lt;table&gt;&lt;tr&gt;&lt;td bgcolor&#x3D;#F4A460&gt;背景色的设置是按照十六进制颜色值：#F4A460&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor&#x3D;#FF6347&gt;背景色的设置是按照十六进制颜色值：#FF6347&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt; &lt;table&gt;&lt;tr&gt;&lt;td bgcolor&#x3D;#D8BFD8&gt;背景色的设置是按照十六进制颜色值：#D8BFD8&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt; &lt;table&gt;&lt;tr&gt;&lt;td bgcolor&#x3D;#008080&gt;背景色的设置是按照十六进制颜色值：#008080&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt; &lt;table&gt;&lt;tr&gt;&lt;td bgcolor&#x3D;#FFD700&gt;背景色的设置是按照十六进制颜色值：#FFD700&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt; 效果如下： 背景色的设置是按照十六进制颜色值：#F4A460 背景色的设置是按照十六进制颜色值：#FF6347 背景色的设置是按照十六进制颜色值：#D8BFD8 背景色的设置是按照十六进制颜色值：#008080 背景色的设置是按照十六进制颜色值：#FFD700 参考： 作者：**miki的测试笔记** 链接：https://www.cnblogs.com/miki-peng/articles/12502985.html 作者：择势量投 链接：https://www.jianshu.com/p/ebe52d2d468f 来源：简书","categories":[{"name":"MarkDown语法","slug":"MarkDown语法","permalink":"https://codeanime.cc/categories/MarkDown%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://codeanime.cc/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MarkDown语法","slug":"MarkDown语法","permalink":"https://codeanime.cc/tags/MarkDown%E8%AF%AD%E6%B3%95/"}]},{"title":"Git常用命令","slug":"Git常用命令","date":"2021-09-11T08:44:28.000Z","updated":"2021-09-12T00:29:50.330Z","comments":true,"path":"Git常用命令.html","link":"","permalink":"https://codeanime.cc/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html","excerpt":"","text":"Git 常用命令仓库# 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url] 配置# 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name \"[name]\" $ git config [--global] user.email \"[email address]\" 增加/删除文件# 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] 代码提交# 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... 分支# 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 标签# 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 查看信息# 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat \"@&#123;0 day ago&#125;\" # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog 远程同步# 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all 撤销# 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop 其他# 生成一个可供发布的压缩包 $ git archive 原文作者：码云 原文链接：https://gitee.com/all-about-git 参考文章：狂神说","categories":[{"name":"Git","slug":"Git","permalink":"https://codeanime.cc/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://codeanime.cc/tags/Git/"},{"name":"Linux","slug":"Linux","permalink":"https://codeanime.cc/tags/Linux/"},{"name":"笔记","slug":"笔记","permalink":"https://codeanime.cc/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Vim使用手册","slug":"Vim使用手册","date":"2021-09-11T08:00:01.000Z","updated":"2021-10-10T01:42:41.875Z","comments":true,"path":"Vim使用手册.html","link":"","permalink":"https://codeanime.cc/Vim%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.html","excerpt":"","text":"Vim使用手册所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。 但是目前我们使用比较多的是 vim 编辑器。 vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。 什么是 vim？Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。 连 vim 的官方网站 (http://www.vim.org) 自己也说 vim 是一个程序开发工具而不是文字处理软件。 vim 键盘图： vi/vim 的使用基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 这三种模式的作用分别是： 命令模式：用户刚刚启动 vi/vim，便进入了命令模式。 此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。 以下是常用的几个命令： i 切换到输入模式，以输入字符。 x 删除当前光标所在处的字符。 : 切换到底线命令模式，以在最底一行输入命令。 若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。 命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。 输入模式在命令模式下按下i就进入了输入模式。 在输入模式中，可以使用以下按键： 字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键，在文本中移动光标 HOME/END，移动光标到行首/行尾 Page Up/Page Down，上/下翻页 Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 ESC，退出输入模式，切换到命令模式 底线命令模式在命令模式下按下:（英文冒号）就进入了底线命令模式。 底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。 在底线命令模式中，基本的命令有（已经省略了冒号）： q 退出程序 w 保存文件 按ESC键可随时退出底线命令模式。 简单的说，我们可以将这三个模式想成底下的图标来表示： vi/vim 使用实例使用 vi/vim 进入一般模式如果你想要使用 vi 来建立一个名为 runoob.txt 的文件时，你可以这样做： $ vim runoob.txt 直接输入 vi 文件名 就能够进入 vi 的一般模式了。请注意，记得 vi 后面一定要加文件名，不管该文件存在与否！ 按下 i 进入输入模式(也称为编辑模式)，开始编辑文字在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！ 在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。 这个时候，键盘上除了 Esc 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。 按下 ESC 按钮回到一般模式好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 Esc 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！ 在一般模式中按下 :wq 储存后离开 viOK，我们要存档了，存盘并离开的指令很简单，输入 :wq 即可保存离开！ OK! 这样我们就成功创建了一个 runoob.txt 的文件。 vi/vim 按键说明除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。 第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等 移动光标的方法 h 或 向左箭头键(←) 光标向左移动一个字符 j 或 向下箭头键(↓) 光标向下移动一个字符 k 或 向上箭头键(↑) 光标向上移动一个字符 l 或 向右箭头键(→) 光标向右移动一个字符 如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！ [Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用) [Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用) [Ctrl] + [d] 屏幕『向下』移动半页 [Ctrl] + [u] 屏幕『向上』移动半页 + 光标移动到非空格符的下一行 - 光标移动到非空格符的上一行 n 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20 则光标会向后面移动 20 个字符距离。 0 或功能键[Home] 这是数字『 0 』：移动到这一行的最前面字符处 (常用) $ 或功能键[End] 移动到这一行的最后面字符处(常用) H 光标移动到这个屏幕的最上方那一行的第一个字符 M 光标移动到这个屏幕的中央那一行的第一个字符 L 光标移动到这个屏幕的最下方那一行的第一个字符 G 移动到这个档案的最后一行(常用) nG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) gg 移动到这个档案的第一行，相当于 1G 啊！ (常用) n n 为数字。光标向下移动 n 行(常用) 搜索替换 /word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用) ?word 向光标之上寻找一个字符串名称为 word 的字符串。 n 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ N 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！ :n1,n2s/word1/word2/g n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用) :1,$s/word1/word2/g 或 :%s/word1/word2/g 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用) :1,$s/word1/word2/gc 或 :%s/word1/word2/gc 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用) 删除、复制与贴上 x, X 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用) nx n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 dd 删除游标所在的那一整行(常用) ndd n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用) d1G 删除光标所在到第一行的所有数据 dG 删除光标所在到最后一行的所有数据 d$ 删除游标所在处，到该行的最后一个字符 d0 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符 yy 复制游标所在的那一行(常用) nyy n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用) y1G 复制游标所在行到第一行的所有数据 yG 复制游标所在行到最后一行的所有数据 y0 复制光标所在的那个字符到该行行首的所有数据 y$ 复制光标所在的那个字符到该行行尾的所有数据 p, P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用) J 将光标所在行与下一行的数据结合成同一行 c 重复删除多个数据，例如向下删除 10 行，[ 10cj ] u 复原前一个动作。(常用) [Ctrl]+r 重做上一个动作。(常用) 这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！ . 不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用) 第二部分：一般模式切换到编辑模式的可用的按钮说明 进入输入或取代的编辑模式 i, I 进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用) a, A 进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用) o, O 进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用) r, R 进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用) 上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！ [Esc] 退出编辑模式，回到一般模式中(常用) 第三部分：一般模式切换到指令行模式的可用的按钮说明 指令行的储存、离开等指令 :w 将编辑的数据写入硬盘档案中(常用) :w! 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ :q 离开 vi (常用) :q! 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。 注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～ :wq 储存后离开，若为 :wq! 则为强制储存后离开 (常用) ZZ 这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出) ZQ 不保存，强制退出。效果等同于 **:q!**。 :w [filename] 将编辑的数据储存成另一个档案（类似另存新档） :r [filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 :n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。 :! command 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！ vim 环境的变更 :set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号 :set nonu 与 set nu 相反，为取消行号！ 特别注意，在 vi/vim 中，数字是很有意义的！数字通常代表重复做几次的意思！ 也有可能是代表去到第几个什么什么的意思。 举例来说，要删除 50 行，则是用 『50dd』 对吧！ 数字加在动作之前，如我要向下移动 20 行呢？那就是『20j』或者是『20↓』即可。 原文链接：https://www.runoob.com/linux/linux-vim.html 原文作者：菜鸟教程","categories":[{"name":"VIm","slug":"VIm","permalink":"https://codeanime.cc/categories/VIm/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://codeanime.cc/tags/Linux/"},{"name":"Vim","slug":"Vim","permalink":"https://codeanime.cc/tags/Vim/"}]},{"title":"Linux系统小记","slug":"Linux系统小记","date":"2021-09-11T07:43:18.000Z","updated":"2021-10-10T01:42:13.129Z","comments":true,"path":"Linux系统小记.html","link":"","permalink":"https://codeanime.cc/Linux%E7%B3%BB%E7%BB%9F%E5%B0%8F%E8%AE%B0.html","excerpt":"","text":"Linux系统小记系统目录结构 以下是对这些目录的解释： /bin：bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。 /boot：这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。 /dev ：dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。 /etc：etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home：用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。 /lib：lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /media：linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。 /mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。 /opt：opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 /proc：proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器： echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all /root：该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin：s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。 /selinux： 这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。 /srv： 该目录存放一些服务启动之后需要提取的数据。 /sys： 这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。 sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。 该文件系统是内核设备树的一个直观反映。 当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。 /tmp：tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。 /usr： usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。 /usr/bin：系统用户使用的应用程序。 /usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src：内核源代码默认的放置目录。 /var：var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 /run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。 登陆一般来说，用户登陆方式有三种： 命令行登陆 ssh登陆 图形界面登陆 shutdown：关机 关机指令：shutdown sync # 将数据由内存同步到硬盘 shutdown # 关机指令，可以使用man shutdown来看一下帮助文档 shutdown -h 10 # 10分钟后关机 shutdown -h now # 马上关机 shutdown -h 10:11 # 10点11分关机 shutdown -h +now # 十分钟后关机 shutdown -r now # 马上重启 shutdown -r +10 # 十分钟后重启 reboot # 重启 halt # 关闭系统 注：关机或重启之前要运行sync命令，把内存中的数据同写到磁盘 ls：列出目录语法：ls [选项] [目录名称] 选项与参数： -a：显示所有文件及目录，连同隐藏文件（以.开头） -l：使用长格式列出文件及目录信息（包括文件的属性与权限等等数据） cd：切换目录cd：是change directory的缩写，该命令的功能是从当前目录切换到指定目录 语法：cd [相对路径或绝对路径] cd /home # 切换到home目录 cd .. # 返回上一级目录 cd / # 回到根目录 cd ~ # 回到家目录 pwd：显示当前目录pwd是print working directory的缩写，也就是显示当前工作目录的绝对路径 语法：pwd [参数] pwd # 显示当前工作目录 mkdir：创建新目录mkdir是“make directories”的缩写，用来创建目录。 语法：mkdir [选项] [目录] -m：建立目录的同时设置目录的权限 -p：递归创建多级目录 mkdir codeanime #创建codenaime目录 mkdir -p test1/test2/test3/test4 #递归创建多层目录 mkdir -m 711 test2 # 创建权限为rwx--x--x的目录 rmdir：删除空目录rmdir是remove directory的缩写，用来删除空目录 语法：rmdir [选项] [目录] -p：用递归的方式删除指定的目录路径中的所有父级目录，非空则报错 rmdir -p test1 # 删除非空目录 rmdir test2 # 删除空目录 cp：复制文件或目录cp是copy的缩写，用来复制文件或目录 语法：cp [选项] [文件或目录] -p：保留源文件或目录的所有属性 -d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录 -r：递归复制文件和目录（recursion） -a：等价于-dpr选项 -f：为强制（force）的意思，若目标文件已存在，则会直接覆盖原文件 -i：若目标文件已存在，则会询问是否覆盖。（inquire） -l：对源文件建立硬连接，而非复制文件 -s：对源文件建立符号连接，而非复制文件，（即捷径） -u：当源文件比目标文件新，或者目标文件不存在时，才执行复制此操作 cp /root/install.sh /tmp/codeanime # 把root目录下的install.sh文件复制到/tmp/codeanime目录下 rm：移除文件或目录rm是remove的缩写，用来移除文件或目录，即删除。 语法：rm [选项] [文件或目录] -f：就是force的意思，忽略不存在的文件，不会出现警告信息 -i：删除前会询问用户是否操作 -r：递归删除（recursion） rm /tmp/codenaime/install.sh # 删除/tmp/codeanime目录下的install.sh mv：移动文件与目录（或修改名称）mv是“move”单词的缩写，可以移动文件或对其改名。 语法：mv [选项] -f：force强制，覆盖已有文件时，不进行任何提示 -i：inquire询问，若存在同名文件，则向用户询问是否覆盖 -u：当源文件比目标文件新，或者目标文件不存在时，才执行移动此操作 mv install.sh test # 移动当前目录下install.sh到本目录下的test文件夹下 chgrp：更改文件用户组语法：chgrp [选型] [文件或目录] -R：递归处理，将指定目录下的所有文件及子目录一并处理（recursion） chgrp -R root install.sh # 更改文件install.sh的组为root chown：改变文件或目录用户和用户组语法：chown [选项] -R：对目前目录下的所有文件与子目录进行相同的拥有者变更 chown root install.sh # 更改文件install.sh用户为root chmod：改变文件或目录权限语法：chmod [选项] [文件或文件夹] -R：对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更) chmod 770 install.sh # 改变install.sh的权限为770，即-rwx-rwx--- cat：由第一行开始显示文本内容语法：cat [选项] [文件] -n：显示行数（空行也编号） -b：显示行数（空行不编号） -E：每行结束处显示$符号 -T：将TAB字符显示为 ^I符号 -v：使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外 -e：等价于”-vE”组合 -t：等价于”-vT”组合 -A：等价于 -vET组合 cat -A install.sh # 查看instal.sh tac：与cat相反文件内容从最后一行开始显示，可以看出tac是cat倒着写的 tac -A install.sh # 查看instal.sh nl：添加行号语法：nl [选项] [文件] -b：指定行号指定的方式。主要有两种：-b a表示无论为空行，也同样列出行号（类似cat -n）;-b t如果有空行，空的那一行不要列出行号（默认值） -n：列出行号表示的方式。主要有三种：-n ln：行号在荧幕的的最左方显示；-n rn：行号在自己栏位的最右方显示，且不加0；-n rz：行号在自己栏位的最右方显示，且加0； -w：行号栏位的占用的位数 nl -n ln install.sh nl -b t install.sh nl -w 10 install.sh # 行号占位10位 more：显示文本文件内容语法：more [文件] # 空格键：向下翻一页 # Enter键：向下翻一行 # /字串：在这个显示的内容中，向下搜寻“字串”这个关键字 # :f：立刻显示出档名中以及显示的行数 # q：立刻离开more，不再显示该文件内容 # b或[ctrl]-b：往回翻页，只对文件有用，对管线无用 # H键：显示帮助屏 # B键：显示上一屏内容 # Q键：退出more命令 # Ctrl+F、空格键：向下滚动一屏 # Ctrl+B：返回上一屏 # =： 输出当前的行号 # V：调用vi编辑器 # !：调用Shell，并执行命令 more install.sh less：一页一页滚动语法：less [文件] # PageUp键向上翻页 # PageDown键向下翻页 # q：退出less程序 # 空格键：向下翻动一页 # /字串：向下搜寻“字串” # ？字串：向上搜寻“字串” # n：重复前一个搜寻（与/或？有关） # N：反向的重复前一个搜寻（与/或？有关） less install.sh head：取出文件前面几行语法：head [选项] [文件] -n后面跟数字，代表显示几行 head -n10 install.sh # 显示文件前十行 tail：取出文件后几行语法：tail [选项] [文件] -n后面接数字，代表显示几行 默认显示最后10行。 tail -n20 install.sh # 显示文件最后20行 ln：为文件创建链接ln英文全称是“link”，即链接的意思，它的功能是为某一个文件在另外一个位置建立一个同步的链接。 一种是hard link，又称为硬链接；另一种是symbolic link，又称为符号链接。 通俗一点理解，可以把硬链接当成源文件的副本，他和源文件一样的大小，但是事实上却不占任何空间。符号链接可以理解为类似windows一样的快捷方式。 符号链接 ： 符号链接以路径的形式存在，类似于Windows操作系统中的快捷方式。 符号链接可以跨文件系统 ，硬链接不可以。 符号链接可以对一个不存在的文件名进行链接，硬链接不可以。 符号链接可以对目录进行链接，硬链接不可以。 硬链接： 硬链接以文件副本的形式存在，但不占用实际空间。 硬链接不允许给目录创建硬链接。 硬链接只有在同一个文件系统中才能创建。 语法格式： ln [选项] [源文件或目录] [目标文件或目录] -b：为每个已存在的目标文件创建备份文件 -f：强制创建链接，即使目标文件已经存在 -n：把指向目录的符号链接视为一个普通文件 -i：交互模式，若目标文件已经存在，则提示用户确认进行覆盖 -s：对源文件建立符号链接，而非硬链接 ln -b install.sh # 创建备份文件 ln install.sh install2.sh # 创建install.sh的硬链接文件install2.sh ln -s install.sh install3.sh # 创建install.sh的符号链接文件install3.sh useradd：创建用户语法：useradd [选项] [用户名] -c：添加备注文字（comment） -d：目录，新用户每次登陆时所使用的家目录，如果此目录不存在，则同时使用-m选项，可以创建主目录 -g：指定用户对应的用户组 -G：定义此用户为多个不同组的成员 -m：用户目录不存在时则自动创建 -s：Shell文件 指定用户的登录Shell -u：指定用户id useradd -m codeanime # 创建一个用户为codeanime，其中-m为用户codeanime产生一个主目录/home/codeanime 增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow,.etc/group等。 su：切换用户名语法：su [用户名] sudo su # 从普通用户切换到root用户 exit或logout或快捷方式ctrl+d #退回到原来的用户 su - root # 在切换用户时，如果想在切换用户之后使用新用户的工作环境，可以在su和username之间加- $表示普通用户 #表示超级用户，即root用户 userdel：删除账号语法：userdel [选项] [用户名] -r：把用户的主目录一起删除 如果一个用户的账号不再使用，可以从系统中删除。 删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。 userdel codeanime # 删除codeanime账户 userdel -r codeanime # 此命令删除用户codeanime在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。 usermod：修改账号语法：usermod [选项] [账号] 常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。 usermod -s /bin/code -d /home/co –g developer codeanime # 此命令将用户codeanime修改为code，主目录改为/home/co，用户组改为developer。 passwd：修改用户账户密码语法：passwd [选项] [用户名] -l：锁定用户密码，无法被用户自行修改 -u：解开已锁定用户密码，允许用户自行修改 -d：删除密码 -f：强迫用户下次登录时修改密码 passwd # 修改密码 passwd codeanime # 修改codeanime用户密码 passwd -d codeanime # 删除codeanime用户的密码，下次用户codeanime登陆时，系统不再允许codeanime用户登陆 passwd -l codeanime # 锁定codeanime用户，使其不能登陆 groupadd：新建工作组用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新 语法：groupaddd [选项] [用户组] -g：指定新建工作组的id -o：允许添加组ID号不唯一的工作组 groupadd group1 # 向系统增加了一个group1新组，新组的组标识号是在当前已有的最大组标识号的基础上加1 groupadd -g 101 group2 # 此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101 groupdel：删除用户组语法：groupdel [选项] [群组名称] groupdel group1 # 删除用户组group1 groupmod：更改群组识别码或名称语法：groupmod [选项] [用户组] -g：设置欲使用的群组识别码 -o：重复使用群组识别码 -n：设置欲使用的群组名称 groupmod -g 102 group2 # 此命令将组group2的组标识号修改为102 groupmod –g 103 -n group3 group2 # 将组group2的标识号改为103，组名修改为group3 newgrp：登入另一个群组newgrp命令类的英文全称为“new group”,该命令类似login指令，当它是以相同的帐号，另一个群组名称，再次登入系统。欲使用newgrp指令切换群组，您必须是该群组的用户，否则将无法登入指定的群组。 单一用户要同时隶属多个群组，需利用交替用户的设置。若不指定群组名称，则newgrp指令会登入该用户名称的预设群组 语法：newgrp [选项] newgrp root # 将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组 df：显示磁盘空间使用情况df命令的英文全称即“Disk Free”，顾名思义功能是用于显示系统上可使用的磁盘空间。默认显示单位为KB，建议使用“df -h”的参数组合，根据磁盘容量自动变换合适的单位，更利于阅读 语法：df [选项] [目录或文件] -a：显示所有系统文件 -k：以 KBytes 的容量显示各文件系统 -m：以 MBytes 的容量显示各文件系统 -h：以容易阅读的方式显示 -H：以1000字节为换算单位来显示 -T：输出时显示文件系统类型 -i：显示索引字节信息，不用硬盘容量，而以 inode 的数量来显示 df -h # 以容易阅读的方式显示 df -aT # 将系统内的所有特殊文件格式及名称都列出来 df -h /etc # 将 /etc 底下的可用的磁盘容量以易读的容量格式显示 du：查看空间du命令的英文全称是“Disk Usage”，即用于查看磁盘占用空间的意思。但是与df命令不同的是du命令是对文件和目录磁盘使用的空间的查看，而不是某个分区,与 df 不一样的是，du 这个命令其实会直接到文件系统内去搜寻所有的文件数据 语法：du [选项] [文件] -a：显示目录中所有文件大小 -h：以易读方式显示文件大小 -s：仅显示总计 -S：不包括子目录下的总计，与 -s 有点差别 -k：以KB为单位显示文件大小 -m：以MB为单位显示文件大小 du # 直接输入 du 没有加任何选项时，则 du 会分析当前所在目录的文件与目录所占用的硬盘空间 du -a # 将文件的容量也列出来 du -sm /* # 检查根目录底下每个目录所占用的容量,通配符 * 来代表每个目录 mount：文件系统挂载语法：mount [选项] mount /dev/hdc6 /mnt/hdc6 # 将 /dev/hdc6 挂载到 /mnt/hdc6 上面 umount：卸载文件系统语法：umount [选项] [装置文件名或挂载点] -f：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下 -n：不升级 /etc/mtab 情况下卸除 umount /dev/hdc6 # 卸载/dev/hdc6","categories":[{"name":"Linux","slug":"Linux","permalink":"https://codeanime.cc/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://codeanime.cc/tags/Linux/"},{"name":"笔记","slug":"笔记","permalink":"https://codeanime.cc/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"记一次Hexo博客迁移至另一台电脑","slug":"记一次Hexo博客迁移至另一台电脑","date":"2021-09-03T12:50:45.000Z","updated":"2021-09-03T12:51:50.585Z","comments":true,"path":"记一次Hexo博客迁移至另一台电脑.html","link":"","permalink":"https://codeanime.cc/%E8%AE%B0%E4%B8%80%E6%AC%A1Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3%E5%8F%A6%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91.html","excerpt":"","text":"记一次Hexo博客迁移至另一台电脑安装Node.js下载地址见这里。然后正常安装。安装完成后，输入node -v和npm -v，如果出现版本号，那么就安装成功了。 安装git下载地址见这里。然后正常安装，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt，这样我们就可以直接在命令提示符里打开git了。安装完成后在命令提示符中输入git —version验证是否安装成功。 最好把nodejs和git都配置到环境变量里 安装 Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 $ npm install -g hexo-cli 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 $ hexo init &lt;folder&gt; $ cd &lt;folder&gt; $ npm install 注：这里的是文件夹名，新搭建的hexo的小伙伴估计都被坑过 例如我要把博客放在D盘blog文件夹里面的codeanime文件夹里，就在blog文件夹右键，git bash here， 注意是在blog文件夹，然后执行命令： hexo init codeanime cd codeanime npm install 新建完成后，指定文件夹的目录如下： . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes 将原来的文件拷贝到新电脑中需要拷贝的文件有： _config.yml, theme/, source/, scaffolds/, package.json, .gitignore 下面是这些文件的作用： _config.yml：整个站点的配置，包括基本介绍，所使用的主题，关联的仓库等；theme/：所用的主题以及主题的配置；source/：目前所写的所有文章以及404页面等；scaffolds/：Hexo所提供的模板文件；package.json：说明站点使用了哪些包；gitignore：放置在git端时忽略的文件； 需要删除的文件 .git, node_modules/, public/, .deploy_git/, db_json 这些文件的作用： .git：git的配置，关联文件夹等，由于我们已经换了电脑，所以之前的配置应该被舍弃掉；node_modules/：在用npm install时会重新生成；public/：在用hexo generate时会重新生成；.deploy_git/：在用hexo deploy时会重新生成；db.json：站点的一些数据文件； 其实这些文件就是.gitignore中写的可以被忽略的内容】 然后进入你的博客目录（我的是codeanime文件夹），右键git bash here，执行命令 &#x2F;&#x2F; 安装其他一些必要的组件 npm install hexo-deployer-git --save npm install hexo-generator-feed --save npm install hexo-generator-sitemap --save 本地测试&#x2F;&#x2F;先本地预览 hexo clean hexo g hexo s &#x2F;&#x2F;此时可以先在localhost:4000 本地预览博客，如果不报错，那就说明迁移成功 部署到Github生成SSH添加到GitHub在你的博客文件夹中打开git bash,复制一下代码 git config --global user.name &quot;yourname&quot; git config --global user.email &quot;youremail&quot; 内容换成你自己的Githuby用户名和邮箱。执行一下两条指令，检查你有没有输入正确。 git config user.name git config user.email 然后创建SSH,一路回车 ssh-keygen -t rsa -C &quot;youremail&quot; 注意C是大写。 这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹（在C:\\Users\\你的用户名）。 ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。 而后在GitHub的setting中，找到SSH and GPC keys的设置选项，点击New SSH key把你的id_rsa.pub里面的信息复制进去,title随便填写。 测试&#x2F;&#x2F; 正式部署hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 其他期间测试的时候会出现登陆github账号的提醒,正常登陆登陆就行了 踩坑：报错1：hexo d时出现ERROR deployer not found: gitERROR Deployer not found: git 解决方案这是因为没安装hexo-deployer-git插件，在站点目录下输入下面的插件安装就好了： npm install hexo-deployer-git --save 然后在使用Hexo d命令就可以推送了。 错误2:hexo报错spwan failed 报错2FATAL &#123; err: Error: Spawn failed at ChildProcess.&lt;anonymous&gt; (&#x2F;usr&#x2F;local&#x2F;src&#x2F;hexo&#x2F;cairbin&#x2F;node_modules&#x2F;hexo-util&#x2F;lib&#x2F;spawn.js:51:21) at ChildProcess.emit (events.js:376:20) at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:277:12) &#123; code: 128 &#125;&#125; Something&#39;s wrong. Maybe you can find the solution here: %s https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;troubleshooting.html 解决方案 进行以下处理 ##进入博客根目录(以我的为例)cd &#x2F;usr&#x2F;local&#x2F;src&#x2F;hexo&#x2F;cairbin&#x2F;##删除git提交文件夹rm -rf .deploy_git&#x2F;git config --global core.autocrlf false 最后重新生成提交 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 报错3! [remote rejected] master -&gt; master (push declined due to email privacy restrictions) 解决方案 这是因为你的github设置出了问题 浏览器进入github.com 登陆github -&gt; “+” -&gt;settings 后续操作如下图 重新提交 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 大功告成","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://codeanime.cc/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://codeanime.cc/tags/Hexo/"},{"name":"迁移","slug":"迁移","permalink":"https://codeanime.cc/tags/%E8%BF%81%E7%A7%BB/"},{"name":"搬家","slug":"搬家","permalink":"https://codeanime.cc/tags/%E6%90%AC%E5%AE%B6/"}]},{"title":"在GitHub上部署hexo博客","slug":"在GitHub上部署hexo博客","date":"2021-09-03T12:18:02.000Z","updated":"2021-09-03T12:49:47.800Z","comments":true,"path":"在GitHub上部署hexo博客.html","link":"","permalink":"https://codeanime.cc/%E5%9C%A8GitHub%E4%B8%8A%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2.html","excerpt":"","text":"在GitHub上部署hexo博客在GitHub Pages部署hexo博客 需要的工具 node.js git 安装及部署 安装完成node.js和git后安装hexonpm install hexo -g安装后使用hexo -v查看版本号，看是否安装成功 创建hexo项目寻找一个文件夹作为博客的目录在这个目录下使用hexo init该目录 使用npm install安装需要的组件 使用npm install hexo-deployer-git --save安装插件 使用hexo generate或hexo g生成当前的博客 使用hexo server或hexo s启动服务器然后就可以打开浏览器访问localhost:4000在本地查看当前的博客 生成SSH密钥打开Git Bash，使用以下命令配置gitgit config --global user.name &quot;你的github用户的名字&quot;git config --global user.email &quot;你的github账户邮箱&quot;cd ~/.sshssh-keygen -t rsa -C &quot;你的github账户邮箱&quot;连续三次回车eval &quot;$(ssh-agent -s)&quot;，添加到ssh-agentssh-add ~/.ssh/id_rsa，添加生成的SSH密钥到ssh-agentcat ~/.ssh/id_rsa.pub复制此时显示的内容，内容应该是ssh-rsa简介 Ctrl+C退出后，在GitHub上新建一个新的仓库，收藏名随意，还需要记录下来，我这里起名叫博客，最下面的用README初始化这个仓库，要勾选上，然后保存卫生。进入这个仓库后选择设置，在左侧选项卡选项中翻到下面，GItHub页面，源选择master分支，选择保存后，会在这部分的标题处写明这个仓库的url，就是你博客的网址了。还是页面的左侧的选项卡，部署选择添加部署键，添加密钥。题目随意，我设置为了博客的关键粘贴我们刚才复制的那一段。最下面允许写访问要打勾。选择添加项即可。然后在Git的Bash的使用中ssh -T git@github.com测试，如果看到喜后面是你的用户名，就说明成功了。 修改hexo配置文件 打开本地博客的根目录，找到_config.yml文件， 在文件的开头处，第二部分，URL部分改成如下内容： # URL ## 如果您的站点放在子目录中，请将 url 设置为 &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; 并将 root 设置为 &#39;&#x2F;child&#x2F;&#39; url: http:&#x2F;&#x2F;yoursite.com&#x2F;blog root: &#x2F;blog &#x2F; 永久链接： :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F; permalink_defaults: 这里的url和root这需要修改。url在入口要加仓库名，我的仓库叫博客，所以写成了 http:&#x2F;&#x2F;yoursite.com&#x2F;仓库名 ，同理root修改成 &#x2F;仓库名&#x2F; 。 在文件的结尾处，部署这部分改成如下内容： # 部署 ## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html deploy: type: git repository: git@github.com:Davidham3&#x2F;blog.git branch: master 需要的是，这里的repository这个，应该去GitHub里面你新建那个那个的那个叫的仓库里面找。进入仓库主页后，点击下面绿色的克隆，或者下载在新弹出的窗口选项选择使用SSH，然后将下面的文字复制粘贴到这里。 修改完配置文件后保存退出。 使用hexo clean清除扫描 使用hexo g生成博客 使用hexo deploy或hexo d将部署到GitHub上，打开你的GitHub Pages设置进入输入的url，就可以的博客了。以上两步也可以连写为hexo d -g。 原文作者：戴维汉姆 原文链接：https://davidham3.github.io/blog/2018/02/20/%E5%9C%A8github%E4%B8%8A%E9%83%A8%E7%BD%B2hexo/","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://codeanime.cc/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://codeanime.cc/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"https://codeanime.cc/tags/Github/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://codeanime.cc/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"Hexo初使用","slug":"Hexo初使用","date":"2021-09-03T08:09:48.370Z","updated":"2021-09-14T08:14:10.113Z","comments":true,"path":"Hexo初使用.html","link":"","permalink":"https://codeanime.cc/Hexo%E5%88%9D%E4%BD%BF%E7%94%A8.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://codeanime.cc/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://codeanime.cc/tags/Hexo/"}]},{"title":"Hexo-Fluid添加追番页面&&Bangumi 插件使用说明","slug":"Hexo-Fluid添加追番页面-Bangumi-插件使用说明","date":"2021-08-30T06:34:29.000Z","updated":"2021-08-30T06:38:32.636Z","comments":true,"path":"Hexo-Fluid添加追番页面-Bangumi-插件使用说明.html","link":"","permalink":"https://codeanime.cc/Hexo-Fluid%E6%B7%BB%E5%8A%A0%E8%BF%BD%E7%95%AA%E9%A1%B5%E9%9D%A2-Bangumi-%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html","excerpt":"","text":"话不多少，立马开淦！ 一、根据官方文档安装插件参考Github项目地址 二、安装$ npm install hexo-bilibili-bangumi --save 三、配置将下面的配置写入站点的配置文件 _config.yml 里。（注意不是主题配置文件） bangumi: # 追番设置 enable: true path: vmid: title: '追番列表' quote: '生命不息，追番不止！' show: 1 loading: metaColor: color: webp: progress: extra_options: key: value cinema: # 追剧设置 enable: true path: vmid: title: '追番列表' quote: '生命不息，追番不止！' show: 1 loading: metaColor: color: webp: progress: extra_options: key: value enable: 是否启用 path: 页面路径，默认bangumis/index.html, cinemas/index.html vmid: 哔哩哔哩的 vmid(uid),如何获取？ title: 该页面的标题 quote: 写在页面开头的一段话，支持 html 语法，可留空。 show: 初始显示页面：0: 想看, 1: 在看, 2: 看过，默认为1 loading: 图片加载完成前的 loading 图片 metaColor: meta 部分(简介上方)字体颜色 color: 简介字体颜色 webp: 番剧封面使用webp格式(此格式在safari浏览器下不显示，但是图片大小可以缩小 100 倍左右), 默认true progress: 获取番剧数据时是否显示进度条，默认true extra_options: 此配置会扩展到Hexopage变量中 四、使用 hexo new page &quot;bangumis&quot;其 bangumis的 md 文档加上type: &quot;bangumis&quot; 添加 uid 在hexo generate或hexo deploy之前使用hexo bangumi -u命令更新番剧数据！ 删除数据命令:hexo bangumi -d 五、获取 uid登录哔哩哔哩后前往https://space.bilibili.com页面，网址最后的一串数字就是 uid *需要将追番列表设置为公开！* 六、手动添加番剧数据因为某些番剧在哔哩哔哩上没有，但是又想在 hexo 中展示，怎么办呢？现在支持手动添加番剧数据了！ 在 sources/_data/ 目录下新建文件，命名为 extra_bangumis.json ，并添加以如下内容: &#123; \"watchedExtra\": [ &#123; \"title\": \"缘之空\", \"type\": \"番剧\", \"area\": \"日本\", \"cover\": \"https://cdn.jsdelivr.net/gh/mmdjiji/bangumis@main/Yosuga-no-Sora/cover.jpg\", \"totalCount\": \"全12话\", \"id\": 0, \"follow\": \"不可用\", \"view\": \"不可用\", \"danmaku\": \"不可用\", \"coin\": \"不可用\", \"score\": \"不可用\", \"des\": \"远离都市的田园小镇，奥木染。春日野悠带着妹妹穹，来到了这座城镇。坐落在这里的是，儿时暑假经常造访的充满回忆的已故祖父的家。双亲因意外事故而丧生，变得无依无靠...\" &#125; ] &#125; title 是番剧的标题，cover 是封面图链接， des 是简介，上述字段均根据需要修改。 另外除了 watchedExtra 数组，还可以在后面添加新的数组，可用数组名如下: 可用数组名 含义 wantWatchExtra 想看 watchingExtra 在看 watchedExtra 看过 需要注意，在两个数组之间需要用 , 分隔。 七、进行个性化修改 参考Matrey 主题增加豆瓣书/影单 1、ejs 文件的创建在/themes/fluid/layout文件夹下面创建一个名为 bangumi.ejs 的文件，并将下面的内容复制进去： &lt;%- partial('_partial/post-cover') %> &lt;style> .bangumi-picture img &#123; width: 100%; &#125; &lt;/style> &lt;main class=\"content\"> &lt;div id=\"contact\" class=\"container chip-container\"> &lt;div class=\"card\"> &lt;div class=\"card-content\" style=\"padding: 30px\"> &lt;h1 style=\"margin: 10px 0 10px 0px;\">&lt;%= page.title %>&lt;/h1> &lt;%- page.content %> &lt;/div> &lt;/div> &lt;div class=\"card\"> &lt;div class=\"card-content\" style=\"text-align: center\"> &lt;h3 style=\"margin: 5px 0 5px 5px;\">如果你有好的内容推荐，欢迎在下面留言！&lt;/h3> &lt;/div> &lt;/div> &lt;div class=\"card\"> &lt;% if (theme.gitalk &amp;&amp; theme.gitalk.enable) &#123; %> &lt;%- partial('_partial/gitalk') %> &lt;% &#125; %> &lt;% if (theme.gitment.enable) &#123; %> &lt;%- partial('_partial/gitment') %> &lt;% &#125; %> &lt;% if (theme.disqus.enable) &#123; %> &lt;%- partial('_partial/disqus') %> &lt;% &#125; %> &lt;% if (theme.livere &amp;&amp; theme.livere.enable) &#123; %> &lt;%- partial('_partial/livere') %> &lt;% &#125; %> &lt;% if (theme.valine &amp;&amp; theme.valine.enable) &#123; %> &lt;%- partial('_partial/valine') %> &lt;% &#125; %> &lt;% if (theme.minivaline &amp;&amp; theme.minivaline.enable) &#123; %> &lt;%- partial('_partial/minivaline') %> &lt;% &#125; %> &lt;/div> &lt;/div> &lt;/main> 最后面的几个&lt;% if (*) &#123; %&gt; &lt;% * %&gt; &lt;% &#125; %&gt;模块，可以根据实际运用模块进行删改 2、插件 moudle 内容修改然后在博客站点目录下的 node_modules 文件夹下找到 hexo-bilibili-bangumi/lib，用文本编辑器打开文件夹。 下面两个 js 文件中的代码进行对应修改： hexo-bilibili-bangumi\\lib\\bangumi-generator.js hexo-bilibili-bangumi\\src\\lib\\bangumi-generator.js layout: ['page', 'bangumi'] 本来的代码是layout: [&#39;page&#39;, &#39;post&#39;]","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://codeanime.cc/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://codeanime.cc/tags/Hexo/"},{"name":"Fluid","slug":"Fluid","permalink":"https://codeanime.cc/tags/Fluid/"},{"name":"魔改","slug":"魔改","permalink":"https://codeanime.cc/tags/%E9%AD%94%E6%94%B9/"},{"name":"主题","slug":"主题","permalink":"https://codeanime.cc/tags/%E4%B8%BB%E9%A2%98/"}]},{"title":"Hexo 常用命令及备份指南","slug":"Hexo-常用命令及备份指南","date":"2021-08-29T07:48:18.000Z","updated":"2021-09-02T15:54:27.769Z","comments":true,"path":"Hexo-常用命令及备份指南.html","link":"","permalink":"https://codeanime.cc/Hexo-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%A4%87%E4%BB%BD%E6%8C%87%E5%8D%97.html","excerpt":"","text":"常用命令# Hexo的常见缩写 $ hexo n \"博客名称\" => hexo new \"博客名称\" #这两个都是创建新文章，前者是简写模式 $ hexo p => hexo publish $ hexo g => hexo generate #生成 $ hexo s => hexo server #启动服务预览 $ hexo d => hexo deploy #部署 $ hexo g -d #生成静态文件（gnerate），且文件生成后立即部署网站（deploy）； $ hexo version # 显示 Hexo 版本； $ npm list #查看插件； $ npm uninstall 3插件名称` 卸载插件； $ hexo clean #清除缓存文件 (`db.json`) 和已生成的静态文件 (`public`)；在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令 # Hexo 服务器的命令 $ hexo server #Hexo 会监视文件变动并自动更新，无须重启服务器。 $ hexo server -s #静态模式 $ hexo server -p 5000 #更改端口 $ hexo server -i 192.168.1.1 #自定义IP $ hexo clean #清除缓存，网页正常情况下可以忽略此条命令 $ hexo g #生成静态网页 $ hexo d #开始部署 # Hexo资料网站 https://hexo.io/zh-cn/ 备份博客使用 hexo-git-backup 插件进行备份操作。 安装插件如果 Hexo 版本是 3.x.x，则应按如下方式安装： $ npm install hexo-git-backup --saveCopy 插件升级如果使用 –save 安装，则在更新时必须先删除。 $ npm remove hexo-git-backup $ npm install hexo-git-backup --saveCopy 插件配置在博客目录根的 _config.yml 中增加相应配置。 backup: type: git theme: coney,landscape,xxx repository: github: git@github.com:xxx&#x2F;xxx.git,branchName gitcafe: git@github.com:xxx&#x2F;xxx.git,branchNameCopy 其中 branchName 为在 GitHub 中博客仓库中自行创建的分支名称。若需要备份主题则在 theme 处添加主题名称。 插件更多配置细则请参考官方文档。 插件使用hexo b 备份博客到 GitHub 上对应的 backup 分支。 建议每次发布博客 hexo d 的时候都同时 hexo b 对博客进行备份更新。 恢复博客安装 Hexo在新环境下根据 Hexo官方文档 安装配置好Hexo环境， 安装博客部署到 GitHub 所需要的插件： npm install --save hexo-deployer-gitCopy 覆盖本地文件从之前插件备份到 GitHub 分支中下载博客文件到本地，并覆盖本地博客文件。 此外，可以只下载其中的 config.yml，theme/，source/，scaffolds/，package.json，.gitignore 这六个文件覆盖。 此时运行如下三连进行测试博客是否迁移成功。 hexo clean hexo g hexo sCopy 如果成功接下来就是安装常用插件的任务了…. 后记 如果不想使用 hexo-git-backup 插件对博客进行备份，可参考此文：在Github上备份Hexo博客 。 在 hexo d 时若出现 fatal: &#39;github&#39; does not appear to be a git repository 的错误，请参考此 Issue 。 参考资料 Hexo官方文档 hexo-git-backup Hexo博客使用插件hexo-git-backup通过GitHub备份与恢复 在Github上备份Hexo博客 卸载 hexo 插件","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://codeanime.cc/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://codeanime.cc/tags/Hexo/"},{"name":"备份Hexo博客","slug":"备份Hexo博客","permalink":"https://codeanime.cc/tags/%E5%A4%87%E4%BB%BDHexo%E5%8D%9A%E5%AE%A2/"}]},{"title":"Hexo Fluid主题魔改","slug":"Hexo-Fluid主题魔改","date":"2021-08-29T07:32:35.000Z","updated":"2021-09-14T03:10:30.381Z","comments":true,"path":"Hexo-Fluid主题魔改.html","link":"","permalink":"https://codeanime.cc/Hexo-Fluid%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9.html","excerpt":"","text":"所谓魔改，就是与主题不同，一旦主题已经被采用或者被实现，则会被划掉，而且魔改初心是使用无侵入式的方式修改——即不修改源码，而是使用注入器的方式。这样的话主题升级比较容易！ 一、在任意hexo主题博客中添加github日历：在博客中添加github的commit的日历：二、背景固定三、自定义滚动条、首页图片动画、自动翻译标题至英文标题、Twikoo评论样式修改四、瞎折腾1，瞎折腾2，瞎折腾3，五、主题美化:头部上升的气泡、动态彩带、动态黑色线条、雪花飘落、樱花飘落、鼠标跟随小星星、页脚加入运行时间、大雪花飘落、鼠标点击出字、鼠标点击出小爱心、鼠标点击出爆炸效果、鼠标指针、滚动条颜色、头部打字机六、看板娘1,看板娘2,看板娘3,看板娘自定义提示文本七、一言八、添加网站运行时间与版权声明优化、添加排序、加密、标题翻译、站点地图等插件九、版权声明、tag、页脚优化十、自定义字体、关于页添加评论、评论样式十一、浏览器网页标题恶搞","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://codeanime.cc/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://codeanime.cc/tags/Hexo/"},{"name":"Fluid","slug":"Fluid","permalink":"https://codeanime.cc/tags/Fluid/"},{"name":"魔改","slug":"魔改","permalink":"https://codeanime.cc/tags/%E9%AD%94%E6%94%B9/"}]},{"title":"给Hexo + Github pages搭建的个人博客绑定域名","slug":"给Hexo-Github-pages搭建的个人博客绑定域名","date":"2021-08-28T13:09:59.000Z","updated":"2021-09-02T15:53:43.484Z","comments":true,"path":"给Hexo-Github-pages搭建的个人博客绑定域名.html","link":"","permalink":"https://codeanime.cc/%E7%BB%99Hexo-Github-pages%E6%90%AD%E5%BB%BA%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D.html","excerpt":"","text":"给Hexo + Github pages搭建的个人博客绑定域名前段时间使用Hexo给自己搭了一个博客，托管在Github上面。不过托管在Github上的博客对外暴露的是github.io的子域名，那么既然是个人博客，当然要上自己的域名啦！话不多少，开始折腾吧！ 一、购买域名选择域名也是一个技术活，建议大家在下单购买自己中意的域名之前，先去检查一下这个域名之前有没有被人使用过，以及这个域名是否被各个搜索引擎ban掉了，这里的门道比较多，我刚刚开始接触，也是在网上搜资料看的，这里就不多说了，建议大家直接搜资料看看 ; ) 我这里是在腾讯云上购买的域名，进入腾讯云的域名注册服务，可以选一个中意的域名，先搜一下看看哪些后缀的域名还没有被占用。 例如搜索”codeanime”域名,哪个能买就买哪个 注意： 在国内购买域名需要实名认证才能使用 二、配置域名解析记录买到的域名要腾讯云审核好后才能使用，审核好后需要解析一下才能指向我们的Github pages地址。从腾讯云域名注册界面找到刚刚购买的域名，点击右边的“解析”，进入配置页。 这里可以选择快速添加解析： 1、点击快速添加解析 2、选择网站解析 3、选择域名映射（CANME） 4、填写你github仓库的域名，确定 三、配置CNAME文件DNS配置生效后，新购买的域名就已经指向Github pages页面地址了。但此时如果去访问这个域名的话，得到的是Github的404返回页，这是因为我们还没有在Github pages中配置域名。我们还需要在工程的根目录下放置一份CNAME文件指向我们的域名。这里说的“根目录”是指的托管在Github pages上的静态页面工程的根目录，而对于hexo源工程而言，CNAME文件应该放在source/目录下，文件内容就是我们的域名，操作如下： 找到你的hexo博客目录，进入source文件夹，创建一个”CNAME”文件（没有后缀名的） 打开CNAME文件，内容就填写你的域名 四、最后到你 code-anime.github.io 的Settings里，填上你的域名 然后执行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 完成构建和部署就行了。","categories":[{"name":"生命不息折腾不止！","slug":"生命不息折腾不止！","permalink":"https://codeanime.cc/categories/%E7%94%9F%E5%91%BD%E4%B8%8D%E6%81%AF%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2%EF%BC%81/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://codeanime.cc/tags/Hexo/"},{"name":"生命不息折腾不止！","slug":"生命不息折腾不止！","permalink":"https://codeanime.cc/tags/%E7%94%9F%E5%91%BD%E4%B8%8D%E6%81%AF%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2%EF%BC%81/"},{"name":"github","slug":"github","permalink":"https://codeanime.cc/tags/github/"},{"name":"域名","slug":"域名","permalink":"https://codeanime.cc/tags/%E5%9F%9F%E5%90%8D/"}]},{"title":"《樱花庄的宠物女孩》人物简介","slug":"《樱花庄的宠物女孩》人物简介","date":"2021-08-20T15:44:28.000Z","updated":"2021-08-20T16:05:40.781Z","comments":true,"path":"《樱花庄的宠物女孩》人物简介.html","link":"","permalink":"https://codeanime.cc/%E3%80%8A%E6%A8%B1%E8%8A%B1%E5%BA%84%E7%9A%84%E5%AE%A0%E7%89%A9%E5%A5%B3%E5%AD%A9%E3%80%8B%E4%BA%BA%E7%89%A9%E7%AE%80%E4%BB%8B.html","excerpt":"","text":"《樱花庄的宠物女孩》是鸭志田一著作、沟口凯吉负责插画、电击文库所属的轻小说，全13卷（本篇10卷+短篇3卷）。小说亦改编成同名动画、漫画以及游戏。 繁体中文版由台湾角川发行，简体中文版由天闻角川发行，并授权腾讯动漫在其平台上发布电子版。 [1] 小说曾获“这本轻小说真厉害！2011年第16名的成绩。 [2] 中文名 樱花庄的宠物女孩 原版名称 さくら荘のペットな彼女 作 者 鸭志田一 作品背景编辑 语音 作者鸭志田一在后记中提到，故事的发想在很久以前就大致想到，并列入“总有一天想写的故事清单”当中。 [3] 至于标题的“樱花庄”，只是因为中意它听起来顺耳又有亲切感才取的名称。但由于这不是太罕见的名字，所以作者上网随意搜寻了一下，发现它似乎实际存在于日本全国各地许多地方，但其实并没有以哪里的樱花庄作为题材。 [4] 故事内容编辑 语音 小说主要讲述了就读水明艺术大学附属高中的神田空太，一年级的夏天时在宿舍中养猫，而被校长叫去问话，校长让他在丢掉猫与从此搬到”樱花庄”中作选择。身为爱猫一族的空太，暂时选择了流落到因聚集各种怪人而恶名昭著的“樱花庄”。 隔年春天，随着世界级天才画家椎名真白搬进了樱花庄，神田空太开始过起被这名缺乏常识的少女耍得团团转的日子。 [5] 登场角色编辑 语音 樱花庄 **神田空太**就读水明艺术大学附属高中普通科二年级，因在一般宿舍养猫而被流放到樱花庄，成为樱花庄的101号房客。感受到了自己的才能和真白的差距之后奋力追赶，目标是成为游戏制作人。三鹰仁评价空太具有不可思议的力量能把樱花庄的人凝聚在一起。 **椎名真白**从英国转学到水明艺术大学附属高中美术科二年级。个性温和，天然呆、三无，有极度地依赖性。完全没有一点自理能力，甚至连换洗衣物也是空太帮忙选，喜爱吃年轮蛋糕，拥有与常人迥异的思维回路，因为出生于艺术世家，从小便开始学习画画，对外界的反应迟钝，不会笑，缺乏生活常识，被空太评价为“活在绘画的世界里”。 **青山七海**空太的同班同学。原本住在大阪，因此操有一口关西腔，为了能够当上声优而努力改掉，但是激动的时候还是会下意识的用关西腔。在学校保持着优等生的姿态，非常真实，平易近人，有点羞涩、傲娇，平凡而可爱。似乎很喜欢老虎，有一个具有搭话功能的很可爱的老虎抱枕“虎次郎”，其他很多东西也是老虎。喜欢空太，但是不敢坦率地表达出来。梦想是声优。 **上井草美咲**就读于水明艺术大学附属高中美术科三年级，上井草风香的妹妹。美术技巧高超，喜欢制作动画，独自制作了多部动画。属性为“外星人”，行为举止怪异，永远充满激情，充满活力，常令神田空太和三鹰仁非常烦恼。 **三鹰仁**在樱花庄中的别称为“夜之帝王”，源自于其女性关系的混乱、其帅气的外貌、花花公子的性格跟夜夜笙歌的能力，被空太称做“走在路上就可以让女性怀孕”，但他本人宣称都有做避孕措施。同时和六个已经工作的成年女性交往，按星期几来安排晚上去谁家过夜。 **赤坂龙之介有着女性面貌的少年。程式设计师。是个茧居族，整天龟在宿舍房间里，用电脑和樱花庄房客连络。在业界很有名气，编写的程序受到普遍的好评。讨厌异性，不能有任何身体接触，被丽塔吻过之后出现昏厥。小女仆**由龙之介独立开发的程式，非常人性化。主要工作是当龙之介忙碌时，代替龙之介联络樱花庄其他房客之用，研发者有提到目前正在研发如何让女仆得以实体化。女仆的衣服以及动作由美咲设计制作。对龙之介抱有好意的样子，对丽塔抱有敌意。 赤坂龙之介（左）、女仆（右） **千石千寻**水明艺术大学附属高中的美术教师樱花庄的管理员，住在管理员室椎名真白的表姐，做出决定把椎名真白交给了空太的罪魁祸首。自称“永远的二十九岁”。小说第一卷登场时为二十九岁又十五个月，第七卷时为二十九岁又三十个月，三围参数不详。学生时代梦想是成为画家，在被和希表白时被和希说喜欢千寻的画，但是大学毕业之后放弃作画而回到母校做美术老师。 **丽塔·爱因兹渥司**真白过去在英国的室友。与空太和真白等人同年，但外表和言行看起来比他们更为成熟。身材上前凸后翘，比真白和七海的身材还要好。因真白的能力太过耀眼而放弃绘画，不过在来到樱花庄之后重拾画笔，喵波隆的制作功不可没。见过龙之介之后对龙之介产生兴趣并且对龙之介展开攻势。 **姬宫伊织**在仁与美咲毕业后、空太等人升上三年级后，入学水明艺术大学附属高中音乐科一年级，姫宫沙织的亲弟弟。7卷登场。本人是个散发青春气息的男高中生，也有着一般男生会有的好色一面，喜欢女孩子前凸后翘，梦想希望自己未来的女朋友是个身材火辣的美少女，有着自己能像恋爱模拟游戏中般梦幻的邂逅场景再现，之后跟心仪的女孩子顺利恋爱的妄想。喜欢长谷栞奈，并毫不掩饰这份感情，向栞奈表白并遭到拒绝，但一直没有放弃。 **长谷栞奈**在仁与美咲毕业后、空太等人升上三年级后，入学水明艺术大学附属高中普通科一年级，曾和优子同宿舍。7卷登场。高中生作家，以自身家庭经历创作的小说颇得好评。曾经喜欢神田空太，但意识到自己已无法参与到七海和真白的竞争中而感到不甘心。也曾在自己写的小说里表达过这种感情。 [6] 水明艺术大学附属高中 **宫原大地**空太的邻座兼同班同学，空太少数朋友之一，游泳部部员。细长的肌肉，身高也比较高大。但是，实际上性格很孩子气。一直喜欢着七海，为了接近七海而努力获得了文化祭委员会职务，在文化祭后夜祭的时候向七海告白，但是却被拒。 高崎茧空太与七海的同班同学。与七海是朋友关系，身材娇小。对于七海与空太的关系一直非常支持。暗恋赤坂龙之介。 本庄弥生普通科2年级→3年级空太与七海的同班同学，身高175cm，垒球部所属。一直支持空太和七海的关系。在和学校里的某个老师交往。 **姬宫沙织**音乐科3年生→毕业（6卷）一直戴着耳机，耳机上写有“HAU-HAU”而被美咲和仁用「皓皓」来称呼，但本人似乎讨厌美咲以外的人用这种叫法，以至于以后没有再带过这只耳机。经常担任美咲制作的动画音乐的制作。在2年级的时候与前学生会长馆林总一郎交往中，毕业要去奥地利留学，因为舍不得总一郎而犹豫不决，在和仁在天台偶遇并谈话之后下定决心去奥地利。弟弟姫宫伊织第二年入学水明艺术大学付属高校。弟弟伊织所戴含有“HAU-HAU”的耳机是沙织所用过的。 **馆林总一郎**前学生会会长。和仁连续三年同班。在1年级的文化祭上，看了沙织钢琴演奏的表演，并对沙织一见钟情，却在一年半后才告白，与姫宫沙织在交往中。虽然笨手笨脚，但是很认真，个性很正经；和性格潇洒、才华洋溢，信手拈来即成艺的三鹰仁形成鲜明的对比。曾在学园祭上和空太吵了一架，因此两人存在芥蒂，但后来进了大学部后对空太的厌恶度大为降低。 **深谷志穗**真白的朋友兼同班同学。虽然觉得才能上自己比不过真白，但是有自己的道路要走，提前领悟到这个觉悟。发型是辫子，性格比较亲切，也是班上内少数敢亲近真白的同学。 **白山小春**在水明高中担任现代国文老师，与千寻同年龄，与千寻是同届同学兼校友，跟千寻一样想把自己嫁出去。对于和希对千寻的感情也知情。学生时代时喜欢和希。 其他角色 **上井草风香**大学生。美咲的亲姐姐，仁的前女友。知道仁最爱的是自己的妹妹美咲。当得知仁要和美咲一起报水高时，再也无法忍受时，和仁摊牌分手。与美咲有相似的容貌，但是与妹妹有相反的性格。 **神田优子**空太的妹妹，兄控。小时候因身体不好经常被哥哥照料，所以养成了极度兄控的性格，导致一步也不想离开哥哥，每次出现于空太面前时都会撒娇。视真白为情敌（真白也把优子当作情敌）。 空太之父名字不详。是空太的父亲，很溺爱女儿优子。借助酒劲才有勇气和儿子交谈。 **神田明子**空太的母亲，脸上总是带着温柔的微笑，空太说“没有见过可怕的神色”，但是，那是不能表现出自己的感情，所以经常笑着的可能性很高。发型是娃娃头。虽然真白在空太家里的发言依旧少根筋，得让空太正坐三小时面对母亲解释真白的缘由，但也表达出明理的一面，使得寒假期间空太家没有因为真白而天翻地覆。喜欢七海，并对空太说讨媳妇的话，妈妈喜欢七海哟。 **饭田绫乃**真白的漫画编辑，丽塔的朋友，教真白漫画过激描写的人。在家庭餐厅里，喜欢点上一堆餐点，并且喜好嘴里同时有咸味跟甜味的感觉，反映在性格上的浪漫喜好。 **藤泽和希**在“来做游戏吧”的商业游戏企画中，担任评审之一，高中时期就读水明，也是水高的校友。学生时代就喜欢千寻，最后表白失败。当年的梦想是成为游戏制作人，并且实现了梦想。这也是千寻不敢见面的原因，当年和千寻虽然目标不同却相互刺激，朝梦想迈进，和希实现了梦想而千寻放弃了梦想当了美术老师。 [6] 用语解说编辑 语音 原话(8张)水明艺术大学附属高中（水明芸术大学附属高等学校（すいめいげいじゅつだいがくふぞくこうとうがっこう）） 简称“水高”。分为普通以及艺术两种学科。艺术学科下分美术科以及音乐科。空太、七海、龙之介与仁（於第六集毕业前）是就读普通科，真白、美咲则是就读美术科。虽然艺术学科的单学年总人数仅有20人，但由於菁英化的培养制度，而吸引全国各地的学生报考。 水明艺术大学（水明芸术大学（すいめいげいじゅつだいがく）） 艺术相关的学院，在水高的旁边。一般水高毕业直升。 樱花庄议事录（さくら荘议事録） 记录樱花庄的各种事件的决议，通过网络聊天室确定和记录。 [7] **樱花庄**（さくら荘（さくらそう）） 樱花庄是一栋两层的木结构的旧公寓，因院子里的大樱花树而得名樱花庄。但是因为美咲的缘故还种有竹子，原作中并没有给出樱花庄的具体地址，只知道在水明艺术大学附属高等学校的附近（而不是在校内），但动画版第7集末尾在上井草美咲的驾照上出现了樱花庄地址及全称：东京都水明市水明樱花庄台3-10-11 水明艺术大学附属高等学校学生宿舍樱花庄（东京都水明市水明さくら台3-10-11 水明芸术大学付属高等学校学生寮さくら荘。）。 从樱花庄到学校或最近的车站都是步行十分钟的路程。樱花庄的楼房耐震程度堪忧，还曾被提出过拆掉。而且这栋公寓是没有寮母（管杂务的舍管阿姨）的，所以什麼事都得房客自己搞定。厨房、澡堂都是公用的。樱花庄虽然也算是一栋学生宿舍，但这里住的都是因为在普通学生宿舍闹出状况而被赶出来的问题儿童，因此被称为“问题儿童的老巢”（问题児の巣窟）。担任管理员（正式名称：监视要员）的是真白的表姐、美术老师千石千寻。樱花庄在学校内的知名度颇高。因此，只要有任何人住进来过，马上就会成为校内的知名人物。在其他学生间谣传著靠近住在樱花庄的学生就会得到“樱花庄菌”的谣言。男主角神田空太因在学生宿舍养猫而被轰出了普通宿舍，搬到了“恶名昭著”的樱花庄居住。但其实樱花庄原本是为了让水明附中的学生进行拓展美术、音乐等才能的自由活动而设立的，现在变味儿了。 第六卷中面临要被拆除的危机，实则是水高理事会为了不让真白的才能浪费而想出的权宜之计。在樱花庄全体收集全校学生联署的同时，仁和美咲策划了利用毕业典礼的行动，最终用真情打动了全体学生从而化解了危机。在仁和美咲毕业之后，决定顺势继续利用樱花庄的理事会又将姬宫伊织和长谷刊奈安排住入樱花庄，使得樱花庄再度满员。 千寻究竟在樱花庄住了多久目前没有确定的说法，但在原作官方由作者每周更新的《樱花庄议事录》（さくら荘议事录）中，有一次千寻向空太提到自己在樱花庄已经住了超过十年了。 樱花庄住的房客分布如下： 2F 201：上井草美咲（零年春）长谷栞奈（三年春） 202：椎名真白（二年春） 203：青山七海（二年夏） 房间未知：神田优子（四年） 1F 101：神田空太（一年夏） 102：赤坂龙之介（一年春） 103：三鹰仁（零年春）姬宫伊织（三年春） 管理员室：千石千寻 注：括号内为入住年份，本表格设定以神田空太入住之年为樱花庄第1年 房客分布","categories":[{"name":"动漫","slug":"动漫","permalink":"https://codeanime.cc/categories/%E5%8A%A8%E6%BC%AB/"}],"tags":[{"name":"动漫","slug":"动漫","permalink":"https://codeanime.cc/tags/%E5%8A%A8%E6%BC%AB/"},{"name":"感动","slug":"感动","permalink":"https://codeanime.cc/tags/%E6%84%9F%E5%8A%A8/"},{"name":"观后感","slug":"观后感","permalink":"https://codeanime.cc/tags/%E8%A7%82%E5%90%8E%E6%84%9F/"}]},{"title":"关于《我的青春恋爱物语果然有问题。》所说的真物究竟是什么","slug":"关于《我的青春恋爱物语果然有问题。》所说的真物究竟是什么","date":"2021-08-16T08:33:23.000Z","updated":"2021-09-02T15:50:14.369Z","comments":true,"path":"关于《我的青春恋爱物语果然有问题。》所说的真物究竟是什么.html","link":"","permalink":"https://codeanime.cc/%E5%85%B3%E4%BA%8E%E3%80%8A%E6%88%91%E7%9A%84%E9%9D%92%E6%98%A5%E6%81%8B%E7%88%B1%E7%89%A9%E8%AF%AD%E6%9E%9C%E7%84%B6%E6%9C%89%E9%97%AE%E9%A2%98%E3%80%82%E3%80%8B%E6%89%80%E8%AF%B4%E7%9A%84%E7%9C%9F%E7%89%A9%E7%A9%B6%E7%AB%9F%E6%98%AF%E4%BB%80%E4%B9%88.html","excerpt":"","text":"关于《我的青春恋爱物语果然有问题。》所说的真物究竟是什么一部动漫，一首音乐，一个角色，一种人生。 着重和大家聊聊《我的青春恋爱物语果然有问题。完》第十一集、第十二集，大老师口中的真物究竟是什么。他比企谷八幡的青春恋爱物语究竟有个毛的问题。 首先是故事开场，大老师第一句经典语录：青春是一场谎言，是一种罪恶，歌颂青春者往往欺骗自己与周遭的人，正面看待自身所处环境的一切，就算犯下什么滔天大错，他们也视为青春的象征，刻画为记忆中的一页，所以结论就是–爆炸吧，现充（指在现实世界中生活得充实的人们，全称是“现实生活很充实的人生赢家”）。 有人说是京阿尼给残酷的青春上了一层浪漫的滤镜，是大老师口中所谓青春是一种谎言，是一种罪恶，所有人都在讴歌青春积极地肯定自己周围的一切，为失败寻找接口，可是他本人也不得不承认那口中所言的真物，就藏在这所谓的”失败”的青春中。 实际上当我们回头再去看梦开始的地方，发现从一开始大老师就已经明确的告诉了观众，他自己就是现充，因为他一直在爆炸啊。这里，我们先来探讨一个一直以来春物的一个最大的争论点，那就是比企谷八幡这个人本身，有人冠名为：孤独哲学家、世界第一妹控、日本最后的忍者、单人棒球爱好者、黑暗骑士、彩加小天使共浴狂热分子、黑色蕾丝仰视者、粉红胖次见证者，比企谷正道之光八幡。最早，是有不少小鬼将大老师奉做行为的指引，为自己的孤僻找一个合理的借口，学来的大老师的吐槽力却学不来吐槽水平，学来了如何远离人群却学不来如何与自己达成和解，学来了雪乃与团子如何心疼大老师，却学不来大老师那份自爆的勇气，看到了大老师眼中的虚假，却看不到大老师眼中的真物。就算你生活中有雪乃，你也肯定没有平冢静那么可爱的老师。 在这段青春的伊始，作者为这个小小的侍奉部安排了几个性格鲜明，在现实中都能够代表相当一类人的几个角色。外向孤独的团子，理性压过感性的雪乃，以及高情商自闭天才比企谷八幡，从一开始，侍奉部的存在就是为了帮助别人去解决一些棘手的人际关系，一些只属于这个年纪的懵懂与纠结，其实在每个人的初高中时代，你都或多或少地做过类似的事，只是你自己不一定有这个自觉，比如帮助朋友追对象，安慰被甩的朋友，帮同学融入集体，甚至是帮助ta解决学习上的瓶颈问题等等，当你考虑过自己帮助别人的行为是为了满足自己还是真的在帮助别人的时候，此时的你的这份纠结，其实就属于侍奉部的业务范畴了，当然除此之外还有很多，我想每一个能在春物的小故事中找到共鸣的观众多少都有过类似的经历或者思考，至少我自己是曾经付出过行动，但最后以失败告终，所以当我们想去考虑何为真物的时候首先大家需要搞明白的是，什么，是伪物？ 是留美所处的小集体中各个孩子之间看似和谐的友情 是叶山小团体中没有了叶山就不在融洽的三个人 是海老名与阿部所继续维系的可能性 是建立在雪乃知道比企谷八幡这个人前提下的初见 是平冢静老师与比企谷八幡之间未曾打破的那个界限 是为了弟弟偷偷外出打工的川崎沙希 是不停发卡但是台词语气却不停变化的一色 是大老师、雪乃、结衣三个人之间在彼此发现对方的心意之后，继续维系的社团关系 总结下来就是指：建立在谎言之上的感情与关系，在这点上大老师与雪乃从一开始就有着这样的共识–此为伪物 对于团子从一开始其实就是很常规的展开，观众在最初也有着不少这样的看法，团子对大老师的靠近最初是以感激之情为基础的，所以在最后，静似乎是给了这个角度上的真物满分的回答：如果对一个女生产生共鸣、熟稔、怜悯、尊敬、嫉妒以及在这些之上的感情，那肯定不只是喜欢，所以，无法分开、离别，即使隔着一段距离依然会随着时间相互吸引，那或许就能称为真物。 于是一切似乎都得到了解释，但是我总有一个疙瘩在心中未曾解开，尤其是在最后团子的回归，新的侍奉部任务又再次出现的时候，有那么一瞬间我真以为团子被小恶魔忽悠，那么其实也就是这么一个问题，阳乃口中所谓的共依存，或者换句话说，难道你们就没有这种异议？团子为了维系三人之间的友情所做出的努力，难道就被认为是伪物了吗？知道作为一个普通的观众的我从未对此承认过。于是我去翻开春物前面的故事，同样的，假如川崎沙希的故事未被发现，弟弟顺利且幸福地升学，那么川崎沙希同学是否还算得上伪物，假如那帮小屁孩没有这波人性的考验，大家快乐的相处一直到长大，那么这份友情是否还算得上伪物…… 于是在留美的这段大老师的话似乎找到了答案：要靠把某人踩在脚底下才能其乐融融的关系，哪可能是真正的友情，但是，如果明知道那是虚假的，却还是愿意伸出援手的话，那一定就是真正的友情了。最终阐述的依旧是那个观点：那就是看清生活的真相后依旧继续热爱生活。那么从大的人际关系的角度，这个，也就是真物了吧。 从《我的青春恋爱物语果然有问题。完》第十一集最后大老师对雪乃的告白中：虽然大概不够作为扭曲你人生的代价，我把我的一切都交给你，不需要的话随时扔掉就行，若嫌麻烦也大可忘掉，这完全是我的自作主张，所以你不必答复，我几乎没有财产，能给的只有时间、感情、将来、人生，这些不切合实际的东西。终于在下一秒，我找到了对真物，最后的解释。你会发现即使到最后，大老师的告白是最后这几句依然具有非常强的单向性，所以是否可以认为，对于青春，对于这段青春恋爱物语，本就不存在真物，或者说，所有的一切都是伪物。就像这份告白的前提，懵懂，不成熟刚刚破土而出的我们什么都没有，是跌到底的垃圾股，所拥有的只有未来，时间，感情，承诺这些伪物，对于团子来说，那份我全都要却又不可能的前提是，当有两个人真正成为了情侣，这份友情就不可能再继续下去。那么这个从一开始就固化的学生时代的人心中的观念，是不是也是所谓的伪物。 所以答案就是：所有可以被称为伪物的东西，是因为人毫无理由的相信并付出了行动，才变成了我们眼中的真物，留美明知这份友情是虚假的脆弱的，却依旧选择伸出援手，此时虚假的友情就成为了真物。叶山得知三人看似融洽的关系，核心其实是自己之后，选择让自己退出，此四人虚伪的友情就变成了真物。川崎沙希同学隐瞒自己为了弟弟，但弟弟为了姐姐去探寻真相，此时被谎言笼罩的亲情就变成了真物。 真物就是团子明知二人关系已定却依旧选择继续与他们做永远的朋友。 真物就是大老师在拒绝平冢静伸出的手之后却在下一秒又紧紧握住。 真物就是大老师明知道告白的所有前提都是伪物却依旧选择靠近。 真物就是雪乃明知所有的一切都是伪物却依旧选择将彼此的人生交付。 所以当这么一部携带着如此多的人的青春的一部作品完结，除了爷青结之外，我希望作为普通观众的每一个我们，得到的不是我的青春，没有恋爱，没有物语，只有问题这么个令人糟心的结论，或许此刻你已经离开学校，或许此刻你已经步入成年，或者你已经成家立业，或许你依旧孤身一人，首先，我们明知动画中的每一段故事，都是伪物。明知你看到的这一段青春恋爱物语都是伪物，可我们依旧选择相信，去相信在这一段段虚构的故事中的真情实感，去相信，即使我们的青春已逝，但我们的恋爱物语，永远都不会完结，或许在我们的人生中依旧会看到各种各样的伪物，充满着各种各样的问题，但我希望从此以后，我们依旧可以有着大老师那双洞察伪物的眼睛，也随时可以调侃爆炸吧，现充！但是一定要珍惜身边的小町，身边的材木座，身边的平冢静老师，身边最强的学妹，身边最可爱的团子，并且一定有一天，当你遇到了那个和自己有着同样的世界观，不可爱，有很麻烦，冰雪聪明，和自己一样自我封闭却渴望沟通的伪物，假如她试图依靠你，假如你有着让自己扭曲的人生进一步扭曲并干涉到她的想法，希望你能抓紧她的手。把所有能用上的伪物都用上，然后赌上自己的人生，假如这份勇气能够得到回应，假如能得到所有人的祝福，我想那就是属于每一个人自己的，独一无二的真物。","categories":[{"name":"动漫","slug":"动漫","permalink":"https://codeanime.cc/categories/%E5%8A%A8%E6%BC%AB/"}],"tags":[{"name":"动漫","slug":"动漫","permalink":"https://codeanime.cc/tags/%E5%8A%A8%E6%BC%AB/"},{"name":"漫评","slug":"漫评","permalink":"https://codeanime.cc/tags/%E6%BC%AB%E8%AF%84/"},{"name":"青春","slug":"青春","permalink":"https://codeanime.cc/tags/%E9%9D%92%E6%98%A5/"},{"name":"爷青结","slug":"爷青结","permalink":"https://codeanime.cc/tags/%E7%88%B7%E9%9D%92%E7%BB%93/"}]},{"title":"那些感动人的句子","slug":"那些感动人的句子","date":"2021-08-13T12:53:37.000Z","updated":"2021-08-20T16:29:11.871Z","comments":true,"path":"那些感动人的句子.html","link":"","permalink":"https://codeanime.cc/%E9%82%A3%E4%BA%9B%E6%84%9F%E5%8A%A8%E4%BA%BA%E7%9A%84%E5%8F%A5%E5%AD%90.html","excerpt":"","text":"那些感动人的句子：1、知道为什么注定不能在一起的两个人，还要安排他们相遇吗？因为上辈子欠的太多太多，这辈子注定是要还的。在这个世界上，所有的相遇，不是恩赐，就是劫。若无相欠，怎能相见。 2、一本书你重新读一遍，可能会有新的感悟，但不会有新的结局。 3、如果事与愿违，请相信另有安排。 4、我一直相信释迦摩尼说的一句话：无论你遇见谁，ta都是你生命中，该出现的人，绝非偶然，ta一定会教会你一些什么，所以我也始终相信，无论我走到哪里？那都是我该去的地方，经历该经历的事，遇见该遇见的人。 5、今生无悔遇真白，来世愿入樱花庄！","categories":[{"name":"随手","slug":"随手","permalink":"https://codeanime.cc/categories/%E9%9A%8F%E6%89%8B/"}],"tags":[{"name":"随手","slug":"随手","permalink":"https://codeanime.cc/tags/%E9%9A%8F%E6%89%8B/"},{"name":"一言","slug":"一言","permalink":"https://codeanime.cc/tags/%E4%B8%80%E8%A8%80/"},{"name":"句子","slug":"句子","permalink":"https://codeanime.cc/tags/%E5%8F%A5%E5%AD%90/"}]},{"title":"归并排序","slug":"归并排序","date":"2021-08-13T12:47:14.000Z","updated":"2021-09-02T15:52:41.886Z","comments":true,"path":"归并排序.html","link":"","permalink":"https://codeanime.cc/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html","excerpt":"","text":"归并排序：排序原理：1、尽可能的一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，知道拆分后的每个子组的元素个数是1为止。 2、将相邻的两个子组进行合并成一个有序的大组 3、不断重复步骤2，直到最终只有一个组为止 代码实现：package demo02.sort; //排序代码 public class Merge &#123; private static Comparable[] assist;//归并所需要的辅助数组 /* 对数组a中的元素进行排序 */ public static void sort(Comparable[] a) &#123; assist = new Comparable[a.length]; int lo = 0; int hi = a.length-1; sort(a, lo, hi); &#125; /* 对数组a中从lo到hi的元素进行排序 */ private static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) &#123; return; &#125; int mid = lo + (hi - lo) / 2; //对lo到mid之间的元素进行排序； sort(a, lo, mid); //对mid+1到hi之间的元素进行排序； sort(a, mid+1, hi); //对lo到mid这组数据和mid到hi这组数据进行归并 merge(a, lo, mid, hi); &#125; /* 对数组中，从lo到mid为一组，从mid+1到hi为一组，对这两组数据进行归并 */ private static void merge(Comparable[] a, int lo, int mid, int hi) &#123; //lo到mid这组数据和mid+1到hi这组数据归并到辅助数组assist对应的索引处 int i = lo;//定义一个指针，指向assist数组中开始填充数据的索引 int p1 = lo;//定义一个指针，指向第一组数据的第一个元素 int p2 = mid + 1;//定义一个指针，指向第二组数据的第一个元素 //比较左边小组和右边小组中的元素大小，哪个小，就把哪个数据填充到assist数组中 while (p1 &lt;= mid &amp;&amp; p2 &lt;= hi) &#123; if (less(a[p1], a[p2])) &#123; assist[i++] = a[p1++]; &#125; else &#123; assist[i++] = a[p2++]; &#125; &#125; //上面的循环结束后，如果退出循环的条件是p1&lt;=mid，则证明左边小组中的数据已经归并完毕，如果退出循环的条件是p2&lt;=hi,则证明右边小组的数据已经填充完毕； //所以需要把未填充完毕的数据继续填充到assist中,//下面两个循环，只会执行其中的一个 while(p1&lt;=mid)&#123; assist[i++]=a[p1++]; &#125; while(p2&lt;=hi)&#123; assist[i++]=a[p2++]; &#125; //到现在为止，assist数组中，从lo到hi的元素是有序的，再把数据拷贝到a数组中对应的索引处 for (int index=lo;index&lt;=hi;index++)&#123; a[index]=assist[index]; &#125; &#125; /* 比较v元素是否小于w元素 */ private static boolean less(Comparable v, Comparable w) &#123; return v.compareTo(w) &lt; 0; &#125; /* 数组元素i和j交换位置 */ private static void exch(Comparable[] a, int i, int j) &#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125; &#125; package demo02.test; import demo02.sort.Merge; import java.util.Arrays; public class TestMerge &#123; public static void main(String[] args) throws Exception &#123; Integer[] arr = &#123;8, 4, 5, 7, 1, 3, 6, 2&#125;; Merge.sort(arr); System.out.println(Arrays.toString(arr)); &#125; &#125; 运行结果： 归并排序时间复杂度分析：归并排序是分治思想的最典型的例子，上面的算法中，对a[lo…hi]进行排序，先将它分为a[lo…mid]和a[mid+1…hi]两部分，分别通过递归调用将他们单独排序，最后将有序的子数组归并为最终的排序结果。该递归的出口在于如果一个数组不能再被分为两个子数组，那么就会执行merge进行归并，在归并的时候判断元素的大小进行排序。 归并排序的时间复杂度为：log2(n)* 2^(log2(n))=log2(n)*n,根据大O推导法则，忽略底数，最终归并排序的时间复杂度为O(nlogn); 归并排序的缺点：需要申请额外的数组空间，导致空间复杂度提升，是典型的以空间换时间的操作。","categories":[{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://codeanime.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"归并排序","slug":"归并排序","permalink":"https://codeanime.cc/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"}]},{"title":"希尔排序","slug":"希尔排序","date":"2021-08-12T16:42:33.000Z","updated":"2021-09-02T15:53:13.577Z","comments":true,"path":"希尔排序.html","link":"","permalink":"https://codeanime.cc/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html","excerpt":"","text":"希尔排序排序原理： 1、选定一个增量h，按照增长量h作为数据分组的依据，对数据进行分组 2、对分好组的每一组数据完成插入排序 3、减小增长量，最小减为1，重复第二步操作 其中，希尔排序确定增长量h的规则： int h = 1; while(h&lt;数组长度/2)&#123; h = 2h+1; &#125; //循环结束后我们可以确定h的最大值; h的减小规则为: h = h/2; 代码实现： package demo02.sort; public class Shell &#123; /** * 对数组a中的元素进行排序 */ public static void sort(Comparable[] a)&#123; //1.根据数组a的长度，确定增长量h的初始值 int h = 1; while(h&lt;a.length/2)&#123; h = 2*h+1; &#125; //2、希尔排序 while(h>=1)&#123; //排序 //2.1找到待插入的元素 for (int i = h; i &lt; a.length; i++) &#123; //2.2把待插入的元素插入到有序数组中 for (int j = i; j >=h; j-=h) &#123; //待插入的元素是a[j],比较a[j]和a[j-h] if (greater(a[j-h],a[j]))&#123; exch(a,j-h,j); &#125;else &#123; break; &#125; &#125; &#125; //减小h的值 h = h/2; &#125; &#125; /** * 比较v元素是否大于w元素 */ private static boolean greater(Comparable v,Comparable w)&#123; return v.compareTo(w)>0; &#125; /** * 数组元素i和j交换位置 */ private static void exch(Comparable[] a,int i,int j)&#123; Comparable temp; temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; &#125; package demo02.test; import demo02.sort.Shell; import java.util.Arrays; public class TestShell &#123; public static void main(String[] args) &#123; Integer[] a = &#123;9,1,2,5,7,4,8,6,3,5&#125;; Shell.sort(a); System.out.println(Arrays.toString(a)); &#125; &#125; 运行结果：","categories":[{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/categories/Java/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://codeanime.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"java","slug":"java","permalink":"https://codeanime.cc/tags/java/"},{"name":"希尔排序","slug":"希尔排序","permalink":"https://codeanime.cc/tags/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"}]},{"title":"插入排序","slug":"插入排序","date":"2021-08-12T16:42:16.000Z","updated":"2021-09-02T15:48:25.097Z","comments":true,"path":"插入排序.html","link":"","permalink":"https://codeanime.cc/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html","excerpt":"","text":"插入排序：原理：1、把所有的元素分为两组，已经排序的和未排序的 2、找到未排序的组中的第一个元素，向已经排序的组中进行插入 3、倒叙遍历已经排序的元素，依次和待插叙的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待插入元素放到这个位置，其他的元素向后移动一位。 代码实现package demo02.sort; public class Insertion &#123; public static void sort(Comparable[] a)&#123; for (int i = 1; i &lt; a.length; i++) &#123; for (int j = i; j>0; j--) &#123; //比较索引j处的值和索引j-1处的值，如果j—1处的值大，则交换数据，否则，就找到了合适的位置 if (greater(a[j-1],a[j]))&#123; exch(a,j-1,j); &#125;else &#123; break; &#125; &#125; &#125; &#125; /** * 比较v元素是否大于w元素 */ private static boolean greater(Comparable v,Comparable w)&#123; return v.compareTo(w)>0; &#125; /** * 数组元素i和j交换位置 */ private static void exch(Comparable[] a,int i,int j)&#123; Comparable temp; temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; &#125; package demo02.test; import demo02.sort.Insertion; import java.util.Arrays; public class TestInsertion &#123; public static void main(String[] args) &#123; Integer[] a = &#123;4,3,2,10,12,1,5,6&#125;; Insertion.sort(a); System.out.println(Arrays.toString(a)); &#125; &#125; 运行结果： 插入排序时间复杂度分析：","categories":[{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/categories/Java/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://codeanime.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"java","slug":"java","permalink":"https://codeanime.cc/tags/java/"},{"name":"插入排序","slug":"插入排序","permalink":"https://codeanime.cc/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"}]},{"title":"用接口写冒泡排序","slug":"用接口写冒泡排序","date":"2021-08-11T13:09:56.000Z","updated":"2021-09-02T15:49:03.353Z","comments":true,"path":"用接口写冒泡排序.html","link":"","permalink":"https://codeanime.cc/%E7%94%A8%E6%8E%A5%E5%8F%A3%E5%86%99%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html","excerpt":"","text":"用接口写冒泡排序：package demo02.maopaoapi.Bubble; public class Bubble &#123; /** *对数组a中的元素进行排序 */ public static void sort(Comparable[] a)&#123; for (int i = a.length-1; i >0; i--) &#123; for (int j = 0; j &lt; i; j++) &#123; //比较索引j和索引j+1处的值 if (greater(a[j],a[j+1]))&#123; exch(a,j,j+1); &#125; &#125; &#125; &#125; /** * 比较v元素是否大于w元素 */ private static boolean greater(Comparable v,Comparable w)&#123; return v.compareTo(w)>0; &#125; /** * 数组元素i和j交换元素位置 */ private static void exch(Comparable[] a,int i,int j)&#123; Comparable temp; temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; &#125; package demo02.maopaoapi.TestBubble; import demo02.maopaoapi.Bubble.Bubble; import java.util.Arrays; public class TestBubble &#123; public static void main(String[] args) &#123; Integer[] arr = &#123;4,5,6,3,2,1&#125;; Bubble.sort(arr); System.out.println(Arrays.toString(arr)); &#125; &#125; 运行结果： 分析冒泡排序的性能：冒泡排序使用了双层for循环，其中内层循环的循环体是真正完成排序的代码，所以，分析冒泡排序的时间复杂度，主要分析一下内层循环的执行次数即可。","categories":[{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://codeanime.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"https://codeanime.cc/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"name":"接口","slug":"接口","permalink":"https://codeanime.cc/tags/%E6%8E%A5%E5%8F%A3/"}]},{"title":"选择排序","slug":"选择排序","date":"2021-08-11T13:06:21.000Z","updated":"2021-09-02T15:46:18.585Z","comments":true,"path":"选择排序.html","link":"","permalink":"https://codeanime.cc/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html","excerpt":"","text":"选择排序：合适的元素放在合适的位置1、每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果当前索引处的值大于其他某个索引处的值，则假定其他某个索引处的只为最小值，最后可以找到最小值所在的索引。 2、交换第一个索引处和最小值所在的索引处的值 选择排序api实验： package demo02.sort; public class Selection &#123; /** * 对数组a中的元素进行排序 */ public static void sort(Comparable[] a)&#123; for (int i = 0; i &lt; a.length-1; i++) &#123; //定义一个变量，记录最小元素所在的索引，默认为参与选择排序的第一个元素的位置 int minIndex = i; for (int j = i+1; j &lt; a.length; j++) &#123; if (greter(a[minIndex],a[j]))&#123; minIndex = j; &#125; &#125; //交换最小元素所在索引minIndex处的值和索引i处的值 exch(a,i,minIndex); &#125; &#125; /** * 比较v元素是否大于w元素 */ private static boolean greter(Comparable v,Comparable w)&#123; return v.compareTo(w)>0; &#125; /** * 数组元素i和j交换位置 */ private static void exch(Comparable[] a,int i,int j)&#123; Comparable temp; temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; &#125; package demo02.test; import demo02.sort.Selection; import java.util.Arrays; public class TestSelection &#123; public static void main(String[] args) &#123; //原始数据 Integer[] a = &#123;4,6,8,7,9,2,10,1&#125;; Selection.sort(a); System.out.println(Arrays.toString(a)); &#125; &#125; 运行结果： 选择排序时间复杂度分析：","categories":[{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://codeanime.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"接口","slug":"接口","permalink":"https://codeanime.cc/tags/%E6%8E%A5%E5%8F%A3/"},{"name":"选择排序","slug":"选择排序","permalink":"https://codeanime.cc/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"}]},{"title":"Comparable接口的使用","slug":"Comparable接口的使用","date":"2021-08-11T08:14:31.000Z","updated":"2021-09-02T15:52:07.986Z","comments":true,"path":"Comparable接口的使用.html","link":"","permalink":"https://codeanime.cc/Comparable%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8.html","excerpt":"","text":"Comparable接口的使用：（知识回顾）1、定义一个学生类，具有年龄age和姓名username两个属性，并通过Comparable接口提供比较规则。package demo02.sort; public class Student implements Comparable&lt;Student>&#123; private String username; private int age; public String getUsername() &#123; return username; &#125; public int getAge() &#123; return age; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"username='\" + username + '\\'' + \", age=\" + age + '&#125;'; &#125; @Override public int compareTo(Student o) &#123; return this.getAge()-o.getAge(); &#125; &#125; 2、定义测试类TestComparable，在测试类Test中定义测试方法Comparable getMax（comparable c1，comparable c2）完成测试package demo02.test; import demo02.sort.Student; public class TestComparable &#123; public static void main(String[] args) &#123; Student s1 = new Student(); s1.setUsername(\"张三\"); s1.setAge(18); Student s2 = new Student(); s2.setUsername(\"李四\"); s2.setAge(20); Comparable max = getMax(s1, s2); System.out.println(max); &#125; public static Comparable getMax(Comparable c1, Comparable c2) &#123; int result = c1.compareTo(c2); //如果result>0，则c1比c2大，如果result&lt;0，则c2比c1大如果result=0，则c1==c2大 if (result >= 0) &#123; return c1; &#125; else &#123; return c2; &#125; &#125; &#125; 运行结果：","categories":[{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/categories/Java/"}],"tags":[{"name":"Comparable接口","slug":"Comparable接口","permalink":"https://codeanime.cc/tags/Comparable%E6%8E%A5%E5%8F%A3/"},{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/tags/Java/"},{"name":"知识回顾","slug":"知识回顾","permalink":"https://codeanime.cc/tags/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"}]},{"title":"Fluid 页脚增加网站运行时长","slug":"Fluid-页脚增加网站运行时长","date":"2021-08-09T13:41:32.000Z","updated":"2021-08-09T13:44:52.118Z","comments":true,"path":"Fluid-页脚增加网站运行时长.html","link":"","permalink":"https://codeanime.cc/Fluid-%E9%A1%B5%E8%84%9A%E5%A2%9E%E5%8A%A0%E7%BD%91%E7%AB%99%E8%BF%90%E8%A1%8C%E6%97%B6%E9%95%BF.html","excerpt":"","text":"Fluid 1.8.4 版本支持自定义页脚内容了，群友常改的网站运行时长，这次无需再修改源代码。 只需要在主题配置中的 footer: content 添加： footer: content: &#39; &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;hexo.io&quot; target&#x3D;&quot;_blank&quot; rel&#x3D;&quot;nofollow noopener&quot;&gt;&lt;span&gt;Hexo&lt;&#x2F;span&gt;&lt;&#x2F;a&gt; &lt;i class&#x3D;&quot;iconfont icon-love&quot;&gt;&lt;&#x2F;i&gt; &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;github.com&#x2F;fluid-dev&#x2F;hexo-theme-fluid&quot; target&#x3D;&quot;_blank&quot; rel&#x3D;&quot;nofollow noopener&quot;&gt;&lt;span&gt;Fluid&lt;&#x2F;span&gt;&lt;&#x2F;a&gt; &lt;div style&#x3D;&quot;font-size: 0.85rem&quot;&gt; &lt;span id&#x3D;&quot;timeDate&quot;&gt;载入天数...&lt;&#x2F;span&gt; &lt;span id&#x3D;&quot;times&quot;&gt;载入时分秒...&lt;&#x2F;span&gt; &lt;script src&#x3D;&quot;&#x2F;js&#x2F;duration.js&quot;&gt;&lt;&#x2F;script&gt; &lt;&#x2F;div&gt; &#39; content 前三行是 Fluid 原有的页脚内容，建议不要删除，可稍作修改，保留 Fluid 的超链接，用于向更多人推广主题。 duration.js 包含的才是功能代码，我们在博客目录下创建 source/js/duration.js，内容如下： !(function() &#123; &#x2F;** 计时起始时间，自行修改 **&#x2F; var start &#x3D; new Date(&quot;2020&#x2F;01&#x2F;01 00:00:00&quot;); function update() &#123; var now &#x3D; new Date(); now.setTime(now.getTime()+250); days &#x3D; (now - start) &#x2F; 1000 &#x2F; 60 &#x2F; 60 &#x2F; 24; dnum &#x3D; Math.floor(days); hours &#x3D; (now - start) &#x2F; 1000 &#x2F; 60 &#x2F; 60 - (24 * dnum); hnum &#x3D; Math.floor(hours); if(String(hnum).length &#x3D;&#x3D;&#x3D; 1 )&#123; hnum &#x3D; &quot;0&quot; + hnum; &#125; minutes &#x3D; (now - start) &#x2F; 1000 &#x2F;60 - (24 * 60 * dnum) - (60 * hnum); mnum &#x3D; Math.floor(minutes); if(String(mnum).length &#x3D;&#x3D;&#x3D; 1 )&#123; mnum &#x3D; &quot;0&quot; + mnum; &#125; seconds &#x3D; (now - start) &#x2F; 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum &#x3D; Math.round(seconds); if(String(snum).length &#x3D;&#x3D;&#x3D; 1 )&#123; snum &#x3D; &quot;0&quot; + snum; &#125; document.getElementById(&quot;timeDate&quot;).innerHTML &#x3D; &quot;本站安全运行&amp;nbsp&quot;+dnum+&quot;&amp;nbsp天&quot;; document.getElementById(&quot;times&quot;).innerHTML &#x3D; hnum + &quot;&amp;nbsp小时&amp;nbsp&quot; + mnum + &quot;&amp;nbsp分&amp;nbsp&quot; + snum + &quot;&amp;nbsp秒&quot;; &#125; update(); setInterval(update, 1000); &#125;)(); 不要忘记把上面注释的时间改为自己的时间，至此这项功能就引入到 &lt;footer&gt; 里了。 原文链接：https://hexo.fluid-dev.com/posts/fluid-footer-custom/","categories":[{"name":"生命不息，折腾不止！","slug":"生命不息，折腾不止！","permalink":"https://codeanime.cc/categories/%E7%94%9F%E5%91%BD%E4%B8%8D%E6%81%AF%EF%BC%8C%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2%EF%BC%81/"}],"tags":[{"name":"生命不息，折腾不止！","slug":"生命不息，折腾不止！","permalink":"https://codeanime.cc/tags/%E7%94%9F%E5%91%BD%E4%B8%8D%E6%81%AF%EF%BC%8C%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2%EF%BC%81/"}]},{"title":"binary search（二分法）","slug":"binary-search（二分法）","date":"2021-08-09T13:05:06.000Z","updated":"2021-09-02T15:44:39.938Z","comments":true,"path":"binary-search（二分法）.html","link":"","permalink":"https://codeanime.cc/binary-search%EF%BC%88%E4%BA%8C%E5%88%86%E6%B3%95%EF%BC%89.html","excerpt":"","text":"binary search（二分法）：代码： import java.util.Arrays; /** * 二分法查找元素 */ public class BinarySearch &#123; public static void main(String[] args) &#123; int[] arr = &#123;30,20,50,10,80,9,7,12,100,40,8&#125;; int searchWord = 20;//要查找的值 System.out.println(searchWord+\"索引位置：\"+binarySearch(arr,searchWord)); &#125; /** * * @param array 目标数组 * @param value 所要查找的值 * @return 如果找到，则返回这个值在数组中的索引，如果未找到，则返回-1； */ public static int binarySearch(int[] array,int value)&#123; //二分法查找的数组，戏必须先排序 Arrays.sort(array); System.out.println(Arrays.toString(array)); int low = 0; int high = array.length-1; while(low&lt;=high)&#123; int middle = (low+high)/2; if (value==array[middle])&#123; return middle; &#125; if (value>array[middle])&#123; low = middle+1; &#125; if (value&lt;array[middle])&#123; high = middle-1; &#125; &#125; return -1;//未找到返回-1 &#125; &#125; 执行结果：","categories":[{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/tags/Java/"},{"name":"binary search","slug":"binary-search","permalink":"https://codeanime.cc/tags/binary-search/"},{"name":"二分法","slug":"二分法","permalink":"https://codeanime.cc/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"},{"name":"折半查找法","slug":"折半查找法","permalink":"https://codeanime.cc/tags/%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E6%B3%95/"}]},{"title":"稀疏数组的转换","slug":"稀疏数组的转换","date":"2021-08-09T11:55:54.000Z","updated":"2021-08-09T11:57:24.098Z","comments":true,"path":"稀疏数组的转换.html","link":"","permalink":"https://codeanime.cc/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2.html","excerpt":"","text":"二维数组转稀疏数组的思路： 1、遍历原始的二维数组，得到有效数据的个数sum 2、根据sum就可以创建稀疏数组sparseArr int[sum+1] [3] 3、将二维数组的有效数据存入到稀疏数组中 稀疏数组转原始的二维数组的思路 1、先读取稀疏数组的第一行，根据第一行的数据，常见原始的二维数组 2、在读取稀疏数组后几行的数据，并赋给原始的二维数组即可 代码实现：二维数组转换稀疏数组 public class SparseArray &#123; public static void main(String[] args) &#123; //创建一个原始的二维数组11*11 //0：表示没有棋子，1表示黑子，2表示蓝子 int chessArr1[][] = new int[11][11]; chessArr1[1][2] = 1; chessArr1[2][3] = 2; //输出原始的二维数组 System.out.println(\"原始的二维数组：\"); for (int[] row:chessArr1) &#123; for (int data:row) &#123; System.out.printf(\"%d\\t\",data); &#125; System.out.println(); &#125; //将二维数组转换稀疏数组 //1、先遍历二维数组得到非零数据的个数 int sum = 0; for (int i = 0; i &lt; chessArr1.length; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if (chessArr1[i][j]!=0)&#123; sum++; &#125; &#125; &#125; //2、创建对应的稀疏数组 int sparseArr[][] = new int[sum+1][3]; //给稀疏数组赋值 sparseArr[0][0] = 11; sparseArr[0][1] = 11; sparseArr[0][2] = sum; int count = 0; //遍历二维数组，将非零的值存放到sparseArr中 for (int i = 0; i &lt; chessArr1.length; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if (chessArr1[i][j]!=0)&#123; count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr1[i][j]; &#125; &#125; &#125; //输出稀疏数组的形式 System.out.println(); System.out.println(\"得到的稀疏数组为：\"); for (int i = 0; i &lt; sparseArr.length; i++) &#123; System.out.printf(\"%d\\t%d\\t%d\\t\\n\",sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]); &#125; System.out.println(); &#125; &#125; 代码实现稀疏数组转换原始二维数组 package demo01; public class SparseArray &#123; public static void main(String[] args) &#123; //创建一个原始的二维数组11*11 //0：表示没有棋子，1表示黑子，2表示蓝子 int chessArr1[][] = new int[11][11]; chessArr1[1][2] = 1; chessArr1[2][3] = 2; //输出原始的二维数组 System.out.println(\"原始的二维数组：\"); for (int[] row:chessArr1) &#123; for (int data:row) &#123; System.out.printf(\"%d\\t\",data); &#125; System.out.println(); &#125; //将二维数组转换稀疏数组 //1、先遍历二维数组得到非零数据的个数 int sum = 0; for (int i = 0; i &lt; chessArr1.length; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if (chessArr1[i][j]!=0)&#123; sum++; &#125; &#125; &#125; //2、创建对应的稀疏数组 int sparseArr[][] = new int[sum+1][3]; //给稀疏数组赋值 sparseArr[0][0] = 11; sparseArr[0][1] = 11; sparseArr[0][2] = sum; int count = 0; //遍历二维数组，将非零的值存放到sparseArr中 for (int i = 0; i &lt; chessArr1.length; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if (chessArr1[i][j]!=0)&#123; count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr1[i][j]; &#125; &#125; &#125; //输出稀疏数组的形式 System.out.println(); System.out.println(\"得到的稀疏数组为：\"); for (int i = 0; i &lt; sparseArr.length; i++) &#123; System.out.printf(\"%d\\t%d\\t%d\\t\\n\",sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]); &#125; System.out.println(); //将稀疏数组转换为原始二维数组 //1先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组 int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]]; //2、在读取稀疏数组后几行的数组，并赋给原始的二维数组即可 for (int i = 1; i &lt; sparseArr.length; i++) &#123; chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2]; &#125; //恢复后的二维数组 System.out.println(); System.out.println(\"恢复后的二维数组：\"); for (int[] row:chessArr2) &#123; for (int data:row) &#123; System.out.printf(\"%d\\t\",data); &#125; System.out.println(); &#125; &#125; &#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://codeanime.cc/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://codeanime.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"LeetCode-有效字符串判定","slug":"LeetCode-有效字符串判定","date":"2021-08-09T11:51:18.000Z","updated":"2021-08-09T11:54:40.518Z","comments":true,"path":"LeetCode-有效字符串判定.html","link":"","permalink":"https://codeanime.cc/LeetCode-%E6%9C%89%E6%95%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A4%E5%AE%9A.html","excerpt":"","text":"一、给定一个只有括号’(‘,’)’,’{‘,’}’,’[‘,’]’字符串，判断字符串是否有效。有效字符串需要满足： 1、左括号必须用相同的类型的右括号闭合。 2、左括号必须以正确的顺序闭合。 注意空字符串可被认为有效字符串。 实例1： 输入：”()” 输出：true 实例2： 输入： “()[]{}” 输出：true 二、 代码实现：import java.util.Stack; public class Solution &#123; public boolean isValid(String s) &#123; if (s.length() == 0) &#123; return true; &#125; Stack&lt;Character> stack = new Stack&lt;>(); for (char ch : s.toCharArray()) &#123; if (ch == '(' || ch == '&#123;' || ch == '[') &#123; stack.push(ch); &#125; else &#123; if (stack.isEmpty()) &#123; return false; &#125; else &#123; char temp = stack.pop(); if (ch == ')') &#123; if (temp != '(') &#123; return false; &#125; &#125;else if (ch == '&#125;') &#123; if (temp != '&#123;') &#123; return false; &#125; &#125; else if (ch == ']') &#123; if (temp != '[') &#123; return false; &#125; &#125; &#125; &#125; &#125; return stack.isEmpty() ? true : false; &#125; &#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://codeanime.cc/categories/LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://codeanime.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://codeanime.cc/tags/LeetCode/"}]},{"title":"Java冒泡排序","slug":"Java冒泡排序","date":"2021-08-08T10:25:00.000Z","updated":"2021-09-02T15:49:43.560Z","comments":true,"path":"Java冒泡排序.html","link":"","permalink":"https://codeanime.cc/Java%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html","excerpt":"","text":"1、冒泡排序import java.util.Arrays; /** * 冒泡排序 */ public class Test01 &#123; public static void main(String[] args) &#123; int[] values = &#123;3,1,6,2,9,0,7,4,8,5&#125;; System.out.println(\"排序前数组：\"+ Arrays.toString(values)); int temp; for (int i = 0; i &lt; values.length; i++) &#123; for (int j = 0; j &lt; values.length-i-1; j++) &#123; if (values[j]>values[j+1])&#123; temp = values[j]; values[j] = values[j+1]; values[j+1] = temp; &#125; &#125; System.out.println(\"第\"+(i+1)+\"趟，完成时\"+Arrays.toString(values)); &#125; &#125; &#125; 2、优化代码：从上图得知，第五趟排好后就可以直接输出了。所以对代码进行优化 import java.util.Arrays; /** * 冒泡排序 */ public class Test01 &#123; public static void main(String[] args) &#123; int[] values = &#123;3,1,6,2,9,0,7,4,8,5&#125;; System.out.println(\"排序前数组：\"+ Arrays.toString(values)); int temp; //用来交换的临时变量 //定义一个布尔类型的变量，标记数组是否已达到有序状态 boolean flag = true; for (int i = 0; i &lt; values.length; i++) &#123; for (int j = 0; j &lt; values.length-i-1; j++) &#123; if (values[j]>values[j+1])&#123; //两两比较，如果大于就交换 temp = values[j]; values[j] = values[j+1]; values[j+1] = temp; flag = false; &#125; &#125; if (flag)&#123; System.out.println(\"结束排序！\"); break; &#125;else &#123; flag = true; &#125; System.out.println(\"第\"+(i+1)+\"趟，完成时\"+Arrays.toString(values)); &#125; &#125; &#125; 3、把算法封装起来，以后用可以直接调用方法import java.util.Arrays; /** * 冒泡排序 */ public class Test01 &#123; public static void main(String[] args) &#123; int[] values = &#123;3,1,6,2,9,0,7,4,8,5&#125;; bubbleSort(values); &#125; public static void bubbleSort(int[] values)&#123; //int[] values = &#123;3,1,6,2,9,0,7,4,8,5&#125;; System.out.println(\"排序前数组：\"+ Arrays.toString(values)); int temp; //用来交换的临时变量 //定义一个布尔类型的变量，标记数组是否已达到有序状态 boolean flag = true; for (int i = 0; i &lt; values.length; i++) &#123; for (int j = 0; j &lt; values.length-i-1; j++) &#123; if (values[j]>values[j+1])&#123; //两两比较，如果大于就交换 temp = values[j]; values[j] = values[j+1]; values[j+1] = temp; flag = false; &#125; &#125; if (flag)&#123; System.out.println(\"结束排序！\"); break; &#125;else &#123; flag = true; &#125; System.out.println(\"第\"+(i+1)+\"趟，完成时\"+Arrays.toString(values)); &#125; &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://codeanime.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"https://codeanime.cc/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"}]},{"title":"LeetCode---两数相加2","slug":"LeetCode-两数相加2","date":"2021-08-08T08:49:57.000Z","updated":"2021-08-08T09:03:37.900Z","comments":true,"path":"LeetCode-两数相加2.html","link":"","permalink":"https://codeanime.cc/LeetCode-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A02.html","excerpt":"","text":"LeetCode—两数相加2给你两个非空的链表，表示两个非负的整数。他们每位数字都是按照逆序的方式存储的，，并且每个节点只能存储一位数字。 请你将两数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字0之外，这两个数都不会以0开头 例如： 输入：2–4–3 ​ 5–6–4 输出：7–0–8 解法： 1、迭代法class Solution &#123; // Iteration // N is the size of l1, M is the size of l2 // Time Complexity: O(max(M,N)) // Space Complexity: O(max(M,N)) if dummy is counted else O(1) public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int next1 = 0; int total = 0; ListNode dummy = new ListNode(); ListNode cur = dummy; while (l1 != null &amp;&amp; l2 != null) &#123; total = l1.val + l2.val + next1; cur.next = new ListNode(total % 10); next1 = total / 10; l1 = l1.next; l2 = l2.next; cur = cur.next; &#125; while (l1 != null) &#123; total = l1.val + next1; cur.next = new ListNode(total % 10); next1 = total / 10; l1 = l1.next; cur = cur.next; &#125; while (l2 != null) &#123; total = l2.val + next1; cur.next = new ListNode(total % 10); next1 = total / 10; l2 = l2.next; cur = cur.next; &#125; if (next1 != 0) &#123; cur.next = new ListNode(next1); &#125; return dummy.next; &#125; &#125; 2、递归法class Solution &#123; // Recursion // N is the size of l1, M is the size of l2 // Time Complexity: O(max(M,N)) // Space Complexity: O(max(M,N)) if dummy is counted else O(1) public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int total = l1.val + l2.val; int next1 = total / 10; ListNode res = new ListNode(total%10); if (l1.next != null || l2.next != null || next1 != 0) &#123; l1 = l1.next!=null ? l1.next : new ListNode(0); l2 = l2.next!=null ? l2.next : new ListNode(0); l1.val += next1; res.next = addTwoNumbers(l1, l2); &#125; return res; &#125; &#125; 另外写一下递归与迭代的区别：递归和迭代都是循环中的一种。 简单地说，递归是重复调用函数自身实现循环。迭代是函数内某段代码实现循环，而迭代与普通循环的区别是：循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。 递归循环中，遇到满足终止条件的情况时逐层返回来结束。迭代则使用计数器结束循环。当然很多情况都是多种循环混合采用，这要根据具体需求。 使用递归要注意的有两点: 1)递归就是在过程或函数里面调用自身;2)在使用递归时,必须有一个明确的递归结束条件,称为递归出口. 递归分为两个阶段: 1)递推:把复杂的问题的求解推到比原问题简单一些的问题的求解;2)回归:当获得最简单的情况后,逐步返回,依次得到复杂的解. 递归和迭代的空间利用率 迭代是逐渐逼近，用新值覆盖旧值，直到满足条件后结束，不保存中间值，空间利用率高。递归是将一个问题分解为若干相对小一点的问题，遇到递归出口再原路返回，因此必须保存相关的中间值，这些中间值压入栈保存，问题规模较大时会占用大量内存。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://codeanime.cc/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://codeanime.cc/tags/LeetCode/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://codeanime.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"Leetcode---两数之和1","slug":"Leetcode-两数之和1","date":"2021-08-08T07:08:30.000Z","updated":"2021-08-08T08:51:23.961Z","comments":true,"path":"Leetcode-两数之和1.html","link":"","permalink":"https://codeanime.cc/Leetcode-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C1.html","excerpt":"","text":"Leetcode—两数之和1给定一个整数数组nums和一个正阿虎目标值target,请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标 你可以假设每种输入只会对应一个答案，但是，数组中同一个元素不能使用两遍。 示例： nums = [2,7,11,15]，target = 9； 输出：[0,1] 解法一：暴力法 class Solution &#123; // Brute Force // N is the size of nums // Time Complexity: O(N^2) // Space COmplexity: O(1) public int[] twoSum(int[] nums, int target) &#123; int[] result = new int[2]; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i+1; j &lt; nums.length; j++) &#123; int sum = nums[i] + nums[j]; if (sum == target) &#123; result[0] = i; result[1] = j; return result; &#125; &#125; &#125; return result; &#125; &#125; 解法二：哈希表法 class Solution &#123; // HashMap // N is the size of nums // Time Complexity: O(N) // Space COmplexity: O(N) public int[] twoSum(int[] nums, int target) &#123; int[] result = new int[2]; HashMap&lt;Integer, Integer> map = new HashMap&lt;>(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; for (int j = 0; j &lt; nums.length; j++) &#123; int diff = target - nums[j]; if (map.containsKey(diff) &amp;&amp; map.get(diff) != j) &#123; result[0] = j; result[1] = map.get(diff); return result; &#125; &#125; return result; &#125; &#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://codeanime.cc/categories/LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://codeanime.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://codeanime.cc/tags/LeetCode/"}]},{"title":"数据结构 ----> 1","slug":"数据结构-1","date":"2021-08-07T11:38:09.000Z","updated":"2021-09-02T15:58:51.735Z","comments":true,"path":"数据结构-1.html","link":"","permalink":"https://codeanime.cc/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1.html","excerpt":"","text":"数据结构 —-&gt; 1","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://codeanime.cc/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://codeanime.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"程序员","slug":"程序员","permalink":"https://codeanime.cc/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"},{"name":"学习","slug":"学习","permalink":"https://codeanime.cc/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"细思极恐---十年生死两茫茫，通信人，意欲亡。","slug":"细思极恐-十年生死两茫茫，通信人，意欲亡。","date":"2021-08-07T07:00:22.000Z","updated":"2021-08-07T11:58:59.477Z","comments":true,"path":"细思极恐-十年生死两茫茫，通信人，意欲亡。.html","link":"","permalink":"https://codeanime.cc/%E7%BB%86%E6%80%9D%E6%9E%81%E6%81%90-%E5%8D%81%E5%B9%B4%E7%94%9F%E6%AD%BB%E4%B8%A4%E8%8C%AB%E8%8C%AB%EF%BC%8C%E9%80%9A%E4%BF%A1%E4%BA%BA%EF%BC%8C%E6%84%8F%E6%AC%B2%E4%BA%A1%E3%80%82.html","excerpt":"","text":"每一位通信人，都可能面对过来自亲友的“灵魂三问”。 “通信究竟是什么？” “通信从哪里来？” “通信要往哪里去？” 讲真的，我不知道。。。。 让我们看看我这三年到底经历了什么？ 不久前就拿到了成绩单，今天打开又仔细看了一下，就离谱，我都不记得学了这么多门课了，给大家列一下就我校通信工程要学什么吧。 大一 大学物理（一） 大学物理实验（一） 大学英语（一） 高等数学(一) 信息应用技术（一） 大学物理(二) 大学物理(二) 大学英语（二） 电路分析原理 电子工艺 高等数学 (二) 马克思主义基本原理 通信工程专业导论 线性代数 专业见习（一） 大二 C程序设计 大学英语（三） /英语语言素质拓展 复变函数 概率论与数理统计 模拟电子技术 模拟电子技术实验 通信工程制图 信号与系统 电磁场与电磁波 数据通信技术（中兴通讯网络技术工程师） 数字电路（数字电子技术基础） 数字电路实验 数字信号处理 大三 4G移动通信技术 单片机原理及应用 单片机原理及应用实验 光传输技术 宽带接入技术 通信电子线路 通信原理 4G全网建设 Java高级编程 三网融合综合实训 数据库系统及应用 信息论与编码 大四还没开学，，，还有两个月的课程，也不知道还有啥没学的 怪不得民间一直有这样一段流传，我觉得描述得颇为真实： 十年生死两茫茫，通信人，意欲亡。 模电数电，学完更凄凉。 纵使学完又怎样，今信号，明磁场。 夜来报告还没写，速起床，连夜忙。 妹子没有，唯有泪千行! 不得不说，通信专业要学的真的又多又难又咋，包括各种通用基础课、通信专业课，计算机基础课、硬件课、软件课、课程设计和实验课，还有金工实习磨锤子，，，，，万金油专业可不是吹的， 或许也正因为这样，这也成为很多人后续可以从通信专业转行到其他方向的一个垫脚石吧。。。。 通信专业四大天书，学通信的估计都懂： 《电磁场与电磁波》 《模电》 《数字信号处理》 《高频电子线路》 《通信原理》 尤其是《电磁场与电磁波》这棵参天大树，曾几何时，上面挂满了多少英雄好汉。。。 大家如有学通信的，不妨在评论区吐吐槽。。。（苦笑） 学通信专业的小伙伴有想要转行的，趁早打算！ 另外说一下，我搭建了个人博客网站，欢迎大家来互相交流，学习。","categories":[{"name":"随手","slug":"随手","permalink":"https://codeanime.cc/categories/%E9%9A%8F%E6%89%8B/"}],"tags":[{"name":"随手","slug":"随手","permalink":"https://codeanime.cc/tags/%E9%9A%8F%E6%89%8B/"},{"name":"大学","slug":"大学","permalink":"https://codeanime.cc/tags/%E5%A4%A7%E5%AD%A6/"}]},{"title":" Hexo部署出现错误err: Error: Spawn failed解决方式","slug":"Hexo部署出现错误err-Error-Spawn-failed解决方式","date":"2021-08-06T15:29:57.000Z","updated":"2021-09-13T14:56:27.193Z","comments":true,"path":"Hexo部署出现错误err-Error-Spawn-failed解决方式.html","link":"","permalink":"https://codeanime.cc/Hexo%E9%83%A8%E7%BD%B2%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AFerr-Error-Spawn-failed%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F.html","excerpt":"","text":"Hexo部署出现错误err: Error: Spawn failed解决方式部署过程中可能会出现错误 fatal: unable to access 'https://github.com/a956551943/a956551943.github.io/': Encountered end of file FATAL &#123; err: Error: Spawn failed at ChildProcess.&lt;anonymous> (/usr/local/src/hexo/hanyubolg/node_modules/hexo-util/lib/spawn.js:51:21) at ChildProcess.emit (events.js:376:20) at Process.ChildProcess._handle.onexit (internal/child_process.js:277:12) &#123; code: 128 &#125; &#125; Something's wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html 解决方式一： ##进入站点根目录 cd d://blog/codeanime/ ##删除git提交内容文件夹 rm -rf .deploy_git/ ##执行 git config --global core.autocrlf false ##最后 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 解决方式二：有可能是你的git repo配置地址不正确,可以将http方式变更为ssh方式 ##进入站点根目录 cd /usr/local/src/hexo/hanyubolg/ ##删除git提交内容文件夹 vim _config.yml ##修改 deploy: type: git repo: https://github.com/yourname/yourname.github.io.git -> git@github.com:a956551943/weixiaohui.github.io.git branch: master ##最后 hexo clean hexo g hexo d 解决方式三：不建议 ##进入站点根目录 cd /usr/local/src/hexo/hanyubolg/ ##进入depoly文件夹 cd .deploy_git/ ##强制推送 git push -f 文章来源：www.jianshu.com， 作者：翰羽，版权归原作者所有，如需转载，请联系作者。 原文链接： https://www.jianshu.com/p/c60ad2a33a1e","categories":[{"name":"生命不熄，折腾不止！","slug":"生命不熄，折腾不止！","permalink":"https://codeanime.cc/categories/%E7%94%9F%E5%91%BD%E4%B8%8D%E7%86%84%EF%BC%8C%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2%EF%BC%81/"}],"tags":[{"name":"生命不息，折腾不止！","slug":"生命不息，折腾不止！","permalink":"https://codeanime.cc/tags/%E7%94%9F%E5%91%BD%E4%B8%8D%E6%81%AF%EF%BC%8C%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2%EF%BC%81/"}]},{"title":"Hexo-fluid主题设置统计博客阅读量","slug":"Hexo-fluid主题设置统计博客阅读量","date":"2021-08-06T06:32:35.000Z","updated":"2021-08-07T11:49:30.768Z","comments":true,"path":"Hexo-fluid主题设置统计博客阅读量.html","link":"","permalink":"https://codeanime.cc/Hexo-fluid%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E7%BB%9F%E8%AE%A1%E5%8D%9A%E5%AE%A2%E9%98%85%E8%AF%BB%E9%87%8F.html","excerpt":"","text":"Hexo-fluid主题设置统计博客阅读量开始小插曲： 我使用的是sublime文本编辑器： 正戏开始 查找关键字：web_analytics (快捷键ctrl+F) 这里我使用一个第三方服务Leancloud来统计文章的阅读量。 首先需要打开 Leancloud 的官网，注册一个账号，注册好账号之后，点击左上角的按钮，创建一个应用。 创建时「应用名称」可以随你自由命名，下方的「应用计价方案」选择「开发版」就好，不需要花钱，接着点击右下角的蓝色按钮「创建」。 创建好应用之后，打开应用的「设置 &gt;&gt; 应用凭证」，页面中有两个参数，一个是AppID，一个是AppKey。 这两个参数下方的值等会要用到，暂时不要把网页关掉。 查找关键字：leancloud 如下图所示，可以看到 leancloud 下方有两个需要配置的参数，一个是app_id，一个是app_key，这两个参数的值就分别对应上面说到的AppID和AppKey。 接着我们还要开启每篇博客的数据统计的功能，在博客主题配置文件中搜索关键字 view。 每篇博客的数据统计 views 下方有两个参数，一个是 enable，将其设置为 enable 或 true 都可以；一个是统计的来源 source，设置为 leancloud。 完成以上配置之后，将所有变更 Push 到服务器，稍等一小会，刷新自己的博客，一般情况下，就可以在每篇博客的顶部看到阅读量的统计数据了。","categories":[{"name":"生命不熄，折腾不止！","slug":"生命不熄，折腾不止！","permalink":"https://codeanime.cc/categories/%E7%94%9F%E5%91%BD%E4%B8%8D%E7%86%84%EF%BC%8C%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2%EF%BC%81/"}],"tags":[{"name":"生命不息，折腾不止！","slug":"生命不息，折腾不止！","permalink":"https://codeanime.cc/tags/%E7%94%9F%E5%91%BD%E4%B8%8D%E6%81%AF%EF%BC%8C%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2%EF%BC%81/"}]},{"title":"宝塔面板搭建autoPicCdn：一款基于jsdelivr+Github的免费CDN图床","slug":"宝塔面板搭建autoPicCdn：一款基于jsdelivr-Github的免费CDN图床","date":"2021-08-06T05:22:53.000Z","updated":"2021-08-07T11:49:59.983Z","comments":true,"path":"宝塔面板搭建autoPicCdn：一款基于jsdelivr-Github的免费CDN图床.html","link":"","permalink":"https://codeanime.cc/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E6%90%AD%E5%BB%BAautoPicCdn%EF%BC%9A%E4%B8%80%E6%AC%BE%E5%9F%BA%E4%BA%8Ejsdelivr-Github%E7%9A%84%E5%85%8D%E8%B4%B9CDN%E5%9B%BE%E5%BA%8A.html","excerpt":"","text":"autoPicCdn是白嫖Github的存储空间，通过jsdelivr全球加速(含有国内节点)。实现图床加速的目的。 加速效果非常不错，用站长工具检测，也是一片绿油油，所以用来存储一些静态文件是最合适不过了。 相关文章：Github+jsDelivr+PicGo 为脚本/图片等静态文件加速的全球CDN 活动：堡塔（宝塔面板）724运维节，本活动一年就这一次，错过再等一年。组队免费送服务器插件（堡塔APP、堡塔企业级备份、堡塔资源监视器）不拿白不拿，现在就来组队吧！https://www.bt.cn/724/a2?group_id=f5dff75d 1、简介项目：https://github.com/yumusb/autoPicCdn 2、功能1）选择Github（推荐） 白嫖Github的存储空间，通过jsdelivr全球加速(含有国内节点)。实现图床的目的。 2）选择Gitee 白嫖Gitee的存储空间， 实现图床的目的。存储和访问节点都在国内，请在遵循国内相关法律的前提下使用。 文件在1M以上需要访客登录才能访问。1M以下，相当稳。 3、准备1）宝塔面板最新版本（宝塔服务器面板，一键全能部署及管理，送你3188元礼包，点我领取https://www.bt.cn/?invite_code=MV9ub2NxdmI=） 2）lnmp自己安装好（nginx1.18、mysql5.7、PHP7.3、phpmyadmin4.7） 4、新建仓库这里具体的可以参考，上面的文章推荐！ 1）当然你得先有一个github账号！网址：https://github.com/ 2）登录/注册GitHub，新建一个仓库，填写好仓库名，仓库描述，根据需求选择是否为仓库初始化一个README.md描述文件 3）新建好即可，下面我们生成token 5、生成tokenhttps://github.com/settings/tokens 去这个页面生成一个有写权限的token（repo：Full control of private repositories 和write:packages前打勾）~ 得到token后，保存备用。 6、下载程序以及新建数据库1）可以利用宝塔的远程下载来搞定，下载好之后解压，把文件都复制你自己的网站根目录。 2）新建数据库，至于宝塔如何新建，简单看个图吧。 7、导入数据库把网站根目录下的pic.sql文件复制到（/www/backup/database）然后再数据库中导入这个文件。 8、配置up.php中的相关字段打开你网站根目录下的up.php文件，配置其中的相关字段。 &#x2F;&#x2F;必选项define(&quot;TYPE&quot;,&quot;GITHUB&quot;);&#x2F;&#x2F;选择github&#x2F;&#x2F;define(&quot;TYPE&quot;,&quot;GITEE&quot;);&#x2F;&#x2F;选择gitee，如果使用gitee，需要手动建立master分支，可以看这里 https:&#x2F;&#x2F;gitee.com&#x2F;help&#x2F;articles&#x2F;4122 define(&quot;USER&quot;,&quot;pic-cdn&quot;);&#x2F;&#x2F;你的GitHub&#x2F;Gitee的用户名 define(&quot;REPO&quot;,&quot;cdn2&quot;);&#x2F;&#x2F;必须是上面用户名下的 公开仓库 define(&quot;MAIL&quot;,&quot;yumusb@foxmail.com&quot;);&#x2F;&#x2F;邮箱无所谓，随便写 define(&quot;TOKEN&quot;,&quot;213&quot;);&#x2F;&#x2F;贴入你刚才得到的token 之后配置数据库信息 此处为隐藏的内容！ 发表评论并刷新，方可查看 发表评论 保存后，搭建完毕。 9、效果效果还是很不错的，比之前的picgo要方便一点。 10、最后看着写了很多，其实整个步骤很简单，仓库建好后，就是新建网站，下载程序，导入数据库，配置up.php,之后就可以了。 不过你需要知道的是jsDelivr仅能针对50M以下的文件CDN加速！ 仓库单个文件50M会收到警告，大于100M会被拒绝！ 目前GITHUB仓库容量是没有上限的！不过官方推荐在1G以内！ 所以，资源不要滥用，这个图床私用就可以了，不要搞的大家都不好用了。 文章来源： www.daniao.org， 作者：大鸟博客，版权归原作者所有，如需转载，请联系作者。 源文链接： https://www.daniao.org/10086.html","categories":[{"name":"生命不熄，折腾不止！","slug":"生命不熄，折腾不止！","permalink":"https://codeanime.cc/categories/%E7%94%9F%E5%91%BD%E4%B8%8D%E7%86%84%EF%BC%8C%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2%EF%BC%81/"}],"tags":[{"name":"生命不息，折腾不止！","slug":"生命不息，折腾不止！","permalink":"https://codeanime.cc/tags/%E7%94%9F%E5%91%BD%E4%B8%8D%E6%81%AF%EF%BC%8C%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2%EF%BC%81/"}]},{"title":"免费CDN：jsDelivr+Github 使用方法","slug":"免费CDN：jsDelivr-Github-使用方法","date":"2021-08-06T04:25:40.000Z","updated":"2021-08-13T11:39:35.674Z","comments":true,"path":"免费CDN：jsDelivr-Github-使用方法.html","link":"","permalink":"https://codeanime.cc/%E5%85%8D%E8%B4%B9CDN%EF%BC%9AjsDelivr-Github-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.html","excerpt":"","text":"免费CDN：jsDeliver+Github使用方法CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。 详情请参见百度百科：[https://baike.baidu.com/item/CDN/420951]:百度百科 1、新建Github仓库，名字随意取 2、克隆Github仓库到本地 在本地目录右键 Git Bash Here 执行命令： git clone 复制的仓库的地址 3、上传资源把要上传的资源放到本地git仓库 git status &#x2F;&#x2F;查看状态 git add . &#x2F;&#x2F;添加所有文件到暂存区 git commit -m &#39;第一次提交&#39; &#x2F;&#x2F;把文件提交到仓库 git push &#x2F;&#x2F;推送至远程仓库 4、发布仓库点击relsese发布 自定义发布版本号 然后就可以看到发布的版本了 5、通过jsDeliver引用资源使用方法：https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径 例如： 注意版本号不是必须的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下： 可以去官网查看：https://www.jsdelivr.com/ 然后就可以开心玩耍了。","categories":[{"name":"生命不熄，折腾不止！","slug":"生命不熄，折腾不止！","permalink":"https://codeanime.cc/categories/%E7%94%9F%E5%91%BD%E4%B8%8D%E7%86%84%EF%BC%8C%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2%EF%BC%81/"}],"tags":[{"name":"生命不息，折腾不止！","slug":"生命不息，折腾不止！","permalink":"https://codeanime.cc/tags/%E7%94%9F%E5%91%BD%E4%B8%8D%E6%81%AF%EF%BC%8C%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2%EF%BC%81/"}]},{"title":"使用Hexo写博客","slug":"使用Hexo写博客","date":"2021-08-05T14:34:46.000Z","updated":"2021-09-02T15:34:18.789Z","comments":true,"path":"使用Hexo写博客.html","link":"","permalink":"https://codeanime.cc/%E4%BD%BF%E7%94%A8Hexo%E5%86%99%E5%8D%9A%E5%AE%A2.html","excerpt":"","text":"尽管 Hexo 支持 MarkDown，但是我们却不能像写单独的 MarkDown 文档时那样肆无忌惮。由于我们所写的文档是需要被解析为静态网页文件的，所以我们必须严格遵从 Hexo 的规范，这样才能解析出条理清晰的静态网页文件。 新建文档假设我们的文章名为 “hello hexo markdwon”，在命令行键入以下命令即可： $ hexo new &quot;hello hexo markdown&quot; 上述命令的结果是在 ./hexo/source/_posts 路径下新建了一个 hello-hexo-markdown.md 文件。 然后，我们就可以打开编辑器尽情地写作了。 文档格式我们使用文本编辑器打开刚刚新建的 hello-hexo-markdown.md 文件，会发现其中已经存在内容： --- title: hello hexo markdown date: 2016-11-16 18:11:25 tags: --- 这些内容是干嘛的呢？事实上，他们就是用于设置 MarkDown 文档在被解析为静态网页文件时的相关配置，这些配置参数一般位于文件中最上方以 --- 分隔的区域。 其中，title 的值是当前文档名，也是将来在网页中显示的文章标题。 date 值是我们新建文档时的当地时区时间。 tags 值是文档的标签，我们可以随意赋值为文档贴标签。其用法如下： --- title: hello hexo markdown date: 2016-11-16 18:11:25 tags: - hello - hexo - markdown --- 上面的配置参数为这篇文档贴上了 hello、hexo、mardown 标签，如果站点使用的主题支持标签功能，MarkDown 文档被解析为静态网页文件后就可以看到效果。 除了以上这些，还有很多预先定义的参数 Front-mtter，我们这里选取一个常用且较为典型的配置参数 categories 讲解一下。 文章分类categories 是用来给文章分类的，它跟 tags 不同的是其具有顺序性和层次性。 例如，我们写一篇关于 CSS3 动画的文章，我们可能会为其打标签 ”CSS3“、”动画“等，但是我们却会将其分在 CSS/CSS3 类别下，这个是有一定的相关性、顺序性和层次性。简单来说，categories 有点儿像新建文件夹对文档进行分门别类的归置。 categories 的用法同 tags 一样，只不过斗个 categories 值是分先后顺序的。 引用资源写个博客，有时候我们会想添加个图片啦 O.O，或者其他形式的资源，等等。 这时，有两种解决办法： 使用绝对路径引用资源，在 Web 世界中就是资源的 URL 使用相对路径引用资源 文章资源文件夹如果是使用相对路径引用资源，那么我们可以使用 Hexo 提供的资源文件夹功能。 使用文本编辑器打开站点根目录下的 _ config.yml 文件，将 post_asset_folder 值设置为 true。 post_asset_folder: true 上面的操作会开启 Hexo 的文章资源文件管理功能。Hexo 将会在我们每一次通过 hexo new &lt;title&gt; 命令创建新文章时自动创建一个同名文件夹，于是我们便可以将文章所引用的相关资源放到这个同名文件夹下，然后通过相对路径引用。 相对路径引用的标签插件通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。我们可以通过使用 Hexo 提供的标签插件来解决这个问题： &#123;% asset_path slug %&#125; &#123;% asset_img slug [title] %&#125; &#123;% asset_link slug [title] %&#125; 比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](/example.jpg) ，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作） ！！！注意： 如果已经开启了文章的资源文件夹功能，当使用 MarkDown 语法引用相对路径下的资源时，只需 ./资源名称，不用在引用路径中添加同名文件夹目录层级。 正确的引用图片方式是使用下列的标签插件而不是 markdown ： &#123;% asset_img example.jpg This is an example image %&#125; 通过这种方式，图片将会同时出现在文章和主页以及归档页中。 文章摘要有的时候，主题模板配置的不够好的话，Hexo 最终生成的静态站点是不会自动生成文章摘要的。 所以，为了保险起见，我们也自己手动设置文章摘要，这样也方便避免自动生成的摘要不优雅的情况。 设置文章摘要，我们只需在想显示为摘要的内容之后添 &lt;!-- more --&gt; 即可。像下面这样： --- title: hello hexo markdown date: 2016-11-16 18:11:25 tags: - hello - hexo - markdown --- 我是短小精悍的文章摘要(๑•̀ㅂ•́)و✧ &lt;!-- more --&gt; 紧接着文章摘要的正文内容 这样，&lt;!-- more --&gt; 之前、文档配置参数之后中的内容便会被渲染为站点中的文章摘要。 注意！文章摘要在文章详情页是正文中最前面的内容。 生成文件清除缓存文件为了避免不必要的错误，在生成静态文件前，强烈建议先运行以下命令： $ hexo clean 上述命令会清除本地站点文件夹下的缓存文件（db.json）和已有的静态文件（public）。 生成静态文件写好 MarkDown 文档之后，我们就可使用以下命令生成静态文件： $ hexo generate 然后我们就可以启动 Hexo 服务器，使用浏览器打开 http://localhost:4000 查看效果了。 示范下图是一篇经过配置的简单文档，生成静态文件后在网站首页显示的结果。我们可以看到手动设置的摘要，以及打的标签生效了。 文章来源： lfkid.github.io， 作者：lfkid，版权归原作者所有，如需转载，请联系作者。 源文链接： https://lfkid.github.io/2016/11/16/Hexo%E6%95%99%E7%A8%8B%EF%BC%9A%EF%BC%88%E4%B8%89%EF%BC%89%E4%BD%BF%E7%94%A8Hexo%E5%86%99%E5%8D%9A%E5%AE%A2/","categories":[{"name":"生命不熄，折腾不止！","slug":"生命不熄，折腾不止！","permalink":"https://codeanime.cc/categories/%E7%94%9F%E5%91%BD%E4%B8%8D%E7%86%84%EF%BC%8C%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2%EF%BC%81/"}],"tags":[{"name":"生命不息，折腾不止！","slug":"生命不息，折腾不止！","permalink":"https://codeanime.cc/tags/%E7%94%9F%E5%91%BD%E4%B8%8D%E6%81%AF%EF%BC%8C%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2%EF%BC%81/"}]},{"title":"WordPress博客网站搬家和换域名方法","slug":"WordPress博客网站搬家和换域名方法","date":"2021-08-05T14:22:29.000Z","updated":"2021-08-07T11:49:50.591Z","comments":true,"path":"WordPress博客网站搬家和换域名方法.html","link":"","permalink":"https://codeanime.cc/WordPress%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%90%AC%E5%AE%B6%E5%92%8C%E6%8D%A2%E5%9F%9F%E5%90%8D%E6%96%B9%E6%B3%95.html","excerpt":"","text":"WordPress博客网站搬家和换域名方法 方案一 开设个人博客的朋友使用WordPress不在少数，那么也难免不了更换空间和域名的情况，由于笔者亲历了一次更换空间和域名的情况，将博客从AAA.com 更改为 BBB.com，所以本文就分享一下更换域名比较好的办法。 WordPress大家都知道后台需要设置网站的默认网址，如果直接更换了域名的话，使用新的域名是无法登陆的。网上有很多文章，告诉大家可以修改MySQL数据库，或者修改WordPress的wp-config.php文件或function.php文件等，其实不用这么麻烦。 只要更换前后的域名都在自己手里，那么其实解决方法很简单。首先让更改前后的域名都解析到博客空间，也就是让新旧域名都可以正确访问博客。判断新旧域名是否都能正确访问，除了自己本地直接访问两个域名都能正确访问到网站之外，还需要查看其他地区域名访问是否正常，因为电信、联通还有不同地区DNS生效的时间是不同的。这时候站长之家有个比较好的工具可是使用，就是超级ping（ http://ping.chinaz.com），把新旧域名分别输入超级ping里，查看是否各地都能ping通 用管理员登陆WordPress后台，点击设置→常规，将里面的WordPress 地址（URL）和站点地址（URL）都修改为新的域名，然后点击保存更改。咦，咋退出了，其实是成功了，看一下浏览器的地址栏是不是变成新地址了？用管理员账户登陆一下，看看设置→常规里是不是变成了新的域名？然后再点击首页看看是不是变成了新的域名，如果输入旧的域名会不会跳转到新的域名呢。很明显修改成功了，是不是很简单。 但是由于博客文章里的一些链接和图片地址还是用的旧的域名，所以还需要进行一些修改。 登陆phpmyadmin，选择自己博客的数据库，然后点击SQL，将下面三行命令输入进去： UPDATE wp_posts SET post_content = replace( post_content, ‘AAA.com’,’BBB.com’) ; UPDATE wp_comments SET comment_content = replace(comment_content, ‘AAA.com’, ‘BBB.com’) ; UPDATE wp_comments SET comment_author_url = replace(comment_author_url, ‘AAA.com’, ‘BBB.com’) ; 然后点击 执行，如果没有出现错误，那么就会将文章和评论里的所有地址进行了更换。 这时候用新的地址去访问吧，域名完美进行更换 方案二 第一步：备份网站根目录下所有文件并转移到新主机； 第二步：备份网站数据库文件并在新主机上建立数据库，进行导入； 第三步：修改wp-config.php文件，确保网站文件与数据库通信正常； 第四步：在新主机上绑定域名，域名解析到主机。 第五步：在数据库更换网址。 wordpress搬家第一步：备份网站根目录下的所有文件； 方法1.可以直接ftp把网址所有文件直接下来。 方法2.这个wordpress插件 BackUpWordPress 可以备份网站文件和数据库并打包，非常方便，推荐用这个方法。 wordpress搬家第二步：备份数据表并导出，在新主机数据库建立数据库名，并导入数据表； 备份数据表常见的有两种方法，一种是在旧主机里找到数据库管理，将数据表导出sql格式（一般默认为此）；另一种是wordpress博客安装“WordPress Database Backup”插件，通过插件导出数据表（强烈建议安装此插件，可以定期自动备份数据，比较安全），插件安装方法此处不讲。导出Sql格式的数据表后，需要登录新主机的数据库管理界面，建立新的数据库。数据库名可任意，最好与旧的相同。数据库建立后找到导入选项，将之前导出的数据表导入数据库。 wordpress搬家第三步：修改wp-config.php文件，促使网站文件与数据库通信正常； 让网站文件与数据库正常通信需要告诉网站文件，你要用的数据库用户名是什么，密码是什么，网站文件才可以获取数据库信息，然后还要告诉网站文件，你的数据库名是什么，让它找到与之对应的数据表，这样就能保持正常通信了。如下： /** WordPress 数据库的名称 */ define(‘DB_NAME’,’你新建的数据库名称’); /** MySQL 数据库用户名 */ define(‘DB_USER’,’你的数据库用户名，这个在主机数据库信息里可以找到’); /** MySQL 数据库密码 */ define(‘DB_PASSWORD’,’你的数据库密码，这个也在主机信息里找’) /** MySQL 主机 */ define(‘DB_HOST’,’localhost’); 需要改动的只有前三项，其他一般是不修改的。 wordpress搬家第四步：在新主机上绑定域名和域名解析； 这个很简单就不多说了。 wordpress搬家第五步：在数据库更改网址。 打开你的数据库，点击SQL，将以下代码粘贴到方框当中。点击“执行”。 UPDATEwp_optionsSEToption_value =replace( option_value,’http://www.old.com&#39;,&#39;http://www.new.com&#39;)WHEREoption_name =’home’ORoption_name =’siteurl’; UPDATEwp_postsSETpost_content =replace( post_content,’http://www.old.com&#39;,&#39;http://www.new.com&#39;) ; UPDATEwp_postsSETguid =replace( guid,’http://www.old.com&#39;,&#39;http://www.new.com&#39;) ; 修改数据库。找到相应的网站数据库，修改wp-options和wp-posts两个文件。将老域名全部更换为新域名。注意第一个文件需要修改两项：siteurl和home。 这样搬家就完成了,自己测试完记录下来，方便以后使用。 文章来源： blog.51cto.com， 作者：2012hjtwyf，版权归原作者所有，如需转载，请联系作者。 源文链接： https://blog.51cto.com/hujiangtao/1917756","categories":[{"name":"生命不熄，折腾不止！","slug":"生命不熄，折腾不止！","permalink":"https://codeanime.cc/categories/%E7%94%9F%E5%91%BD%E4%B8%8D%E7%86%84%EF%BC%8C%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2%EF%BC%81/"}],"tags":[{"name":"生命不息，折腾不止！","slug":"生命不息，折腾不止！","permalink":"https://codeanime.cc/tags/%E7%94%9F%E5%91%BD%E4%B8%8D%E6%81%AF%EF%BC%8C%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2%EF%BC%81/"}]},{"title":"二次元随机图片API","slug":"二次元随机图片API","date":"2021-08-05T05:05:12.000Z","updated":"2021-10-04T00:25:09.079Z","comments":true,"path":"二次元随机图片API.html","link":"","permalink":"https://codeanime.cc/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%9A%8F%E6%9C%BA%E5%9B%BE%E7%89%87API.html","excerpt":"","text":"俺自己的https://api.codeanime.xyz/random.php 东方ProjectAPI文档：Paulzzh — 东方Project随机图片API 接口：https://img.paulzzh.tech/touhou/random 樱花API文档：随机二次元图片API-樱花 接口：http://www.dmoe.cc/random.php 汐岑API文档：汐岑ACG |- 随机二次元图片API (yanwz.cn) 二次元动漫图片：https://acg.yanwz.cn/api.php menhera酱表情包：https://acg.yanwz.cn/menhera/api.php 风景图片：https://acg.yanwz.cn/scenery/api.php 二次元电脑壁纸：https://acg.yanwz.cn/wallpaper/api.php 阿珏API文档：随机二次元图片API - 阿珏博客 接口：https://random.52ecy.cn/random.phphttps://random.52ecy.cn/randbg.php (推荐) 苏晓晴API文档：随机二次元接口 接口：https://acg.toubiec.cn/random.php 岁月小筑API文档：岁月小筑随机图片API上线了，目前公测中~~ | 岁月小筑 https调用：https://img.xjh.me/random_img.php http调用：http://img.xjh.me/random_img.php 小歪API文档：小歪API-图片API，文字API，二维码API，随心所动不再单调 二次元动漫：https://api.ixiaowai.cn/api/api.php menhera酱动漫：https://api.ixiaowai.cn/mcapi/mcapi.php 一堆api高清壁纸：https://api.ixiaowai.cn/gqapi/gqapi.php 电脑动漫图片：http://api.btstu.cn/sjbz/?lx=dongman 电脑美女图片：http://api.btstu.cn/sjbz/?lx=meizi 电脑随机动漫妹子：http://api.btstu.cn/sjbz/?lx=suiji 手机动漫图片：http://api.btstu.cn/sjbz/?lx=m_dongman 手机美女图片：http://api.btstu.cn/sjbz/?lx=m_meizi 手机随机动漫妹子：http://api.btstu.cn/sjbz/?m_lx=suiji 手机性感美女:https://uploadbeta.com/api/pictures/random/?key=%E6%8E%A8%E5%A5%B3%E9%83%8E 手机电脑自动判断，电脑显示适合电脑的壁纸，手机显示适合手机的壁纸 http://api.btstu.cn/sjbz/zsy.php 风景随机图：http://pic.tsmp4.net/api/fengjing/img.php女神随机图：http://pic.tsmp4.net/api/nvsheng/img.php影视随机图：http://pic.tsmp4.net/api/yingshi/img.php二次元随机图：http://pic.tsmp4.net/api/erciyuan/img.php二次元随机图:https://acg.toubiec.cn/random二次元随机图:http://www.dmoe.cc/random.php https://uploadbeta.com/api/pictures/random/?key=推女郎 https://uploadbeta.com/api/pictures/random/?key=二次元 https://uploadbeta.com/api/pictures/random/?key=动漫 api现在已经有几千张图了，每天都在增加，大家可以玩玩 EEE.DOGAPI文档：随机图片API - EEE.DOG 接口：https://api.yimian.xyz/img 随机图片APIAPI文档：随机图片API (pixivweb.com) 接口：https://api.pixivweb.com/anime18r.php?return=img 樱花API文档：随机二次元图片API-樱花 接口：http://www.dmoe.cc/random.php 汐岑API文档：汐岑ACG |- 随机二次元图片API (yanwz.cn) 二次元动漫图片：https://acg.yanwz.cn/api.php menhera酱表情包：https://acg.yanwz.cn/menhera/api.php 风景图片：https://acg.yanwz.cn/scenery/api.php 二次元电脑壁纸：https://acg.yanwz.cn/wallpaper/api.php 苏晓晴API文档：随机二次元接口 接口：https://acg.toubiec.cn/random.php 岁月小筑API文档：岁月小筑随机图片API上线了，目前公测中~~ | 岁月小筑 https调用：https://img.xjh.me/random_img.php http调用：http://img.xjh.me/random_img.php 随机二次元图片API-樱花API文档：https://www.dmoe.cc/ 接口：https://www.dmoe.cc/random.php 随机二次元图片API文档：https://api.vvhan.com/dongman.html 接口：https://www.niubai.net/yanshi/acgapi/acgurl.php https://api.vvhan.com/api/acgimg 随机二次元图片API接口APi文档：https://api.ghser.com/acg.html 接口地址： https://api.ghser.com/random/api.php 自判断二次元API基本调用格式： https://api.ghser.com/random/api.php PC随机二次元API： https://api.ghser.com/random/pc.php PE随机二次元API： https://api.ghser.com/random/pe.php PC随机二次元风景API： https://api.ghser.com/random/bg.php 随机二次元图片(背景图)APIAPI文档：https://www.nck.cc/index.php/archives/3/ 接口：https://www.rrll.cc/tuceng/ecy.php 七彩云APIAPI文档：https://api.qicaiyun.top/ercy/ 接口：https://api.qicaiyun.top/ercy/api.php 喵白API文档：https://acg.teas.moe/ 接口： https://acg.teas.moe/man/api.php（二次元动漫） https://acg.teas.moe/hua/api.php（二次元动漫2） https://acg.teas.moe/suiji/api.php（随机动漫） 汐岑博客API文档：https://acg.yanwz.cn/ 接口： 二次元动漫图片： https://acg.yanwz.cn/api.php menhera酱表情包： https://acg.yanwz.cn/menhera/api.php 风景图片： https://acg.yanwz.cn/scenery/api.php 二次元电脑壁纸： https://acg.yanwz.cn/wallpaper/api.php 动漫星空API官网API文档：https://api.dongmanxingkong.com/zipanduansuijierciyuantupianapi.html 接口： https://api.ghser.com/random/api.php PC随机二次元API https://api.ghser.com/random/pc.php PE随机二次元API https://api.ghser.com/random/pe.php 随机二次元风景API https://api.ghser.com/random/bg.php 1080P： https://api.dongmanxingkong.com/suijitupian/acg/1080p/index.php 2K： https://api.dongmanxingkong.com/suijitupian/acg/2k/index.php 4K： https://api.dongmanxingkong.com/suijitupian/acg/4k/index.php 随机图片APIAPI文档：随机图片API (pixivweb.com) 接口：https://api.pixivweb.com/anime18r.php?return=img 无名API文档：https://www.12580sky.com/fenxiang/23336.html 接口： 电脑动漫图片： http://api.btstu.cn/sjbz/?lx=dongman 电脑美女图片： http://api.btstu.cn/sjbz/?lx=meizi 电脑随机动漫妹子： http://api.btstu.cn/sjbz/?lx=suiji 手机动漫图片： http://api.btstu.cn/sjbz/?lx=m_dongman 手机美女图片： http://api.btstu.cn/sjbz/?lx=m_meizi 手机随机动漫妹子： http://api.btstu.cn/sjbz/?m_lx=suiji 手机电脑自动判断，电脑显示适合电脑的壁纸，手机显示适合手机的壁纸 http://api.btstu.cn/sjbz/zsy.php 二次元随机图： https://acg.toubiec.cn/random 二次元随机图： http://www.dmoe.cc/random.php https://uploadbeta.com/api/pictures/random/?key=推女郎 https://uploadbeta.com/api/pictures/random/?key=二次元 https://uploadbeta.com/api/pictures/random/?key=动漫 电脑动漫图片：http://api.btstu.cn/sjbz/?lx=dongman 电脑美女图片：http://api.btstu.cn/sjbz/?lx=meizi 电脑随机动漫妹子：http://api.btstu.cn/sjbz/?lx=suiji 手机动漫图片：http://api.btstu.cn/sjbz/?lx=m_dongman 手机美女图片：http://api.btstu.cn/sjbz/?lx=m_meizi 手机随机动漫妹子：http://api.btstu.cn/sjbz/?m_lx=suiji 随机图片API搭建源码GitHub - galnetwen/Random-Image: 随机图片服务 樱花：https://www.dmoe.cc/random.php晓晴博客：https://acg.toubiec.cn/random.phpUnsplash Source | API Documentation：详情请看官网介绍夏沫博客：https://cdn.seovx.com/?mom=302https://cdn.seovx.com/d/?mom=302https://cdn.seovx.com/ha/?mom=302二次元随机图：https://api.blogbig.cn/random/api.php搏天api：https://api.btstu.cn/sjbz/api.php姬长信API For Docker：—-每日bing：https://api.isoyu.com/bing_images.php—-美女图片壁纸：https://api.isoyu.com/mm_images.php—-网红专栏壁纸：https://api.isoyu.com/beibei_images.php—-动态IP签名图片：https://api.isoyu.com/ip_images.php?signature=早安—-ARU(阿鲁)表情包：https://api.isoyu.com/ARU_GIF_S.php樱道：https://api.r10086.com/动漫综合1.php （网站中有更多api接口）小歪API：https://api.ixiaowai.cn/api/api.php（二次元动漫）https://api.ixiaowai.cn/mcapi/mcapi.php（mc酱动漫）https://api.ixiaowai.cn/gqapi/gqapi.php（高清壁纸）保罗｜API：https://api.paugram.com/wallpaper/墨天逸：https://api.mtyqx.cn/tapi/random.phpEEE.DOG：https://api.yimian.xyz/img动漫星空：https://api.dongmanxingkong.com/suijitupian/acg/1080p/index.php岁月小筑：#https调用https://img.xjh.me/random_img.php#http调用http://img.xjh.me/random_img.php东方Project：https://img.paulzzh.tech/touhou/random","categories":[{"name":"生命不熄，折腾不止！","slug":"生命不熄，折腾不止！","permalink":"https://codeanime.cc/categories/%E7%94%9F%E5%91%BD%E4%B8%8D%E7%86%84%EF%BC%8C%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2%EF%BC%81/"}],"tags":[{"name":"生命不息，折腾不止！","slug":"生命不息，折腾不止！","permalink":"https://codeanime.cc/tags/%E7%94%9F%E5%91%BD%E4%B8%8D%E6%81%AF%EF%BC%8C%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2%EF%BC%81/"},{"name":"API","slug":"API","permalink":"https://codeanime.cc/tags/API/"}]}],"categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://codeanime.cc/categories/MySQL/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://codeanime.cc/categories/MyBatis/"},{"name":"Maven","slug":"Maven","permalink":"https://codeanime.cc/categories/Maven/"},{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/categories/Java/"},{"name":"bat","slug":"bat","permalink":"https://codeanime.cc/categories/bat/"},{"name":"踩坑","slug":"踩坑","permalink":"https://codeanime.cc/categories/%E8%B8%A9%E5%9D%91/"},{"name":"git","slug":"git","permalink":"https://codeanime.cc/categories/git/"},{"name":"Hbuilder","slug":"Hbuilder","permalink":"https://codeanime.cc/categories/Hbuilder/"},{"name":"HTML","slug":"HTML","permalink":"https://codeanime.cc/categories/HTML/"},{"name":"Git","slug":"Git","permalink":"https://codeanime.cc/categories/Git/"},{"name":"JDBC","slug":"JDBC","permalink":"https://codeanime.cc/categories/JDBC/"},{"name":"MarkDown语法","slug":"MarkDown语法","permalink":"https://codeanime.cc/categories/MarkDown%E8%AF%AD%E6%B3%95/"},{"name":"VIm","slug":"VIm","permalink":"https://codeanime.cc/categories/VIm/"},{"name":"Linux","slug":"Linux","permalink":"https://codeanime.cc/categories/Linux/"},{"name":"Hexo","slug":"Hexo","permalink":"https://codeanime.cc/categories/Hexo/"},{"name":"生命不息折腾不止！","slug":"生命不息折腾不止！","permalink":"https://codeanime.cc/categories/%E7%94%9F%E5%91%BD%E4%B8%8D%E6%81%AF%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2%EF%BC%81/"},{"name":"动漫","slug":"动漫","permalink":"https://codeanime.cc/categories/%E5%8A%A8%E6%BC%AB/"},{"name":"随手","slug":"随手","permalink":"https://codeanime.cc/categories/%E9%9A%8F%E6%89%8B/"},{"name":"生命不息，折腾不止！","slug":"生命不息，折腾不止！","permalink":"https://codeanime.cc/categories/%E7%94%9F%E5%91%BD%E4%B8%8D%E6%81%AF%EF%BC%8C%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2%EF%BC%81/"},{"name":"数据结构","slug":"数据结构","permalink":"https://codeanime.cc/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://codeanime.cc/categories/LeetCode/"},{"name":"生命不熄，折腾不止！","slug":"生命不熄，折腾不止！","permalink":"https://codeanime.cc/categories/%E7%94%9F%E5%91%BD%E4%B8%8D%E7%86%84%EF%BC%8C%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2%EF%BC%81/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://codeanime.cc/tags/MySQL/"},{"name":"事务","slug":"事务","permalink":"https://codeanime.cc/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://codeanime.cc/tags/MyBatis/"},{"name":"mybatis","slug":"mybatis","permalink":"https://codeanime.cc/tags/mybatis/"},{"name":"maven","slug":"maven","permalink":"https://codeanime.cc/tags/maven/"},{"name":"Java","slug":"Java","permalink":"https://codeanime.cc/tags/Java/"},{"name":"Maven","slug":"Maven","permalink":"https://codeanime.cc/tags/Maven/"},{"name":"多线程","slug":"多线程","permalink":"https://codeanime.cc/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"死锁","slug":"死锁","permalink":"https://codeanime.cc/tags/%E6%AD%BB%E9%94%81/"},{"name":"bat","slug":"bat","permalink":"https://codeanime.cc/tags/bat/"},{"name":"批量修改文件夹,文件名字","slug":"批量修改文件夹-文件名字","permalink":"https://codeanime.cc/tags/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%A4%B9-%E6%96%87%E4%BB%B6%E5%90%8D%E5%AD%97/"},{"name":"Microsoft Store","slug":"Microsoft-Store","permalink":"https://codeanime.cc/tags/Microsoft-Store/"},{"name":"踩坑","slug":"踩坑","permalink":"https://codeanime.cc/tags/%E8%B8%A9%E5%9D%91/"},{"name":"python","slug":"python","permalink":"https://codeanime.cc/tags/python/"},{"name":"git","slug":"git","permalink":"https://codeanime.cc/tags/git/"},{"name":"Hbuilder","slug":"Hbuilder","permalink":"https://codeanime.cc/tags/Hbuilder/"},{"name":"快捷键","slug":"快捷键","permalink":"https://codeanime.cc/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"HTML","slug":"HTML","permalink":"https://codeanime.cc/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://codeanime.cc/tags/CSS/"},{"name":"练习","slug":"练习","permalink":"https://codeanime.cc/tags/%E7%BB%83%E4%B9%A0/"},{"name":"IO流","slug":"IO流","permalink":"https://codeanime.cc/tags/IO%E6%B5%81/"},{"name":"Git","slug":"Git","permalink":"https://codeanime.cc/tags/Git/"},{"name":"Github","slug":"Github","permalink":"https://codeanime.cc/tags/Github/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://codeanime.cc/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"Gitee","slug":"Gitee","permalink":"https://codeanime.cc/tags/Gitee/"},{"name":"笔记","slug":"笔记","permalink":"https://codeanime.cc/tags/%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"https://codeanime.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"JDBC","slug":"JDBC","permalink":"https://codeanime.cc/tags/JDBC/"},{"name":"MarkDown语法","slug":"MarkDown语法","permalink":"https://codeanime.cc/tags/MarkDown%E8%AF%AD%E6%B3%95/"},{"name":"Linux","slug":"Linux","permalink":"https://codeanime.cc/tags/Linux/"},{"name":"Vim","slug":"Vim","permalink":"https://codeanime.cc/tags/Vim/"},{"name":"Hexo","slug":"Hexo","permalink":"https://codeanime.cc/tags/Hexo/"},{"name":"迁移","slug":"迁移","permalink":"https://codeanime.cc/tags/%E8%BF%81%E7%A7%BB/"},{"name":"搬家","slug":"搬家","permalink":"https://codeanime.cc/tags/%E6%90%AC%E5%AE%B6/"},{"name":"Fluid","slug":"Fluid","permalink":"https://codeanime.cc/tags/Fluid/"},{"name":"魔改","slug":"魔改","permalink":"https://codeanime.cc/tags/%E9%AD%94%E6%94%B9/"},{"name":"主题","slug":"主题","permalink":"https://codeanime.cc/tags/%E4%B8%BB%E9%A2%98/"},{"name":"备份Hexo博客","slug":"备份Hexo博客","permalink":"https://codeanime.cc/tags/%E5%A4%87%E4%BB%BDHexo%E5%8D%9A%E5%AE%A2/"},{"name":"生命不息折腾不止！","slug":"生命不息折腾不止！","permalink":"https://codeanime.cc/tags/%E7%94%9F%E5%91%BD%E4%B8%8D%E6%81%AF%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2%EF%BC%81/"},{"name":"github","slug":"github","permalink":"https://codeanime.cc/tags/github/"},{"name":"域名","slug":"域名","permalink":"https://codeanime.cc/tags/%E5%9F%9F%E5%90%8D/"},{"name":"动漫","slug":"动漫","permalink":"https://codeanime.cc/tags/%E5%8A%A8%E6%BC%AB/"},{"name":"感动","slug":"感动","permalink":"https://codeanime.cc/tags/%E6%84%9F%E5%8A%A8/"},{"name":"观后感","slug":"观后感","permalink":"https://codeanime.cc/tags/%E8%A7%82%E5%90%8E%E6%84%9F/"},{"name":"漫评","slug":"漫评","permalink":"https://codeanime.cc/tags/%E6%BC%AB%E8%AF%84/"},{"name":"青春","slug":"青春","permalink":"https://codeanime.cc/tags/%E9%9D%92%E6%98%A5/"},{"name":"爷青结","slug":"爷青结","permalink":"https://codeanime.cc/tags/%E7%88%B7%E9%9D%92%E7%BB%93/"},{"name":"随手","slug":"随手","permalink":"https://codeanime.cc/tags/%E9%9A%8F%E6%89%8B/"},{"name":"一言","slug":"一言","permalink":"https://codeanime.cc/tags/%E4%B8%80%E8%A8%80/"},{"name":"句子","slug":"句子","permalink":"https://codeanime.cc/tags/%E5%8F%A5%E5%AD%90/"},{"name":"数据结构","slug":"数据结构","permalink":"https://codeanime.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"归并排序","slug":"归并排序","permalink":"https://codeanime.cc/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"java","slug":"java","permalink":"https://codeanime.cc/tags/java/"},{"name":"希尔排序","slug":"希尔排序","permalink":"https://codeanime.cc/tags/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"},{"name":"插入排序","slug":"插入排序","permalink":"https://codeanime.cc/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"https://codeanime.cc/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"name":"接口","slug":"接口","permalink":"https://codeanime.cc/tags/%E6%8E%A5%E5%8F%A3/"},{"name":"选择排序","slug":"选择排序","permalink":"https://codeanime.cc/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"},{"name":"Comparable接口","slug":"Comparable接口","permalink":"https://codeanime.cc/tags/Comparable%E6%8E%A5%E5%8F%A3/"},{"name":"知识回顾","slug":"知识回顾","permalink":"https://codeanime.cc/tags/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"},{"name":"生命不息，折腾不止！","slug":"生命不息，折腾不止！","permalink":"https://codeanime.cc/tags/%E7%94%9F%E5%91%BD%E4%B8%8D%E6%81%AF%EF%BC%8C%E6%8A%98%E8%85%BE%E4%B8%8D%E6%AD%A2%EF%BC%81/"},{"name":"binary search","slug":"binary-search","permalink":"https://codeanime.cc/tags/binary-search/"},{"name":"二分法","slug":"二分法","permalink":"https://codeanime.cc/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"},{"name":"折半查找法","slug":"折半查找法","permalink":"https://codeanime.cc/tags/%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://codeanime.cc/tags/LeetCode/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://codeanime.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"程序员","slug":"程序员","permalink":"https://codeanime.cc/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"},{"name":"学习","slug":"学习","permalink":"https://codeanime.cc/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"大学","slug":"大学","permalink":"https://codeanime.cc/tags/%E5%A4%A7%E5%AD%A6/"},{"name":"API","slug":"API","permalink":"https://codeanime.cc/tags/API/"}]}